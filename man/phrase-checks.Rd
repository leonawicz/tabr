% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/phrase.R
\name{phrase-checks}
\alias{phrase-checks}
\alias{as_phrase}
\alias{phrasey}
\alias{notify}
\alias{phrase_notes}
\alias{phrase_info}
\alias{phrase_strings}
\alias{notable}
\title{Phrase validation and coercion}
\usage{
as_phrase(phrase)

phrasey(phrase)

notify(phrase)

phrase_notes(phrase, collapse = TRUE)

phrase_info(phrase, collapse = TRUE, annotations = TRUE)

phrase_strings(phrase, collapse = FALSE)

notable(phrase)
}
\arguments{
\item{phrase}{phrase object or character string (candidate phrase).}

\item{collapse}{logical, collapse result into a single string ready for
phrase construction.}

\item{annotations}{logical, strip any text annotations from the note info
converted from \code{phrase()}.}
}
\value{
see details for each function's purpose and return value.
}
\description{
These helper functions add some validation checks for phrase and candidate
phrase objects.
}
\details{
Use these functions with some caution. They are not intended for strictness
and perfection. \code{phrasey()} checks whether an object is weakly phrase-like
and returns \code{TRUE} or \code{FALSE}. It can be used to safeguard against the most
obvious cases of \code{phrase()} not containing valid phrase syntax when
programming. However, it may also be limiting. Use wear sensible.

\code{as_phrase()} coerces an object to a phrase object if possible. This function
performs an internal \code{phrasey()} check.

\code{notify()} attempts to decompose a phrase object back to its original input
vectors consisting of notes, note info, and optionally, instrument string
numbering. If successful, it returns a tibble data frame with columns:
\code{notes}, \code{info}, \code{string}.

Unless decomposing very simple phrases, this function is likely to reveal
limitations. Complex phrase objects constructed originally with \code{phrase()}
can be challenging to deconstruct in a one to one manner. Information may be
lost, garbled, or the function may fail. For example, this function is not
advanced enough to unravel repeat notation or tuplets.

\code{notable()} returns \code{TRUE} or \code{FALSE} regarding whether a phrase can be
converted back to character string inputs, not necessarily with complete
correctness, but without simple failure.It checks for phrasiness. Then it
tries to call \code{notify()} and returns \code{FALSE} gracefully if that call throws
an exception.
}
\examples{
# Create a list of phrase objects
p1 <- phrase("c ec'g' ec'g'", "4 4 2") # no string numbers (not recommended)
p2 <- phrase("c ec4g4 ec4g4", "4 4 2") # same as above
p3 <- phrase("c b, c", "4. 8( 8)", "5 5 5") # direction implies hammer on
p4 <- phrase("b2 c d", "4( 4)- 2", "5 5 5") # hammer and slide
p5 <- phrase("c ec'g'~ ec'g'", 1, "5 432 432") # tied chord
x <- list(p1, p2, p3, p4, p5)

# Check if phrases and strings are phrasey
sapply(x, phrasey)
sapply(as.character(x), phrasey, USE.NAMES = FALSE)

# Coerce character string representation to phrase and compare with original
y <- lapply(as.character(x), as_phrase)
identical(x, y)

# Check if notable
sapply(x, notable)
notable(p("a b c", 1))
notable("a b x") # note: not constructible as a phrase in the first place

# Notify phrases
d <- do.call(rbind, lapply(x, notify))
d

# Wrappers around notify extract components, default to collapsed strings
phrase_notes(p5)
phrase_info(p5)
phrase_strings(p5)

# If phrase decomposition works well, coercion is one to one
x2 <- lapply(x,
  function(x) p(phrase_notes(x), phrase_info(x), phrase_strings(x))
)
identical(x, x2)
}
