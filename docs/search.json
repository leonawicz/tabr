[{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"constructing-a-musical-phrase","dir":"Articles","previous_headings":"","what":"Constructing a musical phrase","title":"Transcription overview","text":"term phrase simply means arbitrary piece musical structure string together. phrase() takes three main arguments building phrase component parts. first gives pitches (rests) separated time spaces. chords, remove spaces indicate simultaneous notes. example, rest followed sequence pitches might notes = \"r , c f d f\". info note metadata duration. Whole notes given 1, half notes 2, quarter notes 4, , e.g., info = \"4 8 8 8 8 8 8\" (shorten info = \"4 8*6\"). example require additional information dotted notes, staccato notes, ties/slurs, slides, bends, hammer ons pull offs, etc. third argument, string applies fretted string instruments always optional. example specifies strings guitar. Providing information conjunction pitch fixes frets LilyPond guess . applies tablature output. Note x shown just placeholder indicating need specify string quarter note rest. can put string number ignored. Explicit string numbers needed example since lowest fret numbers (LilyPond default) intended. provided complete example. general approach, multiple ways create equivalent phrase objects tabr. Building phrase component parts may necessary programmatic contexts. However, manual data entry simple, interactive examples, music class offers higher level abstraction, sparing typing well cognitive load.","code":"phrase(notes = \"r a, c f d a f\", info = \"4 8*6\", string = \"x 5 5 4 4 3 4\") #> <Musical phrase> #> r4 <a,\\5>8 <c\\5>8 <f\\4>8 <d\\4>8 <a\\3>8 <f\\4>8"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"music-syntax","dir":"Articles","previous_headings":"Constructing a musical phrase","what":"Music syntax","title":"Transcription overview","text":"aside, working music class, can enter notes, note info, optionally string numbers applicable, one string. efficient data entry. can also easier follow binds otherwise separate arguments timestep. See vignettes help documentation music objects details. define music object can passed directly phrase(), understands syntax interprets notes argument music syntax info argument provided (info = NULL). fact, music object even need previously defined. string format can directly provided phrase(). Notice timestep complete within single character string . Also, durations (string numbers) can repeat implicitly explicit change occurs.","code":"as_music(\"r4 a,8 c f d a f\") #> <Music string> #>   Format: space-delimited time #>   Values: r4 a,8 c8 f8 d8 a8 f8 (p1 <- p(\"r4 a,8 c f d a f\")) #> <Musical phrase> #> r4 <a,>8 <c>8 <f>8 <d>8 <a>8 <f>8"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"tracks","dir":"Articles","previous_headings":"","what":"Tracks","title":"Transcription overview","text":"Track construction simple wrapping phrase object track(). example uses single phrase. Typically track consist many phrases concatenated together. Tracks just tibble data frames additional track class.","code":"track1 <- track(p1) track1 #> # A tibble: 1 × 7 #>   phrase       clef     key   tab   tuning    voice lyrics #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"scores","dir":"Articles","previous_headings":"","what":"Scores","title":"Transcription overview","text":"complete score composed one tracks. example single track. Just track constructor takes phrases, score constructor takes tracks inputs. Score objects tibble data frames additional score class.","code":"song <- score(track1) song #> # A tibble: 1 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"calling-lilypond-from-r","dir":"Articles","previous_headings":"","what":"Calling LilyPond from R","title":"Transcription overview","text":"score object created, ready sent LilyPond. LilyPond installed system (added system PATH variable Windows systems), tab() render_* functions call successfully. Alternatively, Windows, can added explicitly calling tabr_options(). option specify LilyPond path still available systems. example commented . However, tabr best package load set paths tabr_options() can successfully detect LilyPond installation standard file system location, may anything. Just check tabr_options() load package. paths equal empty string \"\", need set paths. Otherwise ready run LilyPond R. Technically, loading tabr Windows attempt check specific path see lilypond.exe exists . , path tabr_options() filled . Therefore, need specify LilyPond path PATH environment variable nothing shows tabr_options(), path shown probably installed LilyPond.","code":"# For example if path to `/bin` not set (edit depending on your installation) # tabr_options(lilypond = \"C:/lilypond-2.24.2/bin/lilypond.exe\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"score-metadata","dir":"Articles","previous_headings":"","what":"Score metadata","title":"Transcription overview","text":"ensuring LilyPond accessible, one function left call series steps produce sheet music. tab() takes several arguments, many optional default values. However, since music variable makes sense specify arguments every time. arguments include metadata piece key signature, time signature, tempo, title, author, . needed , good practice least unambiguous music specify key signature, time signature tempo. log output printed R console. Load new pdf file see result. look like .","code":"tab(song, \"phrase.pdf\", key = \"dm\", time = \"4/4\", tempo = \"4 = 120\") #> #### Engraving score to phrase.pdf #### #> GNU LilyPond 2.18.2 #> Processing `./phrase.ly' #> Parsing... #> Interpreting music... #> Preprocessing graphical objects... #> Interpreting music... #> MIDI output to `./phrase.mid'... #> Finding the ideal number of pages... #> Fitting music on 1 page... #> Drawing systems... #> Layout output to `./phrase.ps'... #> Converting to `./phrase.pdf'... #> Success: compilation successfully completed"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-basics.html","id":"piping","dir":"Articles","previous_headings":"","what":"Piping","title":"Transcription overview","text":"tabr functions designed support piping. Even given series steps phrase rendered pdf, short example like require single assignment. steps involved building structure rendering output performed follows. music can quite complex full score much longer, tabr strives minimize work still forcing sense organized structure. long complex music, can require effort practice ensure approach transcription R code opaque. recap, phrase() defined, added track(), track added score(), score rendered tablature pdf file tab() render_* function. next tutorial section discusses phrases detail provides overview different notes note metadata can specified constructing phrase.","code":"p(\"r a2 c f d a f\", \"4 8*6\") |> track() |> score() |>   tab(\"phrase.pdf\", key = \"dm\", time = \"4/4\", tempo = \"4 = 120\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chordchart.html","id":"prepare-chords","dir":"Articles","previous_headings":"","what":"Prepare chords","title":"Render chord charts","text":"consistency, render_chordchart() takes chord input way score() , named character vector. chords names format. Filter guitarChords dataset chords: whose root note either C F chords either 7th, major 7th, minor 7th chords contain sharps fret number root note higher 12","code":"library(dplyr)  chords <- filter(   guitarChords,    root %in% c(\"c\", \"f\") &      id %in% c(\"7\", \"M7\", \"m7\") &     !grepl(\"#\", notes) & root_fret <= 12   ) |>   arrange(root, id)  chords <- setNames(chords$fretboard, chords$lp_name) head(chords) #>              c:7              c:7              c:7              c:7  #>   \"x;3;2;3;1;x;\"   \"x;3;5;3;5;3;\"   \"x;3;2;3;1;3;\"  \"8;10;8;9;8;8;\"  #>              c:7             c':7  #>   \"8;x;8;9;8;x;\" \"x;x;10;9;11;8;\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chordchart.html","id":"render-chord-chart","dir":"Articles","previous_headings":"","what":"Render chord chart","title":"Render chord charts","text":"filtering results 41 chords. size fretboard diagrams increased size = 2. Like lilypond() render_* functions wrap around rendering music scores, render_chordchart() also takes header paper named list arguments. named chord vector ready, rendering chord chart simple following.  chord chart template must kept one page.","code":"hdr <- list(   title = \"Dominant 7th, major 7th and minor 7th chords\",   subtitle = \"C and F root\" ) render_chordchart(chords, \"out.png\", 2, hdr, list(textheight = 175))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"chord-syntax","dir":"Articles","previous_headings":"","what":"Chord syntax","title":"Chords","text":"Like individual pitches, chords combinations simultaneous pitches can specified multiple equivalent ways. difference spaces notes. following equivalent ways specify open C major chord. shown completeness, remember octave tick format used; number format limited utility contexts. notes chord tied next, convenient use tie() avoid write ~ explicitly note chord. Similar notes, explicit string numbers passed string argument also remove spaces individual string numbers. Recall inferred strings first (lowest number) string given, well expansion operator. Recycling works single value.","code":"phrase(\"cegc'e' c3e3g3c4e4 cegc4e4\", 4) #> <Musical phrase> #> <c e g c' e'>4 <c e g c' e'>4 <c e g c' e'>4 tie(\"cegc'e'\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <c~e~g~c'~e'~> chords <- \"cegc'e' c3e3g3c4e4 cegc4e4\" x <- phrase(chords, 4, \"54321 54321 54321\") identical(phrase(chords, 4, \"5*3\"), x) #> [1] TRUE identical(phrase(\"cegc'e'*3\", 4, 5), x) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"chord-syntax-for-fretboard-diagrams","dir":"Articles","previous_headings":"","what":"Chord syntax for fretboard diagrams","title":"Chords","text":"Chord diagrams refer fretboard diagrams commonly displayed sheet music written guitar. chord diagram specifications passed score(), discussed next section brings together overall process moving phrases tracks score. , syntax used specify chords chord diagrams introduced. chords appear song. Note minor chord names, indicated m, one available chord modifiers. modifiers come separator :. different key signatures can expressed throughout tabr, just \"dm\" example, modifiers follow colon general uses chord diagrams. examples moment. chords also require position descriptions, chord can played many ways. part fully defines chord diagram. standard, x means string played o refers open string. numbers refer fret. string six characters representing strings six one (low high pitch) left right.","code":"chord_names <- c(\"d:m\", \"f\", \"g:m\", \"a\") chord_positions <- c(\"xxo231\", \"133211\", \"355333\", \"xo222o\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"named-vector-input","dir":"Articles","previous_headings":"Chord syntax for fretboard diagrams","what":"Named vector input","title":"Chords","text":"chord positions named vector, need pass positions names separately chord_set(). check first argument names looking second argument. Analogous phrase(), chord_set() simple function manipulates input strings named character vector chord entries format understood LilyPond.","code":"chords <- chord_set(chord_positions, chord_names) chords #>            d:m              f            g:m              a  #> \"x;x;o;2;3;1;\" \"1;3;3;2;1;1;\" \"3;5;5;3;3;3;\" \"x;o;2;2;2;o;\" names(chord_positions) <- chord_names identical(chords, chord_set(chord_positions)) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"chord-chart","dir":"Articles","previous_headings":"Chord syntax for fretboard diagrams","what":"Chord chart","title":"Chords","text":"Next, demonstrate chord chart, make dummy song include chord set. output dummy song now contains chord chart centered top first page sheet music.","code":"p(\"r\", 1) |> track() |> score(chords) |> tab(\"ex13.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"details","dir":"Articles","previous_headings":"Chord syntax for fretboard diagrams","what":"Details","title":"Chords","text":"next example highlights several facts chord specification fretboard diagrams chord charts. chord modifiers besides common m follow : separator including chords suspended second forth chords. See first two chords . Common modifiers include m, 7, m7, dim, dim7, maj7, 6, sus2, sus4, aug, 9. Chord inversions, simply chord described chord combined alternate bass root note, examples chords notated /<note>. suffixed chord regardless whether places otherwise unmodified chord chord modifier. See next two chords . Leading x inferred. See . Chords including 2-digit fret numbers require using spaces semicolons delimiter. mix two. See fifth chord . chord name can assigned different chord positions. See next two chords , D minor. Number strings instrument inferred number entries chord string. However, currently support different numbers strings. See final chord , attempts add seventh (unplayed) string, duplicating first Asus2 chord. x marked output, string appears. Similarly, fewer strings indicated fret positions provided, instrument fewer six strings, results erroneously applying subset six guitar strings fretboard diagram. general support may come later. chord vector used purposes (see next section chord sequences) happens contain r s entries rests silent rests, passed chord_set() ignored generating chord charts. chord chart displays chords order defined.","code":"chords <- c(\"xo22oo\", \"o223o\", \"xxx565\", \"786\", \"10 10 10 8\", \"o231\", \"765\", \"o22oo\", NA, NA) names(chords) <- c(\"a:sus2\", \"a:sus4\", \"f/c\", \"g:m/d\", \"f\", \"d:m\", \"d:m\", \"a:sus2\", \"r\", \"s\") chords <- chord_set(chords) p(\"r\", 1) |> track() |> score(chords) |> tab(\"ex14.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"chord-symbols-and-sequences","dir":"Articles","previous_headings":"","what":"Chord symbols and sequences","title":"Chords","text":"already seen chord symbols, placed fretboard diagrams . Chord symbols refer shorthand chord notation, chord labels, often shown chord diagrams well music staff beginning measures chord change. familiar labels C Dm F# F/C. next use chords placement staff time. chord sequence. order place chord symbols time music staff, necessary specify sequence duration chord, just like required notes chords shown inside staff created sequence phrase objects. two examples uses simple melody arpeggiated, broken chords played using chords C, F G. chord symbols shown staff appropriate point time based defined chord sequence.","code":"notes <- \"c e g c' e' c' g e g b d' g' f a c' f' c e g e c\" info <- c(\"8*20 2\", \"4*20 1\") strings <- pc(c(5:1, 2:4, 4:1, 4:1, 5:3, 4:5)) # almost not needed, but for 1st 2 notes of G chord p1 <- p(notes, info[1], strings) p2 <- p(notes, info[2], strings) chords <- chord_set(c(c = \"32o1o\", f = \"3211\", g = \"5433\", r = NA, s = NA))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"chord-sequence","dir":"Articles","previous_headings":"Chord symbols and sequences","what":"Chord sequence","title":"Chords","text":"first version, chord change halfway measure. Assign beat duration information chord sequence just info argument phrase(), e.g., half measure given 2. C chord played full measure times F G chords last half measure. chord sequence named just like chords . correct chord symbol applied staff correct time. Taking names directly chords chord dictionary song suggested way avoid type chord symbols repeatedly. Finally, score() takes chord_seq argument chords argument. Building previous example, passed score().","code":"chord_seq <- c(1, 2, 2, 1) names(chord_seq) <- names(chords)[c(1, 3:1)] # C G F C track(p1) |> score(chords, chord_seq) |> tab(\"ex15.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"using-rests","dir":"Articles","previous_headings":"Chord symbols and sequences","what":"Using rests","title":"Chords","text":"Version two double duration notes. Now C chord lasts two full measures F G chords played one measure . can always specify chord every measure, case providing C chord sequence twice row one measure . However, example uses rests. Note inclusion r s current chords vector. illustrate rests factor chord sequences, silent rest used measure two. avoids showing C chord twice row without chord change . Nothing shown staff point time. final measure phrase uses regular rest, silent. leads “chord” symbol N.C. printed staff. show chord lasting longer measure providing values less one. example also shows simple also common case song every chord chord sequence last exactly one measure.","code":"chord_seq <- rep(1, 6) names(chord_seq) <- names(chords)[c(1, 5, 3:1, 4)] # C (s) G F C (r) track(p2) |> score(chords, chord_seq) |> tab(\"ex16.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-chords.html","id":"overall-picture","dir":"Articles","previous_headings":"Chord symbols and sequences","what":"Overall picture","title":"Chords","text":"Since chord chart included shown prior examples zoomed , result showing full sheet, includes staves chord symbols, chord chart positioned top center, perspective page numbering top right corner.  sum , chords used tabr three ways. Using phrase(), appear among notes staves core component music transcription. also used score() generate chord charts using fretboard diagrams summarize chords occur song. Finally, chord symbols can listed sequence corresponding durations applied music staff, showing chord progression throughout song proper time.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"rendering","dir":"Articles","previous_headings":"","what":"Rendering","title":"Render scores","text":"lilypond() function creates LilyPond file (.ly). Various rendering functions wrap lilypond() combine steps creating intermediary LilyPond file rendering pdf png. general render function tab(), naming consistency can also called render_tab(). render_* functions exist including render_score() render_midi(), focus rendering non-tablature, -purpose sheet music rendering corresponding MIDI file, respectively. examples vignette focus tab(). can set keep_ly = TRUE render functions retain intermediary LilyPond file. now seen many calls tab() throughout vignettes order show full examples previously. sufficient coverage phrases, tracks scores, progression , now time go detail arguments can supplied part rendering engraving process apply entire piece sheet music.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"score-metadata","dir":"Articles","previous_headings":"","what":"Score metadata","title":"Render scores","text":"critical components can supplied lilypond(). key specifies global key signature, e.g. key =\"dm\". Key signatures set individual track override global key, global key used track whose key NA. Key changes middle song supported, can always edit LilyPond file directly make custom changes. time gives time signature, defaulting common time, \"4/4\". tempo provides song tempo, defaulting tempo = \"2 = 60\", LilyPond default. can read 60 half note beats per minute. Note key takes tabr key signature notation, time tempo used mostly transcription context like , take values match LilyPond format. Throughout tutorial section, guitar bass example section tracks scores reused. chord chart chord sequence retained provide complete illustration rendered score. completeness, far. time rendering song, use settings three arguments discussed . Given written, doesn’t make sense change . example, won’t fit well waltz (time = \"3/4\"). illustration purposes, pretend song actually key D minor (F major). key one flat, Bb, affect display B note G chord. Change time 2/2 just sake changing , won’t really different 4/4 except see line common time symbol. Finally, change tempo 4 = 120, also equivalent default, show output slightly differently well.  Notice key change alone, added room single flat symbol squeezed start treble bass clef staves, enough line wrap compared previous tutorial section fit one line. tight fit previous examples enough room LilyPond continue fitting everything one line slight widening created key change. LilyPond generates sheet music somewhat responsive layout engraver. won’t necessarily leave everything one line push single measure line two.","code":"voice1 <- rp(p(\"c5 d5 e5 f5 g5\", \"1 2 4 4 1\", \"1*5\"), 2)  notes <- \"c e g c' e' c' g e g b d' g' f a c' f' c e g e c\" strings <- \"5 4 3 2 1 2 3 4 4 3 2 1 4 3 2 1 5 4 3 4 5\" voice2 <- rp(p(notes, \"8*20 2\", strings), 2)  bass <- rp(p(\"c2e2*4 g1*2 f1*2 c2e2*3\", \"4*10 2\", \"32*4 4*4 32*3\"), 2)  t1 <- track(voice1, voice = 1) t2 <- track(voice2, voice = 2) t3 <- track(bass, clef = \"bass_8\", tuning = \"bass\")  chords <- chord_set(c(c = \"x32o1o\", g = \"355433\", f = \"133211\")) chord_seq <- rep(setNames(c(1, 2, 2, 1), names(chords)[c(1:3, 1)]), 3) chords #>              c              g              f  #> \"x;3;2;o;1;o;\" \"3;5;5;4;3;3;\" \"1;3;3;2;1;1;\" chord_seq #> c g f c c g f c c g f c  #> 1 2 2 1 1 2 2 1 1 2 2 1 song <- trackbind(t1, t2, t3, id = c(1, 1, 2)) |> score(chords, chord_seq) song #> # A tibble: 3 × 8 #>   phrase       clef     key   tab   tuning     voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>      <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'      1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'      2 NA         1 #> 3 <phrase [1]> bass_8   NA    TRUE  e,,a,,d,g,     1 NA         2 lilypond(song, \"ex32.ly\", \"dm\", \"2/2\", \"4 = 120\") tab(song, \"ex32.pdf\", \"dm\", \"2/2\", \"4 = 120\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"output-file","dir":"Articles","previous_headings":"Score metadata","what":"Output file","title":"Render scores","text":"output file specified file ends pdf every example. However, can switch png. Output inferred file extension. file can relative absolute path file.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"song-information","dir":"Articles","previous_headings":"","what":"Song information","title":"Render scores","text":"next important argument lilypond() header. header takes named list character strings used fill general song information title composer. previous examples blank tabs none information ever provided. example given uses available arguments. can use subset . requirement supply . example just shows available. Several likely used cases.  copyright tagline cutoff image, pdf see scroll bottom rendered page.","code":"header <- list(   title = \"Song title\",   composer = \"Words and music by the composer\",   performer = \"Song performer\",   album = \"Album title\",   subtitle = \"Subtitle\",   arranger = \"Arranged by tab arranger\",   copyright = \"2018 <Record Label>\",   instrument = \"guitar and bass\",   tagline = \"A tagline\",   meter = \"meter tag\", opus = \"opus tag\", piece = \"piece tag\", poet = \"poet tag\" )  tab(song, \"ex33.pdf\", header = header)"},{"path":[]},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"midi-files","dir":"Articles","previous_headings":"Other settings","what":"MIDI files","title":"Render scores","text":"probably noticed now every time pdf rendered, accompanying MIDI file also generated. can turned midi = FALSE. specification goes LilyPond file via lilypond(). Therefore, MIDI output created even create LilyPond file lilypond() convert pdf LilyPond outside R. One thing note MIDI files tabr unfold repeats occur song due calls rp(), pct() volta(). allows MIDI file play everything proper number times rather ending prematurely able read repeat notation. Also, tabr package aimed creating guitar tablature. concerned MIDI audio signals audio data general. MIDI functionality considered extra feature receive priority development support. time, way make alterations MIDI file internals. MIDI output can toggled mentioned. without anything, MIDI output respect repeat notation rendered LilyPond file. MIDI output also automatically transposed match transposition applied music staff (reasonable simplified conditions).","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"string-names","dir":"Articles","previous_headings":"Other settings","what":"String names","title":"Render scores","text":"string_names relevant tablature staves. argument defaults NULL. means standard tuning never specified alongside lines tab staff beginning tablature. However, tuning explicitly noted reader aware alternate tuning applicable track. can also set TRUE force tunings explicit including standard guitar tuning FALSE suppress (though unclear value FALSE setting).","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"paper-and-color-settings","dir":"Articles","previous_headings":"Other settings","what":"Paper and color settings","title":"Render scores","text":"nominal level control paper layout via paper. Like header, named list. defaults fine probably need alter values. six options, numeric except page_numbers, logical. textheight linewidth indent first_page_number page_numbers fontsize pass values named list paper, passed retain built defaults. supply using paper. also global color settings. can pass named list colors following. Values hex colors R color names. color background staff_lines time clef beam head stem accidental detail settings others , see help documentation lilypond().","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"png-output","dir":"Articles","previous_headings":"","what":"PNG output","title":"Render scores","text":"examples make use png-specific options function behavior. First, rendering png instead pdf, automatic cropping image attempted. removes full page appearance smaller snippets sheet music. limitations . example, inclusion header elements can disrupt behavior.  , height automatically cropped file type png. Providing textheight paper overrides behavior. width also cropped . However, inclusion header arguments, fails explicit linewidth needed. Similarly, elements describe footer content (still part LilyPond header block) appear bottom page tagline copyright included, automatic height cropping also failed. general, automatic cropping default png output, header disrupts , requiring manual overrides width height. example , remove header content. can make transparent background png, though won’t able see difference . Instead, create dark mode example increase resolution. Since single voice, single track, need explicitly call function transcription pipeline. Use one convenient render_music* functions abstract process, rendering sheet music directly music object. render_music_guitar() good default arguments example.","code":"x <- pitch_seq(\"e,\", 24, key =\"c\") |> as_music(8) |> p() |> track() |> score()  ppr <- list(linewidth = 60, page_numbers = FALSE) hdr <- list(title = \"Notes in C on guitar\", subtitle = \"Standard tuning\") tab(x, \"ex_png1.png\", tempo = NULL, midi = FALSE, header = hdr, paper = ppr) colors <- list(color = \"#e4e4e4\", background = \"gray10\", head = \"tomato\", tabhead = \"tomato\")  x <- as_music(pitch_seq(\"e,\", 24, key =\"c\"), 8) |>    render_music_guitar(\"ex_png2.png\", colors = colors, res = 300)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"the-lilypond-file","dir":"Articles","previous_headings":"","what":"The LilyPond file","title":"Render scores","text":"Finally, familiarize LilyPond file . may output file want make additional edits directly. example also demonstrates differences simplify = TRUE simplify = FALSE. simple piece music possible syntax simplifications shown . phrase() objects robust structure advantages performing object manipulations R, verbose version LilyPond syntax. default, lilypond() well associated render_* functions simplify efficient syntax less cumbersome read work LilyPond files directly.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"original-syntax","dir":"Articles","previous_headings":"The LilyPond file","what":"Original syntax","title":"Render scores","text":"simplifications notable benefits removal <> around single notes repeating consecutive durations unchanged previous timesteps.","code":"lilypond(song, \"song.ly\", simplify = FALSE) cat(readLines(\"song.ly\"), sep = \"\\n\") #> \\version \"2.23.6\" #> #(ly:set-option 'crop #t)\\paper{ #>   line-width=150\\mm #>   oddFooterMarkup = ##f #>   oddHeaderMarkup = ##f #>   bookTitleMarkup = ##f #>   scoreTitleMarkup = ##f #>   indent = 0.\\mm #>   first-page-number = 1 #>   print-page-number = ##t #>   print-first-page-number = ##t #> } #>  #> #(set-global-staff-size 10) #> \\header { #>   title = \"\" #>   subtitle = \"\" #>   composer = \"\" #>   arranger = \"\" #>   instrument = \"\" #>   metre = \"\" #>   opus = \"\" #>   piece = \"\" #>   poet = \"\" #>   copyright = \"\" #>   tagline = \"\" #> } #> \\include \"predefined-guitar-fretboards.ly\" #>  #> #(define fb1 (make-fretboard-table)) #> \\storePredefinedDiagram #fb1 \\chordmode{c} #guitar-tuning \"x;3;2;o;1;o;\" #> #(define fb2 (make-fretboard-table)) #> \\storePredefinedDiagram #fb2 \\chordmode{g} #guitar-tuning \"3;5;5;4;3;3;\" #> #(define fb3 (make-fretboard-table)) #> \\storePredefinedDiagram #fb3 \\chordmode{f} #guitar-tuning \"1;3;3;2;1;1;\" #>  #> global = { #>   \\time 4/4 #>   \\tempo 2 = 60 #>   \\bar \"|.\" #> } #>  #> global_key = { #>  \\key c \\major  #> } #>  #> mychorddiagrams = \\chordmode { #>   \\set predefinedDiagramTable = #fb1 c #>   \\set predefinedDiagramTable = #fb2 g #>   \\set predefinedDiagramTable = #fb3 f #> } #>  #> chordNames = \\chordmode { #>   \\override ChordName.font-size = #2 #>   \\global #>   c1 g2 f2 c1 c1 g2 f2 c1 c1 g2 f2 c1 #> } #>  #> \\markup\\vspace #3 #> \\markup \\fill-line { #>   \\score { #>     << #>       \\context ChordNames { \\mychorddiagrams } #>       \\context FretBoards { #>         \\override FretBoards.FretBoard.size = #1.2 #>         \\mychorddiagrams #>       } #>     >> #>   \\layout {} #>   } #> } #> \\markup\\vspace #3 #>  #> melodyAA = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\voiceOne \\repeat unfold 3 { <c''\\1>1 <d''\\1>2 <e''\\1>4 <f''\\1>4 <g''\\1>1 } #> } #>  #> melodyAB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\voiceTwo \\repeat unfold 3 { <c\\5>8 <e\\4>8 <g\\3>8 <c'\\2>8 <e'\\1>8 <c'\\2>8 <g\\3>8 <e\\4>8 <g\\4>8 <b\\3>8 <d'\\2>8 <g'\\1>8 <f\\4>8 <a\\3>8 <c'\\2>8 <f'\\1>8 <c\\5>8 <e\\4>8 <g\\3>8 <e\\4>8 <c\\5>2 } #> } #>  #> melodyB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\repeat unfold 3 { <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <g,,\\4>4 <g,,\\4>4 <f,,\\4>4 <f,,\\4>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>2 } #> } #>  #> midimelodyAA = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\unfoldRepeats { \\voiceOne \\repeat unfold 3 { <c''\\1>1 <d''\\1>2 <e''\\1>4 <f''\\1>4 <g''\\1>1 } #>  }} #>  #> midimelodyAB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\unfoldRepeats { \\voiceTwo \\repeat unfold 3 { <c\\5>8 <e\\4>8 <g\\3>8 <c'\\2>8 <e'\\1>8 <c'\\2>8 <g\\3>8 <e\\4>8 <g\\4>8 <b\\3>8 <d'\\2>8 <g'\\1>8 <f\\4>8 <a\\3>8 <c'\\2>8 <f'\\1>8 <c\\5>8 <e\\4>8 <g\\3>8 <e\\4>8 <c\\5>2 } #>  }} #>  #> midimelodyB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\unfoldRepeats { \\repeat unfold 3 { <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <g,,\\4>4 <g,,\\4>4 <f,,\\4>4 <f,,\\4>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>4 <c,\\3 e,\\2>2 } #>  } #> } #>  #> \\score {  << #>   \\new ChordNames \\chordNames #>   \\new Staff << \\clef \"treble_8\" \\global_key \\context Voice = \"melodyAA\" \\melodyAA \\context Voice = \"melodyAB\" \\melodyAB >> #>   \\new TabStaff \\with { stringTunings = \\stringTuning <e, a, d g b e'> } << #>     \\override Stem.transparent = ##t #>     \\override Beam.transparent = ##t #>     \\context TabVoice = \"melodyAA\" \\melodyAA \\context TabVoice = \"melodyAB\" \\melodyAB #>   >> #>   \\new Staff << \\clef \"bass_8\" \\global_key \\melodyB >> #>   \\new TabStaff \\with { stringTunings = \\stringTuning <e,, a,, d, g,> } << #>     \\set TabStaff.instrumentName = \\markup  { \\hspace #7 \\override #'(baseline-skip . 1.5)  \\column \\fontsize #-4.5 \\sans { G D A E } } #>     \\override Stem.transparent = ##t #>     \\override Beam.transparent = ##t #>     \\melodyB #>   >> #>   >> #>   \\layout{ } #> } #>  #> \\score {  << #>   \\midimelodyAA #>   \\midimelodyAB #>   \\midimelodyB #>   >> #>   \\midi{ #>     \\tempo 2 = 60 #>   } #> }"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-engraving.html","id":"simplified-syntax","dir":"Articles","previous_headings":"The LilyPond file","what":"Simplified syntax","title":"Render scores","text":"can see changes notation. Since music short example, file remains .","code":"lilypond(song, \"song.ly\") cat(readLines(\"song.ly\"), sep = \"\\n\") #> \\version \"2.23.6\" #> #(ly:set-option 'crop #t)\\paper{ #>   line-width=150\\mm #>   oddFooterMarkup = ##f #>   oddHeaderMarkup = ##f #>   bookTitleMarkup = ##f #>   scoreTitleMarkup = ##f #>   indent = 0.\\mm #>   first-page-number = 1 #>   print-page-number = ##t #>   print-first-page-number = ##t #> } #>  #> #(set-global-staff-size 10) #> \\header { #>   title = \"\" #>   subtitle = \"\" #>   composer = \"\" #>   arranger = \"\" #>   instrument = \"\" #>   metre = \"\" #>   opus = \"\" #>   piece = \"\" #>   poet = \"\" #>   copyright = \"\" #>   tagline = \"\" #> } #> \\include \"predefined-guitar-fretboards.ly\" #>  #> #(define fb1 (make-fretboard-table)) #> \\storePredefinedDiagram #fb1 \\chordmode{c} #guitar-tuning \"x;3;2;o;1;o;\" #> #(define fb2 (make-fretboard-table)) #> \\storePredefinedDiagram #fb2 \\chordmode{g} #guitar-tuning \"3;5;5;4;3;3;\" #> #(define fb3 (make-fretboard-table)) #> \\storePredefinedDiagram #fb3 \\chordmode{f} #guitar-tuning \"1;3;3;2;1;1;\" #>  #> global = { #>   \\time 4/4 #>   \\tempo 2 = 60 #>   \\bar \"|.\" #> } #>  #> global_key = { #>  \\key c \\major  #> } #>  #> mychorddiagrams = \\chordmode { #>   \\set predefinedDiagramTable = #fb1 c #>   \\set predefinedDiagramTable = #fb2 g #>   \\set predefinedDiagramTable = #fb3 f #> } #>  #> chordNames = \\chordmode { #>   \\override ChordName.font-size = #2 #>   \\global #>   c1 g2 f2 c1 c1 g2 f2 c1 c1 g2 f2 c1 #> } #>  #> \\markup\\vspace #3 #> \\markup \\fill-line { #>   \\score { #>     << #>       \\context ChordNames { \\mychorddiagrams } #>       \\context FretBoards { #>         \\override FretBoards.FretBoard.size = #1.2 #>         \\mychorddiagrams #>       } #>     >> #>   \\layout {} #>   } #> } #> \\markup\\vspace #3 #>  #> melodyAA = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\voiceOne \\repeat unfold 3 { c''1\\1 d''2\\1 e''4\\1 f''\\1 g''1\\1 } #> } #>  #> melodyAB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\voiceTwo \\repeat unfold 3 { c8\\5 e\\4 g\\3 c'\\2 e'\\1 c'\\2 g\\3 e\\4 g\\4 b\\3 d'\\2 g'\\1 f\\4 a\\3 c'\\2 f'\\1 c\\5 e\\4 g\\3 e\\4 c2\\5 } #> } #>  #> melodyB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\repeat unfold 3 { <c,\\3 e,\\2>4 <c,\\3 e,\\2> <c,\\3 e,\\2> <c,\\3 e,\\2> g,,\\4 g,,\\4 f,,\\4 f,,\\4 <c,\\3 e,\\2> <c,\\3 e,\\2> <c,\\3 e,\\2>2 } #> } #>  #> midimelodyAA = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\unfoldRepeats { \\voiceOne \\repeat unfold 3 { c''1\\1 d''2\\1 e''4\\1 f''\\1 g''1\\1 } #>  }} #>  #> midimelodyAB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\unfoldRepeats { \\voiceTwo \\repeat unfold 3 { c8\\5 e\\4 g\\3 c'\\2 e'\\1 c'\\2 g\\3 e\\4 g\\4 b\\3 d'\\2 g'\\1 f\\4 a\\3 c'\\2 f'\\1 c\\5 e\\4 g\\3 e\\4 c2\\5 } #>  }} #>  #> midimelodyB = { #>  \\global #>  \\override StringNumber.transparent = ##t #>  \\unfoldRepeats { \\repeat unfold 3 { <c,\\3 e,\\2>4 <c,\\3 e,\\2> <c,\\3 e,\\2> <c,\\3 e,\\2> g,,\\4 g,,\\4 f,,\\4 f,,\\4 <c,\\3 e,\\2> <c,\\3 e,\\2> <c,\\3 e,\\2>2 } #>  } #> } #>  #> \\score {  << #>   \\new ChordNames \\chordNames #>   \\new Staff << \\clef \"treble_8\" \\global_key \\context Voice = \"melodyAA\" \\melodyAA \\context Voice = \"melodyAB\" \\melodyAB >> #>   \\new TabStaff \\with { stringTunings = \\stringTuning <e, a, d g b e'> } << #>     \\override Stem.transparent = ##t #>     \\override Beam.transparent = ##t #>     \\context TabVoice = \"melodyAA\" \\melodyAA \\context TabVoice = \"melodyAB\" \\melodyAB #>   >> #>   \\new Staff << \\clef \"bass_8\" \\global_key \\melodyB >> #>   \\new TabStaff \\with { stringTunings = \\stringTuning <e,, a,, d, g,> } << #>     \\set TabStaff.instrumentName = \\markup  { \\hspace #7 \\override #'(baseline-skip . 1.5)  \\column \\fontsize #-4.5 \\sans { G D A E } } #>     \\override Stem.transparent = ##t #>     \\override Beam.transparent = ##t #>     \\melodyB #>   >> #>   >> #>   \\layout{ } #> } #>  #> \\score {  << #>   \\midimelodyAA #>   \\midimelodyAB #>   \\midimelodyB #>   >> #>   \\midi{ #>     \\tempo 2 = 60 #>   } #> }"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex1.html","id":"r-code","dir":"Articles","previous_headings":"","what":"R code","title":"Example: alternate tuning plus capo","text":"can see notate() can often obstruct otherwise convenient opportunities code reduction. Avoiding repeating annotation means avoiding repeating whatever bound . problem percent repeats nothing show, repetitions melody end score. info mapped length 2 vector using opening note without bound text annotation, respectively. e1 e2 endings phrase p1 used default alternate endings call volta(), respectively, fail bar check; p1 alone end end measure, rather lasts measure half. example also shows single note difference end second ending, e2, ending played end arrangement, enough stop defining sensibly full phrase (p1 e1) . slightest change forces split things expand code, just like tab. music, least kind point transcribing, going change things often even repeated sections.","code":"header <- list(   title = \"Devil's got you beat\",   composer = \"Words and music Blues Saraceno\",   performer = \"Blues Saraceno\",   album = \"Dark Country 4\",   subtitle = \"From the album Dark Country 4 by Blues Saraceno\",   arranger = \"Two picking patterns arranged by Matthew Leonawicz\",   copyright = \"2016 Extreme Music\" )  txt <- c(\"DADGAD tuning with capo on 1st fret. Fingerpicking. Let ring.\") tuning <- \"d, a, d g a d'\"  # melody 1 notes <- c(pn(\"f d c d a d'\", 2), \"f g a d' f d c a,\") info <- purrr::map_chr(c(\"16(\", notate(\"16(\", txt)),                        ~pc(.x, \"16) 8 8 16 16 16( 16) 8 8 16 16 16- 16*7\")) strings <- \"4 4 5 4 2 1 4 4 5 4 2 1 4 4 2 1 4 4 5 5\" p1 <-purrr::map(info, ~p(notes, .x, strings)) e1 <- p(\"d a d' c a, f, d,\", \"8 16 16 16( 16) 16( 16)\", \"4 2 1 5 5 6 6\") e2 <- p(\"d a d' c a, f, e, d,\", \"8 16 16 16( 16) 16- 16( 1)\", \"4 2 1 5 5 6 6 6\")  #melody 2 p2 <- p(\"d a d' f d c\", \"8 16*4 8\", \"4 2 1 4 4 5\")  p_all <- c(pct(c(p1[[2]], e1), 3), volta(pct(p2, 3), 1), p1[[1]], e1, p1[[1]], e2) track(p_all, tuning = tuning) |> score() |>    tab(\"out.pdf\", \"dm\", \"4/4\", \"4 = 115\", header)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex1.html","id":"result","dir":"Articles","previous_headings":"","what":"Result","title":"Example: alternate tuning plus capo","text":"result call tab() follows.  next example refactors phrases properly represent multiple voices output.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex2.html","id":"multiple-voices","dir":"Articles","previous_headings":"","what":"Multiple voices","title":"Example: multiple voices","text":"fingerstyle guitar tab appropriate use two voices guitar part. Even though one guitar playing, thumb playing low three strings fingers playing higher strings shown two distinct voices. Multiple voices like go staff; need separate staff. voice played thumb shows notes stems pointing higher voice stems pointing . changes phrases seen earlier must split two complementary phrases. Voice ID indicated track(). now two tracks, represented different voices, different music staves. Therefore, two tracks use voice = 1 voice = 2, respectively, different tabstaff IDs. , s used instead r silent rests, required. suppresses rest notation resting voice voice active. works well melody since two voices never rest. Notice additional rests fill gaps voice now effectively inactive played. complex fingerstyle arrangements course overlap.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex2.html","id":"transposed-music-staff","dir":"Articles","previous_headings":"","what":"Transposed music staff","title":"Example: multiple voices","text":"refactoring code, take one step transpose treble clef music staff one semitone leaving tablature staff . transposition music staff relative tab staff useful score shared musicians playing instruments need see music staff written explicitly heard, rather infer play statement guitar capo position. can done specifying ms_transpose = 1 key = \"e_m\" (just key = \"flat\") track(). transposes music staff one semitone, affect tablature staff. key necessary ensuring staff written key E flat minor rather D sharp following transposition. Note call tab() still specifies key = \"dm\" since overall perspective presentation guitar tab.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex2.html","id":"final-notes","dir":"Articles","previous_headings":"","what":"Final notes","title":"Example: multiple voices","text":"last thing note reason lot octave 3 characters can omitted, need specify string argument. default chosen LilyPond turns exactly wanted. creates even room code reduction compared previous example. phrases also conveniently listed using paste() c() rep(), coerce phrases character strings, okay long eventually combined phrase objects using pc() wrapped calls like volta() pct() tabr aggressive phrase class convert back.","code":"# melody 1: voice 1 p1 <- paste(p(c(pn(\"s a d'\", 3), \"s\"), \"4. 16 16 4. 16 16 8 16 16 4\"),             c(p(\"s a d s\", \"8 16 16 4\"), p(\"s a d4 s s\", \"8 16 16 4 1\")))  # melody 1: voice 2 notes <- c(c(pn(\"f d c d s\", 2), \"f g s f d c a,\"), \"d s c a, f, d,\", \"d s c a, f, e, d,\") info <- purrr::map_chr(c(\"16(\", notate(\"16(\", txt)), ~pc(.x, \"16) 8*3 16( 16) 8*3 16- 16 8 16*4\")) p2 <- paste(unlist(purrr::map(info[c(2, 1, 1)], ~p(notes[1], .x))),             c(rep(p(notes[2], \"8 8 16( 16) 16( 16)\"), 2),                p(notes[3], \"8 8 16( 16) 16- 16( 1)\"))) p2 <- gsub(\"<g>\", \"<g\\\\\\\\4>\", p2) # force string for one note  # melody 2: voices 1 and 2 p3 <- volta(pct(p(\"s a d4 s\", \"8 16 16 4\"), 3)) p4 <- volta(pct(p(\"d s f d c\", \"8 8 16 16 8\"), 3))  t1 <- pc(pct(p1[1], 3), p3, p1[1], p1[2]) |>    track(key = \"e_m\", tuning = tuning, voice = 1) t2 <- pc(pct(p2[1], 3), p4, p2[2], p2[3]) |>    track(key = \"e_m\", tuning = tuning, voice = 2) trackbind(t1, t2, id = c(1, 1)) |> score() |>    tab(\"out.pdf\", \"dm\", \"4/4\", \"4 = 115\", header)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex2.html","id":"refactor-recap","dir":"Articles","previous_headings":"","what":"Refactor recap","title":"Example: multiple voices","text":"Notice 1 2 passed respective calls track() voice ID. Subsequently, call trackbind() two tracks assigned track staff ID, id = c(1, 1). default, providing id leads unique staff per track. common usage. Providing non-unique staff IDs throw error voice IDs single staff ID also unique. Every track must directed unique voice/staff combination. t1 t2 also transposed one semitone E flat minor use another instrument. recap code reduction: Reduce code concatenating phrases slightly different endings efficiently. Ensure code voices written way relatively easy keep lined time: note t1 t2 track assignments turned . one note arrangement whose default string LilyPond based instrument stringing tuning desired string. Instead specifying strings, fourth string forced simple character substitution using gsub(). Make sure inspect objects get good understanding phrases produced connected. can look opaque complex done number times, becomes easier read write practice.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex2.html","id":"result","dir":"Articles","previous_headings":"","what":"Result","title":"Example: multiple voices","text":"may seem like frustrating refactor sense much code changed, results small change output . However, keep mind just comparative example illustration. Normally, arrangement coded two voices begin style degree code reduction . new output shown . almost identical, , single exception change stem direction representing two voices. Note order voice 1 2 assignment determines one stem stem . voice = 1 points , voice = 2 points , assigned properly avoid obtaining backwards result. Since together tracks share one staff, order passed trackbind() actually matter . trackbind() order matters staff order, voice order within staff. general, voices staves, first last mapped top bottom output.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Example: AC2 - Ezio's family","text":"coding example demonstrates creation complete, two-guitar acoustic arrangement Ezio’s family, main theme Assassin’s Creed 2, educational purposes. arrangement combines fingerstyle arrangement, suffices , optional additional supporting rhythm guitar track. example, fingerstyle guitar easier code single voice, split two voices accurate commonly transcribed. creates bit work introduces possibility coding mistakes, purpose example demonstrate things. track played first guitar also coded using standard approach tabr, type explicit pitches. However, contrast second guitar track phrases typed using alternative string-fret approach. tabr meant . minimally supported likely approach used casual users. approach can quite convenient, also big part leads lot lazy, incomplete, ambiguous, error-prone tabbing songs littered across internet. oddly inconsistent use approaches one score, example purposes. First, enter score metadata:","code":"header <- list(   title = \"Ezio's family\",   composer = \"Written by Jesper Kyd\",   subtitle = \"Theme from Assassin's Creed 2\",   arranger = \"Arranged by Matthew Leonawicz\",   copyright = \"2009 Ubisoft Entertainment\",   tagline = paste(\"Arranged by Matthew Leonawicz\", Sys.Date()) )  txt <- \"Tune down full step: DGCFAD (Dm). Let guitar 1 ring.\" outfile <- \"jesper_kyd-ezios_family-custom_arrangement.pdf\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"guitar-1-voice-1","dir":"Articles","previous_headings":"","what":"Guitar 1 voice 1","title":"Example: AC2 - Ezio's family","text":"main fingerstyle guitar track split two voices. Voice 1 top melody played using fingers voice 2 played using thumb. First, define string number sequences note sequences used often fairly repetitive track. way make work short easy, less type better. first phrases bad. can built largely building blocks set . additional string notes introduced, along alternate ending e2 volta() repeat section. Things become complex next phrases. use longer sequences notes. p5 also relies helper function just shorten typing bit. worth looking opportunities avoid typing anything highly redundant. also type phrases length comfortable working . misplaced note can ruin everything make phrases long troubleshoot easily, become unhappy decision. Phrases, song parts, depending want call slices music notation, six ten built predefined component parts: Finally, phrases can concatenated one long phrase passed track() define first voice first track. ’s defined now many temporary object names reused subsequent voice second track.","code":"s1 <- \"1 3 2 3 1 2 3 2\" s2 <- \"1 3 2 3 2 3 1 2\" s3 <- \"x 3 2 3 1 2 3 2\"  x1 <- \"e4 g b g g4 b g b a4 g b g b4 b g b\" x2 <- gsub(\"b4\", \"g4\", x1) p1a <- p(pc(x1, x2), pc(notate(\"8\", txt), \"8*31\"), pn(s1, 4)) p1 <- p(pc(x1, x2), 8, pn(s1, 4)) p2 <- volta(p(\"e4 g b g b4 b g b a4 g b g b4 b g b\", 8, pn(s1, 2)), 3)  e2 <- p(\"e5 g b g f#5 b g b g5 g b g a5 b g b\", 8, pn(s1, 2)) e <- list(p(x2, 8, pn(s1, 2)), e2) p3 <- c(p1, p1, volta(p(pc(x1, x2, x1), 8, pn(s1, 6)), 1, e)) p4 <- c(   p(pc(     \"b5 g b g b4 b g b e5 g b g b g b4 b s g b g b4 b g b c5 g b g b g b4 b\",     \"s g b g a4 b g b b4 g b g b g a4 b s g b g b4 b g b s g g4 g a4 g b4 g\"), 8,     pc(s1, s2, s3, s2, s3, s2, s3, \"x 3 1 3 1 3 1 3\")),   rp(p(\"c5 g b g b4 b g b\", 8, s1)),   p(\"s g b g b4 b g b e5 g b g b4 b g b s g b g c5 b g b g5 g b g e5 b g b s g b g e5 b g b b4 g b g g4 g f#4 g\", 8,     pc(s3, s1, s3, s1, s3, \"1 3 2 3 1 3 1 3\")) )  f <- function(x) p(pc(x, \"g b g\", x, \"b g b s g b g\", x, \"b g b\"), 8, pc(s1, s3)) p5 <- c(   p1,   p(\"e4 g b g b4 b g b c5 g b g b4 b g b e4 g b g g4 b g b b4 g c5 b g4 g b4 b\", 8, pc(s1, s1, s1, \"1 3 1 2 1 3 1 2\")),   p(\"e4 g b g b4 b g b4 c5 g b g c5 b g b b4 g b g b4 b g b a4 g b g b4 b g b\", 8, pc(\"1 3 2 3 1 2 3 1\", s1, s1, s1)),   p(x1, 8, pn(s1, 2)),   p(\"c5 g b g b4 b g b s g b g b4 b g b\", 8, pc(s1, s3)),   f(\"c5\"), f(\"e5\"), f(\"g5\") ) p6 <- c(volta(p1), p1, p(x1, 8, pn(s1, 2)), e2) p7 <- c(   p(tp(pc(gsub(\"e4|g4\", \"b4\", x1), x2), 12, key = \"em\"), 8, pn(s1, 4)),   p(tp(pc(x1, x2), 12, key = \"em\"), 8, pn(s1, 4)) ) p8 <- c(p1, p1)  x1 <- \"e4 g b g bg4 g b g a4 g b g bb4 g b g\" x2 <- gsub(\"b4\", \"g4\", x1) x3 <- gsub(\"a4\", \"ba4\", x2) p9 <- p(pc(x1, x2, x1, x3), 8, pc(pn(\"1 3 2 3 21 3 2 3\", 7), \"21 3 2 3 21 3 2 3\")) p10 <- c(volta(p1), pn(p1, 2), p(\"e4\", 1, 1)) track1a <- track(c(p1a, p2, p3, p4, p5, p6, p7, p8, p9, p10))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"guitar-1-voice-2","dir":"Articles","previous_headings":"","what":"Guitar 1 voice 2","title":"Example: AC2 - Ezio's family","text":"second voice played thumb. less code. hardest part, however, discipline ensure two voices line perfectly one another intended. already take care notes, note info, string numbers, making phrases, must voices tracks. extra missing note one lead mess. score may may run LilyPond depending nature alignment issue, even , reveal two pieces music sync. Side note: expect example score easy follow line line. may highly familiar transcriptions, looking someone else’s fully put together, ’s likely much abstraction take sensibly, especially parts split multiple voices tracks, must visually separate code disjoint pieces even though pertains music inherently paired. second track created sequences parts, second voice must specified. two tracks bound together, two different voice IDs assigned staff ID share.","code":"p1 <- p(\"s*4\", 1, \"x\") p2 <- volta(p(\"e*2\", 1, 5), 3, silent = TRUE) x1 <- p(\"e e d d c c e2 g2 f#2\", \"1*7 2 2\", \"5 5 4 4 5 5 6*3\")  e <- list(p(\"e2 g2 f#2\", \"1 2 2\", 6), p(\"e2 g3 f#3\", \"1 2 2\", 6)) x2 <- volta(p(\"e2 e2 d d c c\", 1, \"6 6 4 4 5 5\"), 1, e, TRUE) p3 <- pc(x1, x2) p4 <- c(   p(\"e2 e2 d d c c a2 g2 f#2\", \"1*7 2 2\", \"6 6 4 4 5*3 6 6\"),   rp(p(\"e2\", 1, 6)),   p(\"d d c c e2 g2 f#2\", \"1*5 2 2\", \"4 4 6*5\") ) p5 <- p(\"e2*4 s*4 e s*5 e2*8\", 1, \"6*4 x*4 5 x*5 6*8\") p6 <- pc(volta(p(\"e2*4\", 1, 6)), p(\"e e d d c c a2 a2\", 1, \"5 5 4 4 5*4\")) p7 <- p(\"e2 s*7\", 1, \"6 x*7\")  x3 <- p(\"e2 e2 d d c c e2 g2 f#2\", \"1*7 2 2\", \"6 6 4 4 5 5 6*3\") p8 <- x3 p9 <- x3 p10 <- c(volta(p(\"e*4\", 1, 5)), x1, p(\"e2\", 1, 6)) track1b <- track(c(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10), voice = 2)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"guitar-2","dir":"Articles","previous_headings":"","what":"Guitar 2","title":"Example: AC2 - Ezio's family","text":"second guitar adds strummed rhythm section. one voice. , additional note info building blocks helpful avoiding code duplication. Explicit chords require typing single notes especially helpful make use * -string expansion operator possible. mentioned, comparison, guitar part tabbed using string-fret notation. means example instead specifying pitch e2 e, along string number play , 6, can specify string 6 fret 2 (assuming default tuning = \"standard\"). Instead phrase() alias p(), use sf_phrase() sfp(). Aside: alternate specification hastily added prior version tabr people understand tabs don’t read music general. syntax functional like package accessible many users want use , alternate syntax arguably cumbersome write actually harder read. even easier make mistakes . fit well broader design intent package. additional support syntax provided. retrospect consider mistake part added feature encourages use package way counter fundamental design purpose. point option removed tabr. Create track sequence phrases.","code":"i <- \"4 8 8\" i1 <- pn(i, 4) i2 <- pc(i, i, \"8*4\", i) i3 <- pc(i, i, \"8*4 8- 8*3\") i4 <- pc(i, i, i, \"8 8 4\") p1a <- sfp(\"5*3 5*3 5321*3 5*3\", \"75000*3 7508*3 7005*3 75007*3\", i1) p1a2 <- sfp(\"5*3 5*3 5321*3 5*3\", \"75000*3 7508*3 7005*3 7508*3\", i1) p0 <- volta(sfp(\"5*6 5321*3 5*3\", \"75000*3 75007*3 7005*3 75007*3\", i1), 3, silent = TRUE)  p1b <- sfp(\"5*13\", \"55000*3 55003*3 55005*4 55003*3\", i2) p1c <- sfp(\"5*11 1 3 3\", \"35450*3 35453*3 35455*5 7 007*2\", i3) p1d <- sfp(\"6*6 64321*6\", \"022000*3 022003*3 30005*3 20233*3\", i4) p1d2 <- sfp(\"6*6 64321*6\", \"022000*3 022002*3 30005*3 20233*3\", i1) p1d3 <- sfp(\"5*12\", \"02200*12\", i1)  p2 <- c(p1a, p1b, p1c, p1d) p3 <- volta(c(p1a, p1b, p1c), 1, list(p1d, p1d2), TRUE)  p4a <- c(sfp(\"5*12\", \"75000*12\", i1), sfp(\"5*13\", \"55000*13\", i2), sfp(\"5*13\", \"35450*13\", i2)) p4b <- sfp(\"5*6 64321*6\", \"02200*6 30005*3 20233*3\", i4) p4c <- sfp(\"6*6 64321*6\", \"022000*6 30005*3 20233*3\", i4) p4 <- c(p4a, p4b, p4a, p4c)  p5 <- sfp(\"6~ 6 5*14\", \"022000~ 022000 75000*3 7508*3 75007 75000 75008 75000 7508 75000 75007 75000\", \"1 1 4 8 8 4 8*10\")  p6 <- rep(sfp(\"5*12\", \"75000*12\", i1), 3) p7 <- rep(sfp(\"6*12\", \"022000*12\", i1), 4) p8 <- volta(c(p1a, p1a2), silent = TRUE) p9 <- c(p1a, p1b, p1c, p1d3)  p10 <- sfp(\"5~ 5421\", \"75000~ 7500\", \"1 1\") # hack around bug (double pitch full measure tie), again below (p11) p10a <- c(sfp(\"6~ 6\", \"022000~ 022000\", \"1 1\"), rep(p10, 3)) p10b <- volta(rep(p10, 2), silent = TRUE) p11 <- sfp(\"5~ 5421 5~ 5421 5~ 5 5 64321*2 6\", \"75000~ 7500 55000~ 5500 35450~ 3545 75007 30005 20233 022000\", \"1*7 2 2 1\") track2 <- track(c(p1a, p1a2, p0, p2, p3, p4, p1a, p1a2, p5, p6, p7, p8, p9, p10a, p2, p2, p10b, p11))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"chord-chart-and-chords-above-staff","dir":"Articles","previous_headings":"","what":"Chord chart and chords above staff","title":"Example: AC2 - Ezio's family","text":"Placing chord names music staff including chord chart fretboard diagrams top score goes long way improving quality score. Unfortunately, quick painless way longer scores. fretboard diagrams relatively straightforward. need create named character vector defining chords include chord chart. ’s . silent rest s ignored building chord chart, included next part used specify include chord names. placing chords staff time, however, make long vector chord names corresponding durations order insert chord appropriate position sheet music. important distinction pertains measures engraved output. means sequence necessarily number measures coded. repeat sections, specify chord names multiple times repeat. strictly specify chord name goes measure (part measure) visible sheet music. Specifying chord sequence transcription “briefly” arduous task horrendous look . Just take word chord names durations line music staff drawn output. indices used index extract chords chord_names without type repeatedly. chord_seq vector corresponding durations. example, chords mostly last whole measure (actually two). vector consists mostly value 1. 2 indicates chord lasts half measure, etc. silent rest s stored chord_names[9] used often avoid excessively printing chord name two consecutive measures since score chords tend span two measures.","code":"chord_names <- c(\"e:m\", \"e:m7/d\", \"c:maj7\", \"c:maj9\", \"e:m\", \"g:5.9\", \"g:5.9/f#\", \"e:m5.9\", \"s\", \"a:sus2\") chord_positions <- c(\"x75ooo\", \"x55ooo\", \"x3545o\", \"x35435\", \"o22ooo\", \"3xooo5\", \"2xo233\", \"o22oo2\", NA, \"xo22oo\") chords <- chord_set(chord_positions, chord_names) x <- c(1, rep(9, 5), 1, 9, 2, 9, 3:7,         1, 9, 2, 9, 3:7, 5, 8, 6, 7,         1, 9, 2, 9, 3, 9, 10, 6:7, 1, 9, 2, 9, 3, 9, 5:7,         1, rep(9, 25),         1, 9, 2, 9, 3:4, 10, 9,         1, rep(9, 7), 1, 9, 2, 9, 3:7,         1, 9, 2, 9, 3:7,         1, rep(9, 3), 1, 9, 2, 9, 3, 9, 1, 6, 7, 1)  chord_seq <- c(rep(1, 13), 2, 2,                 rep(1, 7), rep(2, 6),                 rep(1, 7), 2, 2,                 rep(1, 7), 2, 2,                 rep(1, 26),                 rep(1, 8),                 rep(1, 8),                 rep(1, 7), 2, 2,                 rep(1, 7), 2, 2,                 rep(1, 11), 2, 2, 1)  names(chord_seq) <- chord_names[x]"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"create-tablature","dir":"Articles","previous_headings":"","what":"Create tablature","title":"Example: AC2 - Ezio's family","text":"Finally, bind three tracks together, specifying two tab staves two guitars assigned . guitar also music staff tab staff. bound tracks passed score(), chords chord sequence provided include chord chart chord names staff. score passed tab() along metadata tablature rendered LilyPond. sheet music six pages. preview page one.  One thing note arrangement written Em view arrangement guitar, essentially “reverse capo” six strings tuned equally full step. sound Dm, full step written. Rather transpose music staves write score awkwardly, simply stated arrangement sounds lower written, often done using capo transpose direction simply providing capo fret.","code":"trackbind(track1a, track1b, track2, id = c(1, 1, 2)) |>   score(chords, chord_seq) |>   tab(outfile, key = \"em\", time = \"4/4\", tempo = \"4 = 120\", header)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex3.html","id":"limitations","dir":"Articles","previous_headings":"","what":"Limitations","title":"Example: AC2 - Ezio's family","text":"example arrangement highlights limitations tabr. First, see tablature output, including music staff tab staff, music staff show pitch twice chord played guitar includes pitch played two different strings. annoying imperfection, problematic. can see p10 p11 drop redundant note second tied chord pair. hack solve problem, leads output less frustrating otherwise. see difference, add notes back rerender score. Another limitation can seen slide string one highest note strummed chord higher single note string. rendered LilyPond engraver slide bottom note chord instead top note. Currently also straight forward specify add 9 chords. can see 9th chord names output, supposed add 9 chords.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex4.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Example: Gin Wigmore - Devil in me","text":"coding example demonstrates creation complete arrangement Devil Gin Wigmore, whose music one original inspirations writing sheet music transcription code tabr. custom arrangement written R code educational purposes. enjoy playing Gin Wigmore’s music guitar, frustrating able find quality guitar tablature reference. course, case vast majority music. tabs helped figure guitar parts found challenging hear clearly layered instruments vocals. end, recourse best figuring guitar track ear. ’s perfect, custom arrangement need exactly like recording, ’s pretty close. now can reproduce arrangement code. tutorial shows use phrase class music class entering notes chords building score.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex4.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Example: Gin Wigmore - Devil in me","text":"First, enter score metadata. Define guitar chords specific shapes positions guitar neck used several times.","code":"hdr <- list(   title = \"Devil in me\",   composer = \"Words and music by Gin Wigmore\",   performer = \"Gin Wigmore\",   album = \"Gravel and Wine\",   subtitle = \"From the album Gravel and Wine by Gin Wigmore\",   arranger = \"Arranged by Matthew Leonawicz\",   copyright = \"2011 Island Records\",   tagline = paste(\"Arranged by Matthew Leonawicz\", Sys.Date()) )  out <- \"gin_wigmore-devil_in_me-custom_arrangement.pdf\" d1 <- \"dad'f'\" f1 <- \"f,cfac'f'\" g1 <- \"g,dgb_d'g'\" a1 <- \"a,eac#'e'\" b_1 <- \"b_,fb_d'f'\" c1 <- \"cegc'e'\" b_2 <- \"b_d'f'b_'\" c2 <- \"c'e'g'c''\" f2 <- \"c'f'a'c''\" d2 <- \"d'f'a'\" f3 <- \"c'f'a'\" g2 <- \"d'g'b_'\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex4.html","id":"chord-chart-and-chord-symbols-above-staff","dir":"Articles","previous_headings":"","what":"Chord chart and chord symbols above staff","title":"Example: Gin Wigmore - Devil in me","text":"Next provide code fretboard diagrams compose chord chart top first page sheet music. requires fretted strings chord symbols identify chord. code defining chord chart. wondering, NA value silent rest s. important used indicate measures chord symbol shown. chord chart pretty easy. cumbersome step laying chord symbols staff time measure measure. , need know plan annotate staff measure, also accounting use volta repeat sections, effectively reduce number measures display sheet music compared many really exist. code defining chord sequence.","code":"chord_names <- c(\"d:m\", \"f\", \"g:m\", \"a\", \"b_\", \"c\", \"s\", \"b_\", \"c\", \"f\", \"d:m\", \"f/c\", \"g:m/d\") chord_positions <- c(\"o231\", \"133211\", \"355333\", \"o222o\", \"13331\", \"32o1o\",                      NA, \"8766\", \"10 9 8 8\", \"10 10 10 8\", \"765\", \"565\", \"786\") chords <- chord_set(chord_positions, chord_names) intro <- rep(c(1:3, 1), each = 2) verse <- list(   c(rep(rep(1:3, each = 2), 2), rep(1:2, each = 2), 3, 4),   c(rep(1:3, each = 2), rep(1:2, each = 2), 3, 4) ) chorus <- c(5:6, 2:1, 5:6) interlude <- list(rep(1:2, each = 2), rep(c(1, 2, 1, 2, 1, 5, 1, 4), each = 2)) ending <- c(7, 1) name_seq <- chord_names[c(intro, verse[[1]], chorus, interlude[[1]],                           verse[[2]], chorus, interlude[[2]], chorus, ending)] measures <- length(c(intro, unlist(verse), rep(chorus, 3), unlist(interlude), ending)) chord_seq <- rep(1, length(name_seq)) |> setNames(name_seq)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex4.html","id":"guitar-1-melody-and-lead","dir":"Articles","previous_headings":"","what":"Guitar 1: melody and lead","title":"Example: Gin Wigmore - Devil in me","text":"Now things get interesting. time write code main guitar. main melody. includes lead guitar bits guitar solo. Since track display tablature output first staff, use one including text annotations. Putting pieces together, done using several phrases . Notice much easier add annotations using as_music(), takes labels arguments. Also, using phrase() directly (actually alias p()), notation still provided efficient single-string syntax used music class. provide syntax, phrase() recognize treat already created music object as_music(). can also concatenate classes together, resulting new phrase object. last step concatenate phrases proper order full track.","code":"txt <- c(\"Guitar 1 w/ tremolo. Guitars 3 and 4 rhythm figures played during intro.\",          \"Add guitar 3 intro rhythm figure during intro lead repeat.\",          \"Add guitar 4 intro rhythm figure until chorus.\",          \"Guitar solo. Add guitar 3 during solo.\") p1 <- purrr::map(txt[1:2], ~p(as_music(\"r4;5 a,8 c f;4 d a;3 f;4 b~16^;3 b~ b2..^\", labels = .x))) p2 <- p(\"r4;4 a8 c';3 d' a;4 f';2 d';3 g'~16^;2 g'~ g'2.^\") p2b <- gsub(\"\\\\.\", \"\\\\.\\\\.\", p2) p3 <- p(\"f'8;2 g'2 a8;4 c';3 d' f';2 d'~1;3 d'\") p4 <- p(\"r1;4*5 r4 g~2. g1 r4 d~2.;5 d1 r2.. c''16;1 c'' a'1;2 r r r4. f'2;3 d'~8 d'1 r2 r8 c''4;1 a'~8;2 a'1 r r\") p5a <- p(pc(b_2, c2, f2, d2), 1, \"4*3 3\") p5 <- purrr::map(1:2, ~c(volta(p5a, .x), p(pc(b_2, c2), 1, 4))) p6 <- c(   p(\"r4.;3 f'4 d' f'~8 f'1 r2 r8 a'c''4.;2 a'1 r2. d''g''~4 d''g''1 r4. a'8 f'4;3 d' a1;4\"),   as_music(\"r4 a'c''4.;2 c''4;1 a'8;2 f'1;3 r4 d''g''2.;2 r1\", labels = txt[3]) ) p7 <- c(volta(p5a, 2), p(pc(b_2, tie(c2), c2, d1), 1, 4))  solo <- c(   as_music(\"d2.;5 c8 d~ d a, c d g-;4 a- g f~ f2- d'8;3 f'4;2 c''8;1 a'2 a4;3 f;4\", labels = txt[4]),   p(\"d2;5 d4 c8 d~ d a, c d g-;4 a- g f~ f2 r8 f';2*3 f'2 f'4 e'\"),   p(\"d'2;3 d'4 c'8 d'~ d' f';2 a;4 c';3 d'4 c' b_2;4 b_4 c'8;3 d'~ d'2 a4 f;4\"),   p(\"d2;5 d4 c8 d~ d a, c d g-;4 a- g a~;3 a2- e'a'16;3*4 e'a'e'';3*10 e'a'e''2 r8\") )  track1 <- track(c(p1[[1]], p2, p3, p4, p5[[1]], p1[[2]], p2b, p6, p5[[2]], solo, p7))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex4.html","id":"guitar-2---4-rhythm","dir":"Articles","previous_headings":"","what":"Guitar 2 - 4: rhythm","title":"Example: Gin Wigmore - Devil in me","text":"rhythm guitar section much simpler, though anyone working transcription , less cryptic glance. However, case much reason looks opaque opportunity save typing creating simple function repeat patterns efficiently. mainly two guitar parts. lead rhythm guitar . chosen call guitars 3 4 actually pretty short pieces. arranged way capture moments, mainly opening, ’s just two guitars. can take decent speakers pick apart. ears best .","code":"f <- function(notes, strings, n = 1) pct(p(pn(notes, 8), \"8 8x 8*3 8x 8 8\", pn(strings, 8)), n - 1) p1a <- c(f(d1, 4, 2), f(f1, 6, 2), f(g1, 6, 2)) p1 <- c(p1a, f(d1, 4), p(d1, \"1-.\", 4)) p2 <- c(p1a, p1a, f(d1, 4, 2), f(f1, 6, 2), f(g1, 6), rep(p(a1, 8, 5), 8)) p3a <- c(f(b_1, 5), f(c1, 5), f(f1, 6), f(d1, 6)) p3 <- c(volta(p3a, silent = TRUE), f(b_1, 5), p(c1, \"1-.\", 5), f(d1, 4, 2), f(f1, 6), p(f1, \"1-.\", 6)) p4 <- c(f(d1, 4, 2), f(f1, 6, 2), f(g1, 6, 2), f(d1, 4, 2), f(f1, 6, 2), f(g1, 6), rep(p(a1, 8, 5), 8)) p5 <- c(volta(p3a, 2, silent = TRUE), f(b_1, 5), p(c1, \"1-.\", 5)) p6 <- c(rep(c(f(d1, 4, 2), f(f1, 6, 2)), 2), f(d1, 4, 2), f(b_1, 5, 2), f(d1, 4, 2), f(a1, 5, 2)) p7 <- c(volta(p3a, 2, silent = TRUE), f(b_1, 5), p(pc(c1, \"r r\"), \"1-. 1 1\", 5))  track2 <- track(pc(p1, p2, p3, p4, p5, p6, p7)) f <- function(notes, n = 1) pct(p(pc(\"r\", notes, \"r\", notes, \"r\"), \"4 8-. 4 8-. 4\", 3), n - 1) p1a <- pc(f(d2, 2), f(f3, 2), f(g2, 2), f(d2), p(pc(d2, \"r\"), \"8-. 2..\", 3)) p1b <- pc(f(d2, 2), f(f3), f(f3)) track3 <- track(p1a)  f <- function(notes, n = 1) pct(p(pc(notes, \"r\", notes, \"r\"), \"8-. 4 8-. 2\", 5), n - 1) p1 <- pc(f(\"da\", 2), f(\"fc'\", 2), f(\"gd'\", 2), f(\"da\", 1), p(pc(\"da r\"), \"4 2.\", 5)) track4 <- track(p1)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-ex4.html","id":"render-the-sheet-music","dir":"Articles","previous_headings":"","what":"Render the sheet music","title":"Example: Gin Wigmore - Devil in me","text":"Now can render sheet music document sending score LilyPond. ! One favorites one favorite musicians, transcribed R code. page one looks like.  limitations. example, rendering string bending output technically challenging LilyPond right requires bit hacking . reason, much effort R side support code string bending, especially things like bend release, bend, release pull . Also, poorly engraved bend notation just used stand vibrato anyway. think ’s just vibrato song. don’t tremolo bar, little bending good enough. Basically, just play parts way want. goes rhythm pattern. need follow exactly. However accurate parts , still just guide.","code":"trackbind(track1, track2, track3, track4) |>   score(chords, chord_seq) |>   tab(out, key = \"dm\", tempo = \"4 = 120\", header = hdr)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-fretboard.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Fretboard diagram plots","text":"music visualization tabr focuses leveraging LilyPond make tablature, diagrams can also drawn directly R using ggplot without need involve LilyPond. plot_fretboard() function makes standalone fretboard diagrams R, independent LilyPond sheet music pipeline. plot_fretboard() highly specialized function takes vector inputs string numbers fret numbers maps combination element-wise produce fretboard diagram. Note plot_fretboard() developmental function interface arguments provides may change. fretted notes marked diagram using customary large circles.","code":"plot_fretboard(string = 6:1, fret = c(0, 2, 2, 0, 0, 0))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-fretboard.html","id":"labels-and-tuning","dir":"Articles","previous_headings":"","what":"Labels and tuning","title":"Fretboard diagram plots","text":"fretted notes can labeled. labels can arbitrary vector corresponding string fret numbers. example, can label circle fingerings used play chords scales.  set labels = \"notes\", special setting label points note names. can done automatically providing string fret numbers conjunction tuning argument gives full information notes along guitar neck. plot_fretboard() transposes internally. means work automatically matter arbitrary tuning set. example also displays tuning.  labels = \"notes\", accidentals displayed flats default. Set accidentals = \"sharp\" change. can also align fret numbers corresponding fretted strings fret_offset = TRUE.  Also notice zero position displayed, lowest fret number automatically printed. default behavior show fret numbers lowest necessary context. can override behavior providing vector desired fret numbers fret_labels. example, may want print fret numbers 3, 5, 7, 9, 12 guitar.  Fret labels displayed subject limits imposed data (fret) override (fret_range, ).","code":"plot_fretboard(6:1, c(0, 2, 2, 0, 0, 0), c(\"G\", \"U\", \"I\", \"T\", \"A\", \"R\")) string <- c(6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1) fret <- c(2, 4, 5, 2, 4, 5, 2, 4, 6, 7, 9, 6, 7, 9, 7, 9, 10, 7, 9, 10) plot_fretboard(string, fret, \"notes\", show_tuning = TRUE) plot_fretboard(string, fret, \"notes\", show_tuning = TRUE, fret_offset = TRUE, accidentals =  \"sharp\") plot_fretboard(string, fret, \"notes\", show_tuning = TRUE, fret_labels = c(3, 5, 7, 9, 12))"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-fretboard.html","id":"limits","dir":"Articles","previous_headings":"","what":"Limits","title":"Fretboard diagram plots","text":"X Y limits expressed terms number instrument strings span frets. can override fret range derived fret:  number strings instrument derived tuning generalizes fretboard diagram possibilities . tuning now specifies seven-string guitar. One note added string seven:","code":"plot_fretboard(string, fret, \"notes\", fret_range = c(0, 10), show_tuning = TRUE) tuning <- \"b1 e2 a2 d3 g3 b3 e4\" plot_fretboard(c(7, string), c(1, fret), \"notes\", fret_range = c(0, 10),                 tuning = tuning, show_tuning = TRUE)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-fretboard.html","id":"color-and-faceting","dir":"Articles","previous_headings":"","what":"Color and faceting","title":"Fretboard diagram plots","text":"points (circles) can border fill color. labels can also colored separately. arguments can vectorized. Notice open chord really open sixth string; muted. zero still given order specify notate, mute argument given logical vector indicates entry muted.  group can also used faceting. However, faceting still problematic feature. may work well enough cases different diagrams span similar frets. presence muted notes can also cause issues faceting. plot_fretboard() works best single-panel plots. Since function returns ggplot object, can always make separate plots arrange grid layout rather rely within-plot faceting. Note plot_fretboard() accepts character inputs like used throughout tabr.","code":"am_frets <- c(c(0, 0, 2, 2, 1, 0), c(5, 7, 7, 5, 5, 5)) am_strings <- c(6:1, 6:1) mute <- c(TRUE, rep(FALSE, 11))  # colors idx <- c(2, 2, 1, 1, 1, 2, rep(1, 6)) lab_col <- c(\"white\", \"black\")[idx] pt_fill <- c(\"firebrick1\", \"white\")[idx]  plot_fretboard(am_strings, am_frets, \"notes\", mute,                 label_color = lab_col, point_fill = pt_fill) f <- \"0 2 2 1 0 0 0 2 2 0 0 0\" s <- c(6:1, 6:1) grp <- rep(c(\"Open E\", \"Open Em\"), each = 6)  # colors idx <- c(2, 1, 1, 1, 2, 2, 2, 1, 1, 2, 2, 2) lab_col <- c(\"white\", \"black\")[idx] pt_fill <- c(\"firebrick1\", \"white\")[idx]  plot_fretboard(s, f, \"notes\", group = grp, fret_range = c(0, 4),                label_color = lab_col, point_fill = pt_fill)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-fretboard.html","id":"orientation","dir":"Articles","previous_headings":"","what":"Orientation","title":"Fretboard diagram plots","text":"direction handedness can also changed. Diagrams can vertical horizontal well left- right-handed. , titles added ggplot objects ggtitle. course can add onto ggplot objects returned plot_fretboard(), limited can add must careful avoid overriding properties layers plot_fretboard() already specified.","code":"library(ggplot2) plot_fretboard(string, fret, \"notes\", label_color = \"white\", point_fill = \"dodgerblue\",                fret_range = c(0, 10), show_tuning = TRUE, horizontal = TRUE) +   ggtitle(\"Horizontal\") plot_fretboard(string, fret, \"notes\", label_color = \"white\", point_fill = \"dodgerblue\",                fret_range = c(0, 10), show_tuning = TRUE, horizontal = TRUE, left_handed = TRUE) +   ggtitle(\"Horizontal and left-handed\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-fretboard.html","id":"chord-diagrams","dir":"Articles","previous_headings":"","what":"Chord diagrams","title":"Fretboard diagram plots","text":"previous examples show mix using plot_fretboard() make general fretboard diagrams show scales, arpeggios patterns, well produce chord diagrams specific chords. easier use plot_chord() latter. wrapper around plot_fretboard() takes string representing single chord simple fret format shown .  Leading x inferred fewer fret values string instrument strings, inferred tuning argument. plot_chord() takes arguments plot_fretboard() except takes chord instead string fret use mute muted notes indicated x inside chord.  Frets assumed single-digit provided . two-digit fret value occurs, must provide fret values space- semicolon-delimited. latter like LilyPond format, trailing semicolon ignored present.  effort leave flexibility user, plotting functions remain development, plotting multiple chords chord chart intentionally handled separately case case basis. example using little extra ggplot2, purrr gridExtra. also shows can tweak layout settings size arrange elements nicely Rmd file.  can use marrangeGrob() instead grid.arrange() want split larger set chord diagrams onto multiple pages.","code":"idx <- c(1, 1, 2, 2, 2, 1) fill <- c(\"white\", \"black\")[idx] lab_col <- c(\"black\", \"white\")[idx] plot_chord(\"xo221o\", \"notes\", label_color = lab_col, point_fill = fill) plot_chord(\"0231\") plot_chord(\"10 12 13 11\", fret_range = c(9, 14)) # same as \"10;12;13;11\" library(ggplot2) library(purrr) library(gridExtra)  chords <- c(\"02210\", \"32010\", \"0232\", \"133211\", \"022100\") id <- c(\"Am\", \"C\", \"D\", \"F\", \"E\")  g <- map2(chords, id, ~{   plot_chord(.x, \"notes\", point_size = 8, fret_range = c(0, 4), accidentals = \"sharp\", asp = 1.25) +      ggtitle(.y) })  grid.arrange(grobs = g, nrow = 2)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"aliases","dir":"Articles","previous_headings":"","what":"Aliases","title":"Phrase helpers","text":"Briefly, convenient aliases tabr functions used often. aliases short function names help keep music notation R syntax concise desired. include: p(), alias phrase(). tp(), alias transpose(). common conflicts watch using tabr shiny p() function use purrr help wrangle complex tablature, transpose() function. Pay attention package load order /use explicit names spaces working packages loaded.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"repeat-and-concatenate","dir":"Articles","previous_headings":"","what":"Repeat and concatenate","title":"Phrase helpers","text":"previous section phrases presented opportunity introduce pn() repeating strings pc() joining together. used strings passed phrase() work character string. recap, pn(), repeating phrase n times; simple wrapper around rep() maintains phrase class passed phrase object uses spaces collapsing repeated input. pc() similar wrapper around paste(). can passed arbitrary number input simple character strings phrase objects. phrase class applied output long least one input passed pc() phrase object. responsibility user ensure case simple character string also represents valid phrase content output phrase valid.","code":"pc(\"c d e\", \"f g a\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d e f g a pn(\"c d e\", 2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d e c d e"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"rests","dir":"Articles","previous_headings":"","what":"Rests","title":"Phrase helpers","text":"rest() function simple wrapper around rep() much like pn(). useful need propagate number rests, perhaps equal duration. accepts two vectorized arguments. first duration rest. second number times repeat . example, say score multiple tracks. certain period score, one track goes silent needs carried sequence rests. Perhaps instrument dropped middle measure returns middle another, several full measures . can easily notated using pn() pc(), convenient rest(), least offer interpretable code prefer. example, using rest() compared writing full notes string well using combinations pn() pc(). matter preference approach take dependent content repeated pasted together. Note using terminal -string multiplicative expansion operator, *, cases many adjacent single-element repetitions, far best option far shortening code concerned. method preferred, essentially removes edge case preference may rest().","code":"\"r8 r8 r8 r1 r1 r1 r1 r1 r1 r1 r1 r1 r1 r4.\" #> [1] \"r8 r8 r8 r1 r1 r1 r1 r1 r1 r1 r1 r1 r1 r4.\" pc(pn(\"r8\", 3), pn(\"r1\", 10), \"r4.\") #> [1] \"r8 r8 r8 r1 r1 r1 r1 r1 r1 r1 r1 r1 r1 r4.\" rest(c(8, 1, \"4.\"), c(3, 10, 1)) #> [1] \"r8 r8 r8 r1 r1 r1 r1 r1 r1 r1 r1 r1 r1 r4.\" \"r8*3 r1*10 r4.\" #> [1] \"r8*3 r1*10 r4.\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"ties","dir":"Articles","previous_headings":"","what":"Ties","title":"Phrase helpers","text":"Tied notes introduced momentarily previous section phrases. example given showed ties denoted appending pitch letter note ~ create tie output note next one. can frustrating type read done six-string chords example. tie() can make bearable. Chords receive discussion subsequent sections. shown briefly end last section space-delimited time simultaneous notes demonstrated clearly. now, enough demonstrate tie().","code":"em <- \"e,a,dgbe'\" tie(em) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <e,~a,~d~g~b~e'~>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"hammer-onpull-off","dir":"Articles","previous_headings":"","what":"Hammer on/pull off","title":"Phrase helpers","text":"simple helper function, hp(), hammer ons pull offs, slurs general. Like several helpers wrapper around paste. ensures slurs come even number always starting stopping point accepts several input styles. particularly useful long runs similar repeated hammer ons /pull offs frustrating type directly.","code":"hp(\"16 16\") #> [1] \"16( 16)\" hp(\"16\", \"16\") #> [1] \"16( 16)\" hp(16, 16, 8, \"2.\") #> [1] \"16( 16) 8( 2.)\" hp(pn(\"16 8\", 8)) #> [1] \"16( 8) 16( 8) 16( 8) 16( 8) 16( 8) 16( 8) 16( 8) 16( 8)\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"transpose","dir":"Articles","previous_headings":"","what":"Transpose","title":"Phrase helpers","text":"last section example showing sequence notes followed sequence transposed one octave . time, written twice. , sequence reproduced using transpose(). Transposing one octave done specifying increase 12 semitones half steps. Transposing done negative integers. default (n = 0) returns input, x, transposition. alias tp() can used limit typing. Examples shown . information passed transpose(), positive n sharpen naturals. Negative n flatten naturals. ideal may fit key signature. standard key signature composed notes may include flats sharps . avoid simply defaulting one based direction transposition, specify key signature key formal, e.g. key = \"dm\", just specify \"flat\" \"sharp\"” really needed. Since notes can arbitrarily short, even single note, reason transpose() attempt guess original new key notes present degree transposition. notes may easily include accidentals anyhow. transpose() works either integer tick style octave numbering shown output style can forced either way. key F one flat (B flat) key G one sharp (F sharp). Transposing notes whole step (two semitones half steps) results new note sequence includes either D flat C sharp second note. pitch occur (except accidental) either keys. Nevertheless, F key number sharps G key number flats, transpositions resulting non-natural notes represented flats sharps, respectively. key C major relative minor natural notes. Setting key \"c\" key = \"\" results default behavior, falling back sharp notes transposing flat notes transposing .","code":"notes1 <- \"c b, c d e e d c b, c c c'\" notes2 <- \"c' b c' d' e' e' d' c' b c' c' c''\" all(transpose(notes1, 12) == as_noteworthy(notes2)) #> [1] TRUE transpose(\"a_ b_' c''\", 0) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_ b_' c'' tp(\"a_ b_' c'\", -1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g a' b tp(\"a_ b_' c'\", 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b' d_' tp(\"a# b' c#'\", 11) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a' a#'' c'' tp(\"a# b' c#'\", 12) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a#' b'' c#'' tp(\"a# b' c#'\", 13) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b' c''' d'' tp(\"a3 b4 c5\", 2, key = \"f\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b d_5 d5 tp(\"a3 b4 c5\", 2, octaves = \"tick\", key = \"g\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b c#'' d'' tp(\"a b' c''\", 2, accidentals = \"flat\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b d_'' d'' tp(\"a, b c'\", 2, octaves = \"integer\", accidentals = \"sharp\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b2 c#4 d4"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-helpers.html","id":"tuplets","dir":"Articles","previous_headings":"","what":"Tuplets","title":"Phrase helpers","text":"important feature tuplet. evenly fit sequence notes number beats otherwise permitted time signature. common default tuplet returned tuplet() triplet. also alias function, triplet() . triplet fits three equally spaced notes two beats normally taken two notes, meaning note triplet lasts two thirds normal duration. examples show equivalence default tuplet() settings triplet() well specifications tuplet ability specify multiple consecutive tuplets fixed pattern single call tuplet(). Like phrase(), functions accept string number argument, critical usual guitar tablature (try engraving final phrase without explicit string numbers see mess get). example includes rests.  triplet() limited utility. Notice allow additional note info included. note info, phrase() supports triplets directly (general tuplets though). recommended provide note info phrase() uses t-prefix triplet notation, e.g., \"t8\". Notes chords triplet timing parsed LilyPond triplet syntax like , also retaining note info.","code":"x <- \"c' d' e'\" tuplet(x, 8) #> <Musical phrase> #> \\tuplet 3/2 4 { <c'>8 <d'> <e'> } triplet(x, 8) # equivalent #> <Musical phrase> #> \\tuplet 3/2 4 { <c'>8 <d'> <e'> } tuplet(pn(x, 2), 8, a = 6, b = 4) # 6 notes per 4 beats #> <Musical phrase> #> \\tuplet 6/4 2 { <c'>8 <d'> <e'> <c'> <d'> <e'> } tuplet(pn(x, 4), 8) # multiple tuplets, one call #> <Musical phrase> #> \\tuplet 3/2 4 { <c'>8 <d'> <e'> <c'> <d'> <e'> <c'> <d'> <e'> <c'> <d'> <e'> } p1 <- c(   triplet(\"c' r e'\", 8, \"4 3 3\"),    tuplet(\"f' g' a' b' c'' b'\", 8, \"3 2 2 1 1 1\", 6, 4),    tuplet(\"a' r f' g' r e' f' e' d' e' d' c'\", 16, \"2 2 3 2 3*7 4\"),   tuplet(\"b a g f e\", 16, \"4 4 5*3\", 5, 4) ) track(pc(p1, p(\"d c\", \"8 4.\", \"6 6\"))) |> score |> tab(\"ex12.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Musical phrases","text":"section goes deeper detail building musical phrases individual notes using syntax available phrase construction. also describes add note information notes phrase. mentioned last section, “phrase” tabr require strict definition. recommended keep phrases short enough much cognitive load. also represent meaningful convenient segments music, example whole measures, particular rhythm section, identifiable section longer solo. Writing music notation R code intended replace LilyPond markup. can always write LilyPond markup directly give options greater control. motivation tabr primarily music data analysis notation perspective, degree various types notation supported, also allows transcribe data sheet music tablature. Working programming language like R also different writing static markup files. API far limited writing LilyPond markup directly, generating music notation programmatically creating sheet music dynamically entirely different use case writing markup specific song. opening section showed basic example using single, simple, phrase. section cover phrases include notes rests different duration, slides, hammer ons pull offs, simple string bends, various elements. Phrases become longer visually complex. way around fact. proper care can kept manageable interpretable, depending comfort level music theory, notation R programming. diving , take look tables overview common syntax operators used throughout section. additional single-note articulations can specified, accented staccato notes. can provided using name square brackets, e.g., [accent] [staccato]. special cases abbreviated syntax available, e.g., -^ -.. many options. common ones shown. See articulations dataset.","code":"<!-- KNITR_ASIS_OUTPUT_TOKEN --><table class=\"table table-striped table-condensed\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\"> <caption>tabr::tabrSyntax<\/caption>  <thead>   <tr>    <th style=\"text-align:left;\"> description <\/th>    <th style=\"text-align:left;\"> syntax <\/th>    <th style=\"text-align:left;\"> example <\/th>   <\/tr>  <\/thead> <tbody>   <tr>    <td style=\"text-align:left;\"> note/pitch <\/td>    <td style=\"text-align:left;\"> a b ... g <\/td>    <td style=\"text-align:left;\"> a <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> sharp <\/td>    <td style=\"text-align:left;\"> # <\/td>    <td style=\"text-align:left;\"> a# <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> flat <\/td>    <td style=\"text-align:left;\"> _ <\/td>    <td style=\"text-align:left;\"> a_ <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> drop or raise one octave <\/td>    <td style=\"text-align:left;\"> , or ' <\/td>    <td style=\"text-align:left;\"> a, a a' <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> octave number <\/td>    <td style=\"text-align:left;\"> 0 1 ... <\/td>    <td style=\"text-align:left;\"> a2 a3 a4 <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> tied notes <\/td>    <td style=\"text-align:left;\"> ~ <\/td>    <td style=\"text-align:left;\"> a~ a <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> note duration <\/td>    <td style=\"text-align:left;\"> 2^n <\/td>    <td style=\"text-align:left;\"> 1 2 4 8 16 <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> dotted note <\/td>    <td style=\"text-align:left;\"> . <\/td>    <td style=\"text-align:left;\"> 2. 2.. <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> slide <\/td>    <td style=\"text-align:left;\"> \\- <\/td>    <td style=\"text-align:left;\"> 2- <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> bend <\/td>    <td style=\"text-align:left;\"> ^ <\/td>    <td style=\"text-align:left;\"> 2^ <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> muted/dead note <\/td>    <td style=\"text-align:left;\"> x <\/td>    <td style=\"text-align:left;\"> 2x <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> slur/hammer/pull off <\/td>    <td style=\"text-align:left;\"> () <\/td>    <td style=\"text-align:left;\"> 2( 2) <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> rest <\/td>    <td style=\"text-align:left;\"> r <\/td>    <td style=\"text-align:left;\"> r <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> silent rest <\/td>    <td style=\"text-align:left;\"> s <\/td>    <td style=\"text-align:left;\"> s <\/td>   <\/tr>   <tr>    <td style=\"text-align:left;\"> expansion operator <\/td>    <td style=\"text-align:left;\"> \\* <\/td>    <td style=\"text-align:left;\"> ceg\\*8, 1\\*4 <\/td>   <\/tr> <\/tbody> <\/table>  <!-- KNITR_ASIS_OUTPUT_TOKEN --> head(articulations) #>       type         value  abb #> 1 standard        accent   -> #> 2 standard    espressivo <NA> #> 3 standard       marcato   -^ #> 4 standard       portato   -_ #> 5 standard staccatissimo   -! #> 6 standard      staccato   -."},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Musical phrases","text":"first argument phrase() notes. Notes represented simply lowercase letters c d e f g b.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"sharps-and-flats","dir":"Articles","previous_headings":"Notes","what":"Sharps and flats","title":"Musical phrases","text":"Sharps represented appending # flats _, example # b_. phrases various tabr functions operate , two-character notes tightly bound treated specific notes just like single letters.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"space-delimited-time","dir":"Articles","previous_headings":"Notes","what":"Space-delimited time","title":"Musical phrases","text":"string notes separated time spaces. Simultaneous notes . example, \"b c\" represents sequence notes time whereas \"ceg\" represents simultaneously played notes C major triad chord. now focus remain individual notes. end section includes tiny chord example. Chords discussed detail later sections. Functions tabr also handle vector-delimited time. quick type example vector notes, already vector collapse . Package functions accept either timestep format.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"unambiguous-pitch","dir":"Articles","previous_headings":"Notes","what":"Unambiguous pitch","title":"Musical phrases","text":"allowable specify note sequences \"b c\", assumes default octave (number 3), one middle C. may intend. example , might mean consecutive notes \"a2 b2 c3\" a3 b3 c4. Combining note octave number specifies absolute pitch. LilyPond markup uses single multiple consecutive commas lower octaves single quote marks higher octaves. notation permitted tabr well. fact, specify integer suffixes octave numbering, phrase() reinterpret . following equivalent, shown printing LilyPond syntax generated phrase(). second example also shows convenient multiplicative expansion operator * can used inside character strings passed three main phrase() arguments. Use wherever convenient, though tutorial section continue write things explicitly increased clarity. operators like one help shorten repetitive code introduced later. tabr two formats referred integer tick octave numbering. Note octave number three corresponds central octave (comma single quote ticks) tick numbering style. 3 can left using numbered format. c3 corresponds lowest C note standard tuned guitar: fifth string, third fret. extreme octaves, latter style requires characters. However, may find easier read chords like open E minor \"e,b,egbe'\" compared either \"e2b2e3g3b3e4\" \"e2b2egbe4\". Regardless, integer octaves recommended, primary reason limits functionality. Numbers used indicating time (music class objects). Therefore, integer octave format can used simple strings phrases, complete objects. tick format also matches used LilyPond software. multiple reasons, just use tick format. rest vignettes stick tick format except making specific comparisons.","code":"phrase(\"c1 c2 c3 c4 c5\", \"1 1 1 1 1\") # not recommended #> <Musical phrase> #> <c,,>1 <c,>1 <c>1 <c'>1 <c''>1 phrase(\"c,, c, c c' c''\", \"1*5\") # recommened format #> <Musical phrase> #> <c,,>1 <c,>1 <c>1 <c'>1 <c''>1"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"time-the-essential-note-metadata","dir":"Articles","previous_headings":"","what":"Time: the essential note metadata","title":"Musical phrases","text":"Additional information note passed second phrase() argument, info. enables removing ambiguities pitch . moment, time duration introduced. brief diversion info argument follows order cover rests, tied notes, string specification; three important elements can described phrase(), actually passed via info argument. Afterward, focus returns info detailed coverage various note metadata supplied phrase() via info.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"duration","dir":"Articles","previous_headings":"Time: the essential note metadata","what":"Duration","title":"Musical phrases","text":"basic, always required bare minimum, time duration note. Notes always duration. previous example showed string ones, info = \"1 1 1 1 1\", equal length (terms space-delimited entries character string) first argument giving sequence five C notes different octaves. ones represent whole notes, lasting entire measure music. possible integer values 2, 4, 8, 16, 32 64, though users probably won’t reason go beyond 16. possible integers represent whole notes, half notes, quarter notes, eighth notes, sixteenth notes, etc. format technically specifying denominator. might inclined toward 1, 1/2, 1/4, etc., since durations represent fractions single measure, total number measures. denominator shorthand implicit numerator always one saves typing, also consistently LilyPond . example using different durations. Entire songs much longer complex meaningfully benefit piping, short examples follow, convenient used. arguments tab relevant yet now just accept defaults.","code":"phrase(\"c d e f g a b c' b c'\", \"16 16 8 8 4 4 8 2 2 1\") |>    track() |> score() |> tab(\"ex01.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"rests-and-ties","dir":"Articles","previous_headings":"","what":"Rests and ties","title":"Musical phrases","text":"Rests tied notes actually part note argument. duration, belongs info. Rests denoted \"r\". general, string specification irrelevant rests nothing played, can use placeholder like x instead string number (see next section string numbers). moment example specifying optional argument, string, can ignored. Replacing notes previous phrase rests looks like following.  first glance, tied notes might seem like something described via info. Even though second note played, tied note still distinct note tied far notation concerned. example, tying note new measure, must included twice notes. tie annotated original note ~ follows.  note played duration one quarter measures, still annotated one quarter note tied one whole note.","code":"phrase(\"r d e r g r b r b r\", \"16 16 8 8 4 4 8 2 2 1\") |>    track() |> score() |> tab(\"ex02.pdf\") phrase(\"r a, b, c~ c\", \"2 8 8 4 1\") |> track() |> score() |> tab(\"ex03.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"explicit-string-fret-combinations","dir":"Articles","previous_headings":"","what":"Explicit string-fret combinations","title":"Musical phrases","text":"Specifying exact pitch still ambiguous guitar tablature note can played different positions along neck guitar. Tabs show string fretted . example, standard tuning, C3 note can played fifth string, third fret, sixth string, eighth fret. left unspecified, guitar tablature software attempt guess play notes guitar. done kind impressive, reliable artificial intelligence. usually just means arbitrarily reducing notes lowest possible frets even combination notes make sense physically practical someone play way. one degree freedom note locked position . necessary specify string number fret number. Providing one implicitly locks . know pitch string number, fret known. LilyPond accepts string numbers readily. isolate numbers info argument notation phrase(), provided third argument, string, also helpful string always optional. Returning earlier phrase, without rests, equivalent phrase explicit string numbers string = \"5 4 4 4 3 3 2 2 2 2\". second version rests provided string = \"x 4 4 x 3 x 2 x 2 x\". Instead, play neck beginning C3 sixth string, eighth fret.  programs like LilyPond allow specifying minimum fret threshold, every note played fret . work better songs others course. still powerful ideal explicit every note’s position. threshold option currently supported tabr. recommended always explicit anyway, leads accurate guitar tablature. preponderance highly inaccurate guitar tabs online world. Please add heap.","code":"notes <- \"c d e f g a b c' b c'\" info <- \"16 16 8 8 4 4 8 2 2 1\" strings <- \"6 6 5 5 5 4 4 4 4 4\" phrase(notes, info, strings) |> track() |> score() |> tab(\"ex04.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"note-metadata-continued","dir":"Articles","previous_headings":"","what":"Note metadata continued","title":"Musical phrases","text":"section returns info argument phrase() examples various pieces note information can bound notes.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"dotted-notes","dir":"Articles","previous_headings":"Note metadata continued","what":"Dotted notes","title":"Musical phrases","text":"Note duration introduced earlier, incompletely. Dotted notes can used add 50% time note. example, dotted quarter note, given \"4.\", equal length quarter note plus eighth note, covering three eighths measure. Double dotted may also supplied. \"2..\" represents one half note plus one quarter note plus another eight note duration, total 4 + 2 + 1 = 7 eighths measure. couple measures rests contains dotted double dotted notes might look like . Dots tightly bound dotted notes. tabr treats multi-character time durations singular elements, just , say, sixteenth notes given \"16\".","code":"phrase(\"c d e e e d c\", \"4. 4. 8 8 2.. 8 1\") |> track() |> score() |> tab(\"ex05.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"staccato","dir":"Articles","previous_headings":"Note metadata continued","what":"Staccato","title":"Musical phrases","text":"Notes played staccato specified appending closing square bracket directly note duration, e.g., altering \"16\" \"16]\". place dot output notes played staccato.","code":"phrase(\"c e g e c\", \"8] 8] 8] 8] 2\") |> track() |> score() |> tab(\"ex06.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"muted-or-dead-notes","dir":"Articles","previous_headings":"Note metadata continued","what":"Muted or dead notes","title":"Musical phrases","text":"Muted dead notes indicated appending \"x\" note duration, e.g., \"8x\".  Multiple pieces information can strung together single note. example, combining muted note staccato can given \"8x]\". early version tabr, caution, orderings note information thoroughly tested yet. Duration always comes first though. pieces information meant go together either, staccato note must essentially held rather released, purpose sliding another note. Use human judgment. don’t ever see something sheet music, may work tabr either. case, example work \"8x]\" \"8]x\". fact, even accidentally leaving extra staccato indicator \"8]x]\", undesirably alter output phrase(), still parsed LilyPond correctly. Nevertheless, stick closely patterns shown examples possible.","code":"phrase(\"c e g e c\", \"8x] 8x] 8x] 8x] 2x\") |> track() |> score() |> tab(\"ex07.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"slides","dir":"Articles","previous_headings":"Note metadata continued","what":"Slides","title":"Musical phrases","text":"Slides partially implemented. work well tabr sliding one note another note. Slides note begin previous note slides note terminate subsequent note implemented. usually done bit hack LilyPond bending grace note making grace note invisible. hack another approach ported tabr.  brief aside, note use * string argument reduce typing. necessary specify string order ensure notes fifth string output. space-delimited elements phrase() can take advantage terminal element notation multiplicative expansion element. Terminal means must appended end whatever expanded; nothing can follow . c*4 *2 expands c c c c inside phrase(). 4.-*2 replaced 4.- 4.-. convenient multiplicative expansion operator within character strings passed phrase() available notes, info string arguments.","code":"phrase(\"c b, c d e e d c b, c c c'\", \"8- 8- 4 8- 8 8- 8 8- 8- 8 4.- 4\", \"5*12\") |>    track() |> score() |> tab(\"ex08.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"hammer-ons-and-pull-offs","dir":"Articles","previous_headings":"Note metadata continued","what":"Hammer ons and pull offs","title":"Musical phrases","text":"Hammer ons pull offs use notation essentially equivalent slurs. require starting stopping point. Therefore, must always come pairs. Providing odd number slur indicators throw error. beginning slur indicated using open parenthesis, (, end slur indicated closing parenthesis, ). Editing previous example, change slides hammer ons pull offs. Change opening two slides (C B C) use pull followed hammer . Note must opened closed, hence )( appended B, second eighth note. Using single set parentheses, opening first note closing third, make single, general slur three output. Next, hammer D E, pick E, pull back D. Notice notation identical directions. Whether slur two consecutive notes hammer pull implicit, given direction. play C-B-C part , differently opening. Pick, pick, hammer , pick, final slide. Finally, transpose one octave increasing octave numbers attached pitches notes. reason simply demonstrate placement slurs notes tablature staff depending string number. transposition, move fifth third string.  Another brief aside: tabr helper functions make work bit easier code bit legible, ideally . Using meaningful separation helps keep code relatively readable easier make changes realize made mistake somewhere. Don’t write one enormous string representing entire song. Aside avoiding code duplication musical repetition, even something might repeat guitar solo still benefits greatly broken manageable parts. pc() used combine parts fed notes rather write single character string. pc() convenient function joining strings tabr. maintains phrase class least one element passed pc() phrase object. string passed info change parts can repeated. Using *n within-string operator earlier apply , another function similar pc() pn(). repeats phrase n times.","code":"notes <- pc(\"c b, c d e e d c b, c c c\", \"c' b c' d' e' e' d' c' b c' c' c''\") info <- pn(\"8( 8)( 4) 8( 8) 8( 8) 8 8( 8) 4.- 4\", 2) strings <- \"5*12 3*12\" phrase(notes, info, strings) |> track() |> score() |> tab(\"ex09.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"string-bending","dir":"Articles","previous_headings":"Note metadata continued","what":"String bending","title":"Musical phrases","text":"String bends available currently limited implementation tabr bend engraving LilyPond fully developed. Specifying kinds bending, elegantly yielding aesthetically pleasing accurate result, immensely difficult. Bends specified ^. Bend engraving look good moment control bend drawn associated notation indicating number semitones bend currently excluded. example , half step bend-release-bend attempted three B notes shown end first phrase. string plucked one time, first two B notes tied third. Since tied note note, done notes. two bends indicated ^ first third notes via info. similar approach taken second phrase, although full step bends G . cases, initial bend pre-bend, quick. None fine details can provided current version tabr.  can see, implementation limited tabr. also relatively difficult achieve natively LilyPond. bends different number steps must inferred key. timing bends releases challenging. engraving poor. start point.","code":"notes <- pc(\"r a, c f d a f b~ b~ b\", \"r a c' d' a f' d' g'~ g'~ g'\") info <- pn(\"4 8*6 16^ 16 2..^\", 2) strings <- pc(\"x 5 5 4 4 3 4 3 3 3\", \"x 4 3 3 4 2 3 2 2 2\") phrase(notes, info, strings) |> track() |> score() |> tab(\"ex10.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-phrases.html","id":"chords","dir":"Articles","previous_headings":"","what":"Chords","title":"Musical phrases","text":"Chords covered detail later sections. now, brief example given fully demonstrate concept space-delimited time use simultaneous vs. sequential notes tabr. example shows include open C major chords inside notes. simply matter removing spaces. tightly bound notes simultaneous time. info applies entire chord describes attributes notes played given moment. obvious limitations though fortunately hugely detrimental. string numbers tightly bound chords well. can seen just like individual notes, chords can specified using combination tick integer octave numbering. equivalent. Tick style may readable . importantly, remember numbered octave format restricts functionality. Octave 3 implicit default can left . Note shorthand string numbering. Note info string numbers can recycled across timesteps notes long length one. single string number given timestep, one note timestep, assumed starting string number addition consecutive string numbers inferred. Multiple explicit string numbers per timestep required completely consecutive. general, number implicit explicit strings per timestep must match number notes. String numbers ignored rests.  covers detailed introduction phrases. next section cover related helper functions, already seen.","code":"p1 <- phrase(\"c cegc'e' c3 c3e3g3c4e4\", 4, 5) track(p1) |> score() |> tab(\"ex11.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"chord-identity-and-comparison","dir":"Articles","previous_headings":"","what":"Chord identity and comparison","title":"Chord functions","text":"already seen is_chord(), similar is_note(). Another check seen is_diatonic(). can also check whether chords major minor, imperfect due inability know user interpreting notation chord inversion. Instances difficult tell, inapplicable single notes, return NA. functions compare chords chord_rank(), chord_order() chord_sort(). Ranking chords, ordering sorting based , requires definition set definitions work . first argument noteworthy string. second, pitch, can \"min\" (default), \"mean\", \"max\". refers functions operate three available definitions ranking chords. ranking individual notes, result fixed two pitches compared. chords, however, pitch = \"min\" compares lowest pitch root note chord. pitch = \"max\", highest pitch note chord used establishing rank. pitch = \"mean\", average notes chord used ranking chords. Rank lowest highest pitch. options define chords ranked, function also passes additional arguments via ... base functions rank() order() additional control general aspects ranking ordering done R. chord_order() works analogously chord_rank(). chord_sort() wraps around chord_order().","code":"x <- \"b c ce_g cd#g\" is_diatonic(x, key = \"b_\") #> [1] FALSE  TRUE  TRUE FALSE chord_is_major(x) #> [1]    NA    NA FALSE FALSE chord_is_minor(x) #> [1]   NA   NA TRUE TRUE x <- \"a2 c a2 ceg ce_g cea\" chord_rank(x, \"min\") #> [1] 1.5 4.5 1.5 4.5 4.5 4.5 chord_rank(x, \"max\") #> [1] 1.5 3.0 1.5 4.5 4.5 6.0 chord_rank(x, \"mean\") #> [1] 1.5 3.0 1.5 5.0 4.0 6.0 chord_order(x) #> [1] 1 3 2 4 5 6 chord_order(x, \"mean\") #> [1] 1 3 2 5 4 6 chord_sort(x, \"mean\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a2 a2 c <ce_g> <ceg> <cea>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"slice-and-filter-chords","dir":"Articles","previous_headings":"","what":"Slice and filter chords","title":"Chord functions","text":"Chords can sliced indexed using functions chord_root(), chord_top() chord_slice(). first two special cases chord_slice. first two functions return noteworthy string containing root top notes chord. string contains single note, definition note returned. chord_slice(), however, integer index range provided possible reduce note chord nothing passing indices completely bounds. note chord completely sliced away dropped. example also shows matters pitch order, order notes chord entered string. slicing functions deal position within chord; simple reproduction vector indexing time steps, trivial can already done note_slice() (clearly slicing single note, noteworthy string). Filtering sequence rather elements within best done taking results function returns logical vector passing note_slice(). tends fall topic general noteworthy string functions apply strictly chords, example shown .","code":"x <- \"a2 ceg e_gc egc,cc'\" chord_root(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c c c, chord_top(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, g g c' identical(chord_slice(x, 1), chord_root(x)) #> [1] TRUE chord_slice(x, 2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e e_ c chord_slice(x, 4) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g chord_slice(x, 3:5) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g g <egc'> x <- \"a2 ceg e_gc egc,cc'\" note_slice(x, 3:4) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <e_gc> <egc,cc'> note_slice(x, is_chord(x)) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ceg> <e_gc> <egc,cc'>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"chord-transformations","dir":"Articles","previous_headings":"","what":"Chord transformations","title":"Chord functions","text":"broken chord can created chord_break(), separates chord component notes, separating time. accepts single chord. chord_invert() creates chord inversions. also takes single chord input. treats chord root position provided. example applies function series inversion values show output changes. chord n notes n - 1 inversions, chord_invert() allows inversions continue, moving chord octaves. want restrict function allowing defined number inversions (excluding root position), set limit = TRUE. enforces rule , example, chord three notes two inversions n can take values -2 2 throw error. Building chord_invert(), chord_arpeggiate() grows chord scale pitch creating arpeggio. n describes many steps add onto original chord. Setting = \"chord\" replicate entire chord , scale. case n indicates whole octave transposition steps. default, n refers number steps individual chord notes arpeggiated, like chord_invert(). means example chord three notes, setting n = 3 = \"note\" equivalent setting n = 1 = \"chord\". argument broken = TRUE also convert broken chord, resulting arpeggio individual notes.","code":"x <- \"ce_g\" chord_break(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e_ g pc(sapply((-3):3, function(i) chord_invert(x, i))) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <c2e_2g2> <e_2g2c> <g2ce_> <ce_g> <e_gc4> <gc4e_4> <c4e_4g4> chord_arpeggiate(\"ce_gb_\", 2) #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce_gb_> <e_gb_c4> <gb_c4e_4> chord_arpeggiate(\"ce_gb_\", -2) #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce_gb_> <b_2ce_g> <g2b_2ce_> chord_arpeggiate(\"ce_gb_\", 2, by = \"chord\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce_gb_> <c4e_4g4b_4> <c5e_5g5b_5> chord_arpeggiate(\"ce_gb_\", 1, broken = TRUE, collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e_ g b_ e_ g b_ c4"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"dyads","dir":"Articles","previous_headings":"","what":"Dyads","title":"Chord functions","text":"introducing chord constructors, brief mention example dyad() function constructing dyads root note interval. Dyads always considered chords, good place mention dyad() since key distinction made tabr context whether single note multiple notes. interval passed dyad() can semitones, named interval mainIntervals corresponds number semitones.","code":"dyad(\"a\", 3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'> x <- c(\"minor third\", \"m3\", \"augmented second\", \"A2\") dyad(\"a\", x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'> <ac'> <ac'> <ac'> dyad(\"c'\", x, reverse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'> <ac'> <ac'> <ac'>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"predefined-chord-constructors","dir":"Articles","previous_headings":"","what":"Predefined chord constructors","title":"Chord functions","text":"Now topic chord construction, two general forms chord construction currently available tabr. first typical chords based defining intervals; .e., “piano chords”. particularly useful guitar-specific chord shapes fingerings, generally span greater pitch range. See guitar chords. tabr chords often constructed scratch explicitly typing chord pitches noteworthy string, many chords can also constructed using helper functions. Currently, helpers exist common chords thirteenths. tabr offers two options chord constructor function name: longer chord_*-named function x* alias. table shows available constructors. functions take root notes key signature input. given function determines intervals chord. combination root note needed create chord. However, key signature can enforce whether result uses flats sharps accidentals present.","code":"#>        full_name abbreviation #> 1      chord_min           xm #> 2      chord_maj           xM #> 3     chord_min7          xm7 #> 4     chord_dom7           x7 #> 5      chord_7s5         x7s5 #> 6     chord_maj7          xM7 #> 7     chord_min6          xm6 #> 8     chord_maj6          xM6 #> 9      chord_dim         xdim #> 10    chord_dim7        xdim7 #> 11    chord_m7b5        xm7b5 #> 12     chord_aug         xaug #> 13       chord_5           x5 #> 14    chord_sus2          xs2 #> 15    chord_sus4          xs4 #> 16    chord_dom9           x9 #> 17     chord_7s9         x7s9 #> 18    chord_maj9          xM9 #> 19    chord_add9        xadd9 #> 20    chord_min9          xm9 #> 21   chord_madd9         xma9 #> 22   chord_min11         xm11 #> 23    chord_7s11        x7s11 #> 24 chord_maj7s11       xM7s11 #> 25      chord_11         x_11 #> 26   chord_maj11         xM11 #> 27      chord_13         x_13 #> 28   chord_min13         xm13 #> 29   chord_maj13         xM13 chord_min7(\"a c e\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'e'g'> <ce_gb_> <egbd'> chord_min7(\"a c e\", key = \"f\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'e'g'> <ce_gb_> <egbd'> xm7(\"a c e\", key = \"f\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'e'g'> <ce_gb_> <egbd'>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"predefined-guitar-chords","dir":"Articles","previous_headings":"","what":"Predefined guitar chords","title":"Chord functions","text":"dataset guitarChords tibble containing 3,967 rows predefined guitar chords. highly redundant, convenient use. generated much smaller chords basis set, transposed notes, yielding chord types shapes twelve notes. Chords begin open position range one octave chords whose lowest fret eleven. also multiple chord voicings many chord types. Finally, chords containing accidentals included table flat sharp versions. twelve columns. , column-wise information also redundant, big deal include removes need variety computations map one representation chord information another. first ten rows:","code":"guitarChords #> # A tibble: 3,967 × 12 #>    id    lp_name root  octave root_fret min_fret bass_string notes      frets  #>    <fct> <chr>   <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>      <chr>  #>  1 M     a,:5    a          2         0        0           5 a,eac#'e'  xo222o #>  2 M     a,:5    a          2         0        0           5 a,ead_'e'  xo222o #>  3 m     a,:m    a          2         0        0           5 a,eac'e'   xo221o #>  4 7     a,:7    a          2         0        0           5 a,egc#'e'  xo2o2o #>  5 7     a,:7    a          2         0        0           5 a,egd_'e'  xo2o2o #>  6 M7    a,:maj7 a          2         0        0           5 a,eg#c#'e' xo212o #>  7 M7    a,:maj7 a          2         0        0           5 a,ea_d_'e' xo212o #>  8 m7    a,:m7   a          2         0        0           5 a,egc'e'   xo2o1o #>  9 sus2  a,:sus2 a          2         0        0           5 a,eabe'    xo22oo #> 10 sus4  a,:sus4 a          2         0        0           5 a,ead'e'   xo223o #> # ℹ 3,957 more rows #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"defining-new-guitar-chord-collections","dir":"Articles","previous_headings":"Predefined guitar chords","what":"Defining new guitar chord collections","title":"Chord functions","text":"can also define chords using chord_def(). need fret numbers fretted chord. Currently assumed six-string instrument. default tuning standard, can changed arbitrarily. NA indicates muted string. Order lowest pitch string highest. example , create set minor chords based open shape. guitarChords currently contain optional column, column can indicate optional chord notes, shown . chord_def() scalar defines single chord, always returning table one row, can map however need order define collection chords. , set chords generated sharps flats.","code":"frets <- c(NA, 0, 2, 2, 1, 0) chord_def(frets, \"m\", 6) # sixth entry (highest string: string #1) is optional #> # A tibble: 1 × 13 #>   id    lp_name root  octave root_fret min_fret bass_string notes    frets  #>   <chr> <chr>   <chr>  <int>     <dbl>    <dbl>       <int> <chr>    <chr>  #> 1 m     a,:m    a          2         0        0           5 a,eac'e' xo221o #> # ℹ 4 more variables: semitones <list>, optional <chr>, fretboard <chr>, #> #   open <lgl> purrr::map_dfr(1:12, ~chord_def(frets + .x, \"m\")) #> # A tibble: 12 × 13 #>    id    lp_name root  octave root_fret min_fret bass_string notes         frets #>    <chr> <chr>   <chr>  <int>     <dbl>    <dbl>       <int> <chr>         <chr> #>  1 m     b_,:m   b_         2         1        1           5 b_,fb_d_'f'   x133… #>  2 m     b,:m    b          2         2        2           5 b,g_bd'g_'    x244… #>  3 m     c:m     c          3         3        3           5 cgc'e_'g'     x355… #>  4 m     d_:m    d_         3         4        4           5 d_a_d_'e'a_'  x466… #>  5 m     d:m     d          3         5        5           5 dad'f'a'      x577… #>  6 m     e_:m    e_         3         6        6           5 e_b_e_'g_'b_' x688… #>  7 m     e:m     e          3         7        7           5 ebe'g'b'      x799… #>  8 m     f:m     f          3         8        8           5 fc'f'a_'c''   x8(1… #>  9 m     g_:m    g_         3         9        9           5 g_d_'g_'a'd_… x9(1… #> 10 m     g:m     g          3        10       10           5 gd'g'b_'d''   x(10… #> 11 m     a_:m    a_         3        11       11           5 a_e_'a_'b'e_… x(11… #> 12 m     a:m     a          3        12       12           5 ae'a'c''e''   x(12… #> # ℹ 4 more variables: semitones <list>, optional <lgl>, fretboard <chr>, #> #   open <lgl> purrr::map_dfr(1:12, ~chord_def(frets + .x, \"m\", key = \"f\")) # flats #> # A tibble: 12 × 13 #>    id    lp_name root  octave root_fret min_fret bass_string notes         frets #>    <chr> <chr>   <chr>  <int>     <dbl>    <dbl>       <int> <chr>         <chr> #>  1 m     b_,:m   b_         2         1        1           5 b_,fb_d_'f'   x133… #>  2 m     b,:m    b          2         2        2           5 b,g_bd'g_'    x244… #>  3 m     c:m     c          3         3        3           5 cgc'e_'g'     x355… #>  4 m     d_:m    d_         3         4        4           5 d_a_d_'e'a_'  x466… #>  5 m     d:m     d          3         5        5           5 dad'f'a'      x577… #>  6 m     e_:m    e_         3         6        6           5 e_b_e_'g_'b_' x688… #>  7 m     e:m     e          3         7        7           5 ebe'g'b'      x799… #>  8 m     f:m     f          3         8        8           5 fc'f'a_'c''   x8(1… #>  9 m     g_:m    g_         3         9        9           5 g_d_'g_'a'd_… x9(1… #> 10 m     g:m     g          3        10       10           5 gd'g'b_'d''   x(10… #> 11 m     a_:m    a_         3        11       11           5 a_e_'a_'b'e_… x(11… #> 12 m     a:m     a          3        12       12           5 ae'a'c''e''   x(12… #> # ℹ 4 more variables: semitones <list>, optional <lgl>, fretboard <chr>, #> #   open <lgl>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"related-helper-functions","dir":"Articles","previous_headings":"Predefined guitar chords","what":"Related helper functions","title":"Chord functions","text":"Several functions available glean specific information guitarChords. functions lp_chord_id() lp_chord_mod() obtain LilyPond chord name LilyPond chord modifier (suffix), given root note tabr format chord name/modifier. quite identical LilyPond format (set exact = TRUE). See function documentation details. gc_is_known() checks guitarChords see explicit chord, given component pitches, exists dataset. Notice string notes note, major chord, hence returns FALSE. gc_name_* functions, now interpreted major chord functions operate chord name inputs.","code":"lp_chord_id(\"a a a\", \"m M m7_5\") #> [1] \"a:m\"    \"a:5\"    \"a:m7_5\" lp_chord_mod(\"a a a\", \"m M m7_5\") #> [1] \"m\"    \"5\"    \"m7_5\" gc_is_known(\"a b_,fb_d'f'\") #> [1] FALSE  TRUE x <- \"a aM b_,m7#5\" gc_name_split(x) #> # A tibble: 3 × 2 #>   root  mod   #>   <chr> <chr> #> 1 a     M     #> 2 a     M     #> 3 b_,   m7#5 gc_name_root(x) #> [1] \"a\"   \"a\"   \"b_,\" gc_name_mod(x) #> [1] \"M\"    \"M\"    \"m7#5\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"guitar-chord-construction","dir":"Articles","previous_headings":"","what":"Guitar chord construction","title":"Chord functions","text":"interesting use guitarChords using map chord names noteworthy strings.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"chord-information","dir":"Articles","previous_headings":"Guitar chord construction","what":"Chord information","title":"Chord functions","text":"gc_info() can used filter guitarChords. examples , can see multiple chord names can supplied . used filter chord dataset. inputs exist, empty tibble zero rows returned. result vectorized match number entries input; simply row filter guitarChords. properties gc_info() apply wrapper functions around , namely, gc_notes() gc_fretboard().","code":"gc_info(\"a\") # a major chord, not a single note #> # A tibble: 6 × 12 #>   id    lp_name root  octave root_fret min_fret bass_string notes        frets   #>   <fct> <chr>   <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>        <chr>   #> 1 M     a,:5    a          2         0        0           5 a,ead_'e'    xo222o  #> 2 M     a,:5    a          2         5        5           6 a,ead_'e'a'  577655  #> 3 M     a,:5    a          2         5        2           6 a,d_ead_'a'  542225  #> 4 M     a:5     a          3         7        7           4 ae'a'd_''    xx79(1… #> 5 M     a:5     a          3        12       12           5 ae'a'd_''e'' x(12)(… #> 6 M     a:5     a          3        12        9           5 ad_'e'a'd_'' x(12)(… #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl> gc_info(\"ceg a#m7_5\") # only third entry is a guitar chord #> # A tibble: 6 × 12 #>   id    lp_name  root  octave root_fret min_fret bass_string notes        frets  #>   <fct> <chr>    <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>        <chr>  #> 1 m7_5  b_,:m7_5 b_         2         1        0           5 b_,a_d_'e'   x1x12o #> 2 m7_5  b_,:m7_5 b_         2         1        1           5 b_,ea_d_'    x1212x #> 3 m7_5  b_,:m7_5 b_         2         6        5           6 b_,a_d_'e'   6x665x #> 4 m7_5  b_:m7_5  b_         3         8        4           4 b_d_'e'a_'   xx8654 #> 5 m7_5  b_:m7_5  b_         3         8        8           4 b_e'a_'d_''  xx8999 #> 6 m7_5  b_:m7_5  b_         3        13       12           5 b_a_'d_''e'' x(13)… #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl> gc_info(\"ceg a#m7_5\", key = \"f\") #> # A tibble: 6 × 12 #>   id    lp_name  root  octave root_fret min_fret bass_string notes        frets  #>   <fct> <chr>    <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>        <chr>  #> 1 m7_5  b_,:m7_5 b_         2         1        0           5 b_,a_d_'e'   x1x12o #> 2 m7_5  b_,:m7_5 b_         2         1        1           5 b_,ea_d_'    x1212x #> 3 m7_5  b_,:m7_5 b_         2         6        5           6 b_,a_d_'e'   6x665x #> 4 m7_5  b_:m7_5  b_         3         8        4           4 b_d_'e'a_'   xx8654 #> 5 m7_5  b_:m7_5  b_         3         8        8           4 b_e'a_'d_''  xx8999 #> 6 m7_5  b_:m7_5  b_         3        13       12           5 b_a_'d_''e'' x(13)… #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl> gc_info(\"a,m c d f,\") #> # A tibble: 23 × 12 #>    id    lp_name root  octave root_fret min_fret bass_string notes       frets   #>    <fct> <chr>   <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>       <chr>   #>  1 m     a,:m    a          2         0        0           5 a,eac'e'    xo221o  #>  2 m     a,:m    a          2         5        5           6 a,eac'e'a'  577555  #>  3 m     a,:m    a          2         5        2           6 a,cea       5322xx  #>  4 m     a:m     a          3         7        7           4 ae'a'c''    xx79(1… #>  5 m     a:m     a          3        12       12           5 ae'a'c''e'' x(12)(… #>  6 m     a:m     a          3        12        9           5 ac'e'a'     x(12)(… #>  7 M     c:5     c          3         3        3           5 cgc'e'g'    x35553  #>  8 M     c:5     c          3         3        0           5 cegc'e'     x32o1o  #>  9 M     c:5     c          3         8        8           6 cgc'e'g'c'' 8(10)(… #> 10 M     c:5     c          3         8        5           6 cegc'e'c''  875558  #> # ℹ 13 more rows #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"map-chord-names-to-notes","dir":"Articles","previous_headings":"Guitar chord construction","what":"Map chord names to notes","title":"Chord functions","text":"gc_notes() takes chord names exist guitarChords returns noteworthy strings needed phrase construction. Remember, just basic filter. specify chords imprecisely, result contain many chords input. specify chords completely unambiguously, one result input. However, also requires provide chord names guitarChords, dropped. Keep mind functions active development approaches take may change prior next CRAN release tabr. Currently, ways can add precision chord mapping include passing following optional arguments: root_octave: octave number root note. root_fret: fret root note. min_fret: lowest fret position chord. bass_string: lowest unmuted string chord. open: open chords, closed/movable chords, (default). key: key signature, enforce sharps flats present. example, possible matches guitarChord filtered whose root fret 0:2. Notice octave information helps restrict chord set ignore_octave = FALSE.","code":"x <- gc_notes(\"a,7 b,m\", root_fret = 0:2, ignore_octave = FALSE) summary(x) #> <Noteworthy string> #>   Timesteps: 2 (0 notes, 2 chords) #>   Octaves: tick #>   Accidentals: flat #>   Format: space-delimited time #>   Values: <a,egd_'e'> <b,g_bd'g_'>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-chords.html","id":"fretboard-diagrams","dir":"Articles","previous_headings":"Guitar chord construction","what":"Fretboard diagrams","title":"Chord functions","text":"creating tablature sheet music LilyPond, may wish include chord chart containing fretboard diagrams chords played. Currently, tabr uses chord_set() function prepare named character vector chords quasi-LilyPond chord names fretboard notation values, ready passed score() proper injection LilyPond. process structure data objects involved may change soon (decided certain yet). time , still process. Therefore, new function gc_fretboard() performs manipulation using chords guitarChords.","code":"gc_fretboard(\"a,m c d f,\", min_fret = 0:1) #>           a,:m            c:5            d:5           f,:5  #> \"x;o;2;2;1;o;\" \"x;3;2;o;1;o;\" \"x;x;o;2;3;2;\" \"1;3;3;2;1;1;\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"external-data-and-alternate-notation","dir":"Articles","previous_headings":"","what":"External data and alternate notation","title":"Syntax converters","text":"tabr package uses particular syntax music notation. can convert representation music syntax used LilyPond order render basic sheet music. However, music notation can entered alternative syntax. might entered form R, likely may come outside R. music notation software. general, source music dataset contains music notation kind want analyze. music notation syntax used tabr integrates functionality cohesively across entire package also supports data export LilyPond, syntax conversion functions help importing external data sources. Syntax converters map alternative music notation formats various music data sources tabr style. allows leverage functionality tabr music analysis possibly transcription without convert data . Ideally endeavors limited quality completeness imported data rather original notation format. However, requires alternative music notation syntax known, likely popular, syntax converter written added package converting particular format, extent possible. alternative syntax can arbitrary, converter must exist . feature package slated incorporation , new version 0.4. active development. Currently two syntax converters available used examples .","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"converting-to-tabr","dir":"Articles","previous_headings":"External data and alternate notation","what":"Converting to tabr","title":"Syntax converters","text":"to_tabr() function used converting alternative representations music notation tabr syntax, allowing data formats piped seamlessly music analysis workflows even sheet music transcription. function general wrapper around specific syntax converters, likely called directly. Examples approaches shown .","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"sources-with-partial-information","dir":"Articles","previous_headings":"External data and alternate notation","what":"Sources with partial information","title":"Syntax converters","text":"sources offer complete explicit information tabr leverage, example order make sufficiently informed sheet music. cases, available formats converted extent possible. Available function arguments given syntax converter allow add additional specification. Different arguments may available /required different syntax converters. good example music data less complete ideal certain use cases list chords obtained chorrrds. package scrapes chord information Cifraclub website, provides song chords, note note transcription data particular instrument. means result syntax conversion must also yield chords, fine data analysis lend well sheet music transcription.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"music21-tiny-notation","dir":"Articles","previous_headings":"","what":"music21 tiny notation","title":"Syntax converters","text":"tiny notation format music21 similar several respects tabr notation. to_tabr() function, specifically, from_music21(), convert music21 tabr syntax. functionality still work progress, works simple notation. Different syntax converters handle different input structures, due different nature information contain, outputs different well. See to_tabr() documentation details converters available arguments.","code":"m21 <- \"4/4 CC#FF4.. trip{c#8eg# d'- e-' f g a'} D4~# D E F r B16 trip{c4 d e}\" x <- from_music21(m21) class(x) #> [1] \"music\"     \"character\" x #> <Music string> #>   Format: space-delimited time #>   Values: <d_,,f,,>4.. <d_ea_>t8 d_'t8 e_'t8 ft8 gt8 a't8 e_,~4 d,4 e,4 f,4 r4 b,16 ct4 dt4 et4 summary(x) #> <Music string> #>   Timesteps: 16 (14 notes, 2 chords) #>   Octaves: tick #>   Accidentals: flat #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: NA #>   Format: space-delimited time #>   Values: <d_,,f,,>4.. <d_ea_>t8 d_'t8 e_'t8 ft8 gt8 a't8 e_,~4 d,4 e,4 f,4 r4 b,16 ct4 dt4 et4 y <- to_tabr(id = \"music21\", x = m21) identical(x, y) #> [1] TRUE from_music21(m21, output = \"list\") # same as music_split(x) #> $notes #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <d_,,f,,> <d_ea_> d_' e_' f g a' e_,~ d, e, f, r b, c d e #>  #> $info #> <Note info string> #>   Format: space-delimited time #>   Values: 4.. t8 t8 t8 t8 t8 t8 4 4 4 4 4 16 t4 t4 t4 #>  #> $lyrics #> [1] NA #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"chorrrds-package-output-cifraclub","dir":"Articles","previous_headings":"","what":"chorrrds package output (Cifraclub)","title":"Syntax converters","text":"Turn output chorrrds package. much simpler music21 notation, mean little can done conversion. mentioned, chord symbols far complete information purposes, lost. from_chorrrds() convert available data tabr syntax can even enhance information guidance. Consider additional limitations beyond detailed music21 notation. input case also specify distinct pitches assigning octaves numbers notes chord, even root note. default, every chord positioned start root note octave three. may correctly represent chord played song question, assumptions must made. Since provided generic chord symbol, also ambiguous chord constructed general, just high low sounds. default standard chord (.e., piano chord) constructed can determined symbol.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"default-behavior","dir":"Articles","previous_headings":"chorrrds package output (Cifraclub)","what":"Default behavior","title":"Syntax converters","text":"example, series chords starting B flat converted. appear notation format provided chorrrds. last two chords intentionally given alternate bass notes, one highest note chord, one . can see to_tabr() takes id suffix from_* function. result . result noteworthy string containing explicit pitches, useful throughout tabr. Notice particular rule handling alternate bass match top chord, prepended new bass note. match, top note dropped, meaning chord simply inverted. less information given, must assumed. Prefer B flats start octave two? Want simple triads? Change sharps? Summarize data? problem. functions tabr ready operate.","code":"chords <- c(\"Bb\", \"Bbm\", \"Bbm7\", \"Bbm7(b5)\", \"Bb7(#5)/G\", \"Bb7(#5)/Ab\") x <- from_chorrrds(chords) x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_d'f'> <b_d_'f'> <b_d_'f'a_'> <b_d_'e'a_'> <gb_d'g_'a_'> <a_b_d'g_'> y <- to_tabr(\"chorrrds\", x = chords) identical(x, y) #> [1] TRUE x <- transpose(x, -12) |> chord_slice(1:3) |> sharpen_flat() tally_pitches(x) #> # A tibble: 7 × 2 #>   pitch     n #>   <chr> <int> #> 1 g,        1 #> 2 g#,       1 #> 3 a#,       6 #> 4 c#        3 #> 5 d         3 #> 6 e         1 #> 7 f         3 distinct_pitches(x) |> pitch_semitones() #> [1] 43 44 46 49 50 52 53"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"guitar-chords","dir":"Articles","previous_headings":"chorrrds package output (Cifraclub)","what":"Guitar chords","title":"Syntax converters","text":"Since chorrrds deals specifically chords, from_chorrrds() offers argument specifically selecting common guitar chords shapes instead standard chord. Setting guitar = TRUE switches using guitarChords dataset find matching guitar chords using gc_info() function. argument necessarily apply available syntax converter. nice feature gc_info() takes several arguments filtering numerous ways single chord can played guitar. helps constrain specify, least part initial pass broad brush, chord symbols chorrrds interpreted. Arguments gc_chords() setting filter conditions guitarChords dataset can passed named list gc_args() control conversion chord symbol specific pitches. One limitation currently method mapping database guitar chords, currently handle inclusion arbitrary alternate bass notes. notes dropped. helpful familiar guitarChords dataset filter arguments various gc_* functions work sense better control chord specification. filters yield single unique chord, first list possible matches returned. typically lowest guitar neck. filters specific chord simply available, NA returned.","code":"from_chorrrds(chords, guitar = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_,fb_d'f'> <b_,fb_d_'f'> <b_,fa_d_'f'> <b_,a_d_'e'> <b_,g_a_d'> <b_,g_a_d'>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example usage","title":"Syntax converters","text":"typical example. chord symbols converted tibble data frame tidy music analysis. Additionally, chord symbols alone provide anything worth making sheet music , can make chord chart.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"ready-for-analysis","dir":"Articles","previous_headings":"Example usage","what":"Ready for analysis","title":"Syntax converters","text":"Say also knew chords strummed four times , four quarter notes per measure. can expand series add time information well. functions available tabr manipulating noteworthy strings can applied similarly data frame columns general music data analysis. Also, notice generic primitives length() rep() implemented tabr classes. See help(\"tabr-methods\") information available methods.","code":"chords <- c(\"Am\", \"C\", \"D\", \"F\", \"Am\", \"E\", \"Am\", \"E\") x <- from_chorrrds(chords, guitar = TRUE)  as_music_df(x) #> # A tibble: 8 × 8 #>   duration pitch      note    semitone octave  freq pitch_int scale_int #>   <chr>    <chr>      <chr>      <int>  <int> <dbl>     <int> <chr>     #> 1 NA       a,eac'e'   aeace         57      2 110.         NA NA        #> 2 NA       cgc'e'g'   cgceg         48      3 131.          3 m3        #> 3 NA       dad'g_'    dadg_         50      3 147.          2 M2        #> 4 NA       f,cfac'f'  fcfacf        53      2  87.3        -9 M6        #> 5 NA       a,eac'e'   aeace         57      2 110.          4 M3        #> 6 NA       e,b,ea_be' ebea_be       52      2  82.4        -5 P4        #> 7 NA       a,eac'e'   aeace         57      2 110.          5 P4        #> 8 NA       e,b,ea_be' ebea_be       52      2  82.4        -5 P4 x <- rep(x, each = 4) time <- rep(4, length(x))  mdf <- as_music_df(x, time, key = \"am\") mdf #> # A tibble: 32 × 17 #>    duration pitch    note  semitone octave  freq key   scale scale_deg pitch_int #>    <chr>    <chr>    <chr>    <int>  <int> <dbl> <chr> <chr>     <int>     <int> #>  1 4        a,eac'e' aeace       57      2  110. am    diat…         3        NA #>  2 4        a,eac'e' aeace       57      2  110. am    diat…         3         0 #>  3 4        a,eac'e' aeace       57      2  110. am    diat…         3         0 #>  4 4        a,eac'e' aeace       57      2  110. am    diat…         3         0 #>  5 4        cgc'e'g' cgceg       48      3  131. am    diat…         3         3 #>  6 4        cgc'e'g' cgceg       48      3  131. am    diat…         3         0 #>  7 4        cgc'e'g' cgceg       48      3  131. am    diat…         3         0 #>  8 4        cgc'e'g' cgceg       48      3  131. am    diat…         3         0 #>  9 4        dad'g_'  dadg_       50      3  147. am    diat…         4         2 #> 10 4        dad'g_'  dadg_       50      3  147. am    diat…         4         0 #> # ℹ 22 more rows #> # ℹ 7 more variables: scale_int <chr>, slur <chr>, slide <lgl>, bend <lgl>, #> #   dotted <int>, articulation <chr>, annotation <chr>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"visual-representation","dir":"Articles","previous_headings":"Example usage","what":"Visual representation","title":"Syntax converters","text":"vignette part music programming music data analysis vignette collection, completeness, example shows can connect LilyPond. Note purposes example, last step requires LilyPond installation, though also ggplot (see vignette examples). fretboard diagram syntax chord names creating chord chart LilyPond can obtained directly pitches chord, long pitches match known chord guitarChords. Since goal make chord chart playable chords, consider chord shape position guitar neck. pitches obviously contain instrument-specific information. can use gc_args specify common playable chords open position nearby low-fret chord shapes. example almost necessary . However, say want ensure C chord open position chord rather barred shape occurred (chord shapes beginning string 5, fret 3 standard tuning). can stipulate min_fret chords must range 0:1. chords ready, needed rendering LilyPond integration following command. Since chords, increase font size fill page.","code":"chords <- unique(chords) x <- from_chorrrds(chords, guitar = TRUE, gc_args = list(min_fret = 0:1)) x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <a,eac'e'> <cegc'e'> <dad'g_'> <f,cfac'f'> <e,b,ea_be'> gc_is_known(x) # Are chords available with these exact pitch sequences? #> [1] TRUE TRUE TRUE TRUE TRUE y <- gc_notes_to_fb(x) y #>           a,:m            c:5            d:5           f,:5           e,:5  #> \"x;o;2;2;1;o;\" \"x;3;2;o;1;o;\" \"x;x;o;2;3;2;\" \"1;3;3;2;1;1;\" \"o;2;2;1;o;o;\" out <- \"House of the rising sun - chords.pdf\" render_chordchart(y, out, fontsize = 80)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"closing-example","dir":"Articles","previous_headings":"Example usage","what":"Closing example","title":"Syntax converters","text":"can merge instrument data music data. mdf data frame contains barred C chord, min_fret used derive fret data. fun, define new function parse fret data calculate new variable giving physical fret span needed fretting hand, excluding open fret course.","code":"library(dplyr)  fret_span <- function(x){   f <- function(x) strsplit(x, \";\") |> unlist() |> as.integer() |>      range(na.rm = TRUE) |> diff()   suppressWarnings(sapply(x, f) + 1L) # coercing string to NA integer }  mutate(mdf, frets = gc_notes_to_fb(pitch), fret_span = fret_span(frets)) |>   select(duration, pitch, frets, fret_span) #> # A tibble: 32 × 4 #>    duration pitch    frets        fret_span #>    <chr>    <chr>    <chr>            <int> #>  1 4        a,eac'e' x;o;2;2;1;o;         2 #>  2 4        a,eac'e' x;o;2;2;1;o;         2 #>  3 4        a,eac'e' x;o;2;2;1;o;         2 #>  4 4        a,eac'e' x;o;2;2;1;o;         2 #>  5 4        cgc'e'g' x;3;5;5;5;3;         3 #>  6 4        cgc'e'g' x;3;5;5;5;3;         3 #>  7 4        cgc'e'g' x;3;5;5;5;3;         3 #>  8 4        cgc'e'g' x;3;5;5;5;3;         3 #>  9 4        dad'g_'  x;x;o;2;3;2;         2 #> 10 4        dad'g_'  x;x;o;2;3;2;         2 #> # ℹ 22 more rows"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-converters.html","id":"wrapping-up","dir":"Articles","previous_headings":"","what":"Wrapping up","title":"Syntax converters","text":"examples output chorrrds package demonstrate plenty can still achieved information basic chord symbols. Eventually tabr include syntax converters. Depending quality completeness music data format question, different conversion options analysis possibilities available.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-music.html","id":"constructing-a-music-object","dir":"Articles","previous_headings":"","what":"Constructing a music object","title":"The music class","text":"First create music object noteworthy notinfo objects. object class can combined form music-class object. as_music() offers several additional arguments. Music objects also store key signature, time signature tempo. include default values: key C, 4/4 common time, 60 half note beats per measure. However, unless transcribing data sheet music, can probably ignore object attributes entirely. Optionally can also include lyrics object. closer look music object. summary information seen noteworthy objects added unique music objects. Just note, octave tick format explicitly shown noteworthy objects, though valid format music objects.","code":"notes <- \"c d e f g a b ceg~ ceg\" info <- \"8*8 1\" x <- as_music(notes, info) x #> <Music string> #>   Format: space-delimited time #>   Values: c8 d8 e8 f8 g8 a8 b8 <ceg~>8 <ceg>1 summary(x) #> <Music string> #>   Timesteps: 9 (7 notes, 2 chords) #>   Octaves: tick #>   Accidentals: flat #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: NA #>   Format: space-delimited time #>   Values: c8 d8 e8 f8 g8 a8 b8 <ceg~>8 <ceg>1"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-music.html","id":"deconstructing-a-music-object","dir":"Articles","previous_headings":"","what":"Deconstructing a music object","title":"The music class","text":"Music analysis generally requires disentangling time sound. reason, building music object notes note info directly useful analysis. convenient object structure, however. Aside generic methods handful functions make sense apply three classes, functions package operate noteworthy strings intentionally accept music object directly. helps keep mind ideal continually deconstruct reconstruct music object just perform operations one two main component parts. can split music object list music_split() can extract relevant piece one functions .","code":"music_split(x) #> $notes #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d e f g a b <ceg~> <ceg> #>  #> $info #> <Note info string> #>   Format: space-delimited time #>   Values: 8 8 8 8 8 8 8 8 1 #>  #> $lyrics #> [1] NA #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\" music_notes(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d e f g a b <ceg~> <ceg> music_info(x) #> <Note info string> #>   Format: space-delimited time #>   Values: 8 8 8 8 8 8 8 8 1 music_key(x) #> [1] \"c\" music_time(x) #> [1] \"4/4\" music_tempo(x) #> [1] \"2 = 60\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-music.html","id":"constructing-from-character","dir":"Articles","previous_headings":"","what":"Constructing from character","title":"The music class","text":"real value building brand new music objects single character string input. method music object construction allows relatively efficient data entry. can potentially lot less typing involved directly entering music syntax new piece music music class rather creating noteworthy noteinfo objects separately. also good place mention like noteworthy noteinfo strings, handy adjective can used check validity music input.","code":"x <- \"a,4*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4 c' g c ce'1\" musical(x) #> [1] TRUE x <- as_music(x) x #> <Music string> #>   Format: space-delimited time #>   Values: a,4 a,4 a,4 a,4 a,4 b,4- c4 <cgc'e'~>4 <cgc'e'>1 e'4 c'4 g4 c4 <ce'>1"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-music.html","id":"details","dir":"Articles","previous_headings":"Constructing from character","what":"Details","title":"The music class","text":"Notice timestep remains space-delimited (vectors also allowed). timestep, notes note info bound together unambiguously delimiter. tick octave numbering required music objects. can see expansion operator * still allowed continues place right end timestep. forget tied notes indicated ~ part note part note info! Order matters . can also include rests r silent rests s.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-music.html","id":"other-efficiencies","dir":"Articles","previous_headings":"Constructing from character","what":"Other efficiencies","title":"The music class","text":"Another benefit approach entering new data durations inferred previous timesteps provided. need explicitly enter duration value change. possible noteinfo result simply removing timesteps, always note entry present mark timestep. one bit aside, string numbers provided stringed fretted instrument context (see example ), also need specify starting string number (lowest pitch/highest number) unless non-consecutive strings. purpose music class transcription, corral related data together analysis. However, music objects lend seamlessly transcription tasks, string numbering allowed even though focused . can see example . , string numbers indicated following semicolon delimiter. Like durations, string numbers also repeat silently. inferred repeated information across timesteps carries rests, including string numbers. String numbers rest timestep ignored gracefully. Lyrics data returns NA requested lyrics object provided construction music object. contrast, string number information represented object provided constructed, since relevant general purpose class used specific transcription use cases. can see , print statement change. functions reveal additional information now contained music object.","code":"x <- \"a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\" x <- as_music(x) x #> <Music string> #>   Format: space-delimited time #>   Values: a,4 a,4 a,4 a,4 a,4 b,4- c4 <cgc'e'~>4 <cgc'e'>1 e'4 c'4 g4 c4 <ce'>1 music_strings(x) #>  [1] \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5432\" \"5432\" \"2\"    #> [11] \"3\"    \"4\"    \"5\"    \"51\" summary(x) #> <Music string> #>   Timesteps: 14 (11 notes, 3 chords) #>   Octaves: tick #>   Accidentals: flat #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: NA #>   Strings: 5 5 5 5 5 5 5 5432 5432 2... #>   Format: space-delimited time #>   Values: a,4 a,4 a,4 a,4 a,4 b,4- c4 <cgc'e'~>4 <cgc'e'>1 e'4 c'4 g4 c4 <ce'>1 music_split(x) #> $notes #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, a, a, a, a, b, c <cgc'e'~> <cgc'e'> e' c' g c <ce'> #>  #> $info #> <Note info string> #>   Format: space-delimited time #>   Values: 4 4 4 4 4 4- 4 4 1 4 4 4 4 1 #>  #> $string #>  [1] \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5432\" \"5432\" \"2\"    #> [11] \"3\"    \"4\"    \"5\"    \"51\"   #>  #> $lyrics #> [1] NA #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-music.html","id":"working-with-music-objects","dir":"Articles","previous_headings":"","what":"Working with music objects","title":"The music class","text":"many functions perform operations noteworthy note info objects require objects exclusively, meaning supposed use functions like music_notes() music_info() extract given component music object, several functions sensible apply directly music objects. First foremost, generic methods implemented music objects. Square bracket subsetting even subset lyrics string numbers present object, just notes note info. several time functions work nicely music objects. introduced vignette note info relevant . require level information contained music object deal real time seconds. works music objects contain tempo value. Note info objects contain level information. can passed functions require tempo value, long also pass tempo function tempo argument. example intended complex, including many changes note duration note info. much gained writing single string case. clarity, starts separate notes note info. See help documentation examples details. may notice table returned steps_per_measure() containing number timesteps per measure music entry measure six. measure six. can see n_measures() greater five sixth measure begin even duration time steps yield complete sixth measure. reason entry table measure timesteps. final chord sequence lasts whole measure, beginning measure five carrying six, timestep starts six. Combining note info tempo powerful allows move beats real time. music object convenient structure keeping sound time together splitting extracting parts object independent computations easy using various supporting functions.","code":"tail(x) #> <Music string> #>   Format: space-delimited time #>   Values: <cgc'e'>1 e'4 c'4 g4 c4 <ce'>1 x[8:9] #> <Music string> #>   Format: space-delimited time #>   Values: <cgc'e'~>4 <cgc'e'>1 y <- rep(x[9:10], each = 2) y #> <Music string> #>   Format: space-delimited time #>   Values: <cgc'e'>1 <cgc'e'>1 e'4 e'4 music_strings(y) #> [1] \"5432\" \"5432\" \"2\"    \"2\" a <- notate(\"t8x\", \"Start here\") notes <- \"a, b, c d e f g# a r ac'e' a c' e' c' r*3 ac'e'~ ac'e'\" info <- paste(a, \"t8x t8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1\") x <- as_music(notes, info)  n_measures(x) #> [1] 5.375 n_beats(x) #> [1] 21.5 bpm(x) #> [1] 120 seconds(x) #> [1] 10.75 steps_per_measure(x) #> # A tibble: 5 × 2 #>   measure steps #>     <int> <int> #> 1       1     8 #> 2       2     2 #> 3       3     4 #> 4       4     4 #> 5       5     1 seconds_per_measure(x) #> [1] 2 seconds_per_step(x) #>  [1] 0.1666667 0.1666667 0.1666667 0.1250000 0.8750000 0.1250000 0.1250000 #>  [8] 1.0000000 1.0000000 0.7500000 0.2500000 0.5000000 0.5000000 0.2500000 #> [15] 0.2500000 0.2500000 0.2500000 2.0000000 2.0000000 steps_start_time(x) #>  [1] 0.0000000 0.1666667 0.3333333 0.5000000 0.6250000 1.5000000 1.6250000 #>  [8] 1.7500000 2.7500000 3.7500000 4.5000000 4.7500000 5.2500000 5.7500000 #> [15] 6.0000000 6.2500000 6.5000000 6.7500000 8.7500000"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-noteinfo.html","id":"the-noteinfo-class","dir":"Articles","previous_headings":"","what":"The noteinfo class","title":"Note information","text":"data stored noteinfo object always includes duration, can also consist various pieces sheet music notation markup syntax; information distinct pitch , example slurs staccato notes. available information aside note duration tends specifically relevant sheet music transcription, can find details transcription vignettes introduce phrase class. worth browsing table phrases vignette note info notation unfamiliar.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-noteinfo.html","id":"checking-note-info","dir":"Articles","previous_headings":"The noteinfo class","what":"Checking note info","title":"Note information","text":"string can checked directly informable(). reports whether entire string conforms requirements valid noteinfo syntax. special case durations provided information, durations include triplets \"t\" dotted notes \".\", integer vector suffice. Even , digit like 5 belong.","code":"x <- \"2. 4.. 8 t8-. t8- t8^ 16\" informable(x) #> [1] TRUE informable(\"5\") #> [1] FALSE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-noteinfo.html","id":"coercion","dir":"Articles","previous_headings":"The noteinfo class","what":"Coercion","title":"Note information","text":"Use as_noteinfo() coerce noteinfo object. print summary statements. Similar noteworthy object, generic methods applied noteinfo class.","code":"x <- as_noteinfo(x) x #> <Note info string> #>   Format: space-delimited time #>   Values: 2. 4.. 8 t8-. t8- t8^ 16 summary(x) #> <Note info string> #>   Timesteps: 7 #>   Format: space-delimited time #>   Values: 2. 4.. 8 t8-. t8- t8^ 16"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-noteinfo.html","id":"other-methods","dir":"Articles","previous_headings":"The noteinfo class","what":"Other methods","title":"Note information","text":"","code":"length(x) #> [1] 7 rev(x) #> <Note info string> #>   Format: space-delimited time #>   Values: 16 t8^ t8- t8-. 8 4.. 2. x[2:4] #> <Note info string> #>   Format: space-delimited time #>   Values: 4.. 8 t8-. x[2:3] <- c(\"1(\", \"2)\") x #> <Note info string> #>   Format: space-delimited time #>   Values: 2. 1( 2) t8-. t8- t8^ 16"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-noteinfo.html","id":"note-info-functions","dir":"Articles","previous_headings":"","what":"Note info functions","title":"Note information","text":"noteworthy class, helper functions available make convenient extract manipulate data noteinfo objects. examples. info_duration() handy function strips away information note durations. functions return logical vectors indicating timesteps certain types information present. info_annotation() extracts text annotations timesteps, returning NA annotation.","code":"a <- notate(\"t8x\", \"Start here\") x <- paste(a, \"t8x t8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1\")  info_duration(x) #> <Note info string> #>   Format: vectorized time #>   Values: t8 t8 t8 16 4.. 16 16 2 2 4. 8 4 4 8 8 8 8 1 1 info_slur_on(x) #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE #> [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE info_slur_off(x) #>  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE #> [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE info_slide(x) #>  [1] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE #> [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE info_dotted(x) #>  [1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE #> [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE info_annotation(x) #>  [1] \"Start here\" NA           NA           NA           NA           #>  [6] NA           NA           NA           NA           NA           #> [11] NA           NA           NA           NA           NA           #> [16] NA           NA           NA           NA"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-noteinfo.html","id":"use-cases","dir":"Articles","previous_headings":"","what":"Use cases","title":"Note information","text":"unlikely reason use noteinfo objects isolation. meant compliment noteworthy objects timestep length. see used combination construct phrases sheet music transcription, also build music object. Music objects subject next tutorial. key takeaway noteworthy- noteinfo-class objects intended provide clean separation sound time, respectively. true note information can just duration, including notation markup represents things effect note sounds, focus specifically separating pitch time (everything else). much analysis can done sequence pitches alone. temporal information meant included noteworthy object rank level. temporal sequence; object built around timesteps. interval/ratio level data part definition. needed, noteinfo paired pitch.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"note-identity-checks","dir":"Articles","previous_headings":"","what":"Note identity checks","title":"Note functions","text":"number functions assist music programming around note pitch validation, comparison, equivalence checking, various manipulations transformations. previous section, saw is_note() is_chord(). identity functions include: note_has_natural() note_has_accidental() note_has_flat() note_has_sharp() note_is_natural() note_is_accidental() note_is_flat() note_is_sharp() note_has_tick() note_has_integer() note_is_tick() note_is_integer() is_diatonic() function is_diatonic() takes key signature context.","code":"x <- \"c e_ g b_\" note_has_accidental(x) #> [1] TRUE note_is_accidental(x) #> [1] FALSE  TRUE FALSE  TRUE x <- \"c e_ g b_ cd#g\" is_diatonic(x, key = \"c\") #> [1]  TRUE FALSE  TRUE FALSE FALSE is_diatonic(x, key = \"b_\") #> [1]  TRUE  TRUE  TRUE  TRUE FALSE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"noteworthy-string-metadata","dir":"Articles","previous_headings":"","what":"Noteworthy string metadata","title":"Note functions","text":"number functions parse basic metadata noteworthy strings. n_steps() n_notes() n_chords() n_octaves() chord_size() octave_type() accidental_type() time_format() is_space_time() is_vector_time() See help(\"note-metadata\") details. examples shown .","code":"x <- \"e_2 a_, c#f#a#\" n_steps(x) #> [1] 3 n_notes(x) #> [1] 2 n_chords(x) #> [1] 1 chord_size(x) #> [1] 1 1 3 octave_type(x) #> [1] \"tick\" time_format(x) #> [1] \"space-delimited time\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"noteworthy-string-summaries","dir":"Articles","previous_headings":"","what":"Noteworthy string summaries","title":"Note functions","text":"clear delineation previous set functions next, helps break bit since many. functions go bit summarizing data noteworthy strings. tally_notes() tally_pitches() octaves() tally_octaves() distinct_notes() distinct_pitches() distinct_octaves() pitch_range() semitone_range() semitone_span() octave_range() octave_span() See help(\"note-summaries\") details. examples.","code":"x <- \"e_2 a_, b_, c#f#a# c#'f#'a#''\" tally_notes(x) #> # A tibble: 6 × 2 #>   note      n #>   <chr> <int> #> 1 c#        2 #> 2 e_        1 #> 3 f#        2 #> 4 a_        1 #> 5 a#        2 #> 6 b_        1 tally_pitches(x) #> # A tibble: 9 × 2 #>   pitch     n #>   <chr> <int> #> 1 e_2       1 #> 2 a_,       1 #> 3 b_,       1 #> 4 c#        1 #> 5 f#        1 #> 6 a#        1 #> 7 c#'       1 #> 8 f#'       1 #> 9 a#''      1 distinct_notes(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d_ e_ g_ a_ b_ b_ distinct_pitches(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, d_ g_ b_ d_' g_' b_'' pitch_range(x) #> [1] \"e_,\"  \"b_''\" semitone_range(x) #> [1] 39 82"},{"path":[]},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"accidentals","dir":"Articles","previous_headings":"Coercion functions","what":"Accidentals","title":"Note functions","text":"Note common functions treat notes different sound one transcribed flat sharp. tabr makes distinction notation purposes; pitch, different notes. also supports transcription. Functions like transpose() course handle pitch pitch therefore style representation affect computation. functions enforcing singular representation accidentals noteworthy strings since unusual mix flats sharps. confused names functions. enforcing single type accidental. actually lower sharps half step semitone well raise flats similarly, use naturalize(). helpful building blocks music programming. useful wrapper around flatten_sharp() sharpen_flat() note_set_key(). Like is_diatonic(), function takes key argument. key meaningful is_diatonic. However, providing key signature helpful purpose enforcing correct representation accidentals intended user, tabr know informed. aware default functions take key argument c, c accidentals key signatures, note_set_key() effect pass values key. also important recognize matter function key choose specifically; matters choose key type accidentals signature wish force noteworthy string use. want flats, makes difference set key = \"f\" key = \"b_\". function, can also literally enter key = \"flat\" key = \"sharp\", options stress extent key actually matters note_set_key(). intent force notes may diatonic key signature fit signature. pitches remain exactly . matter key. forced conform key’s representation accidentals. functions tabr, key arguments utilize specific key signature complete manner, options flat sharp relevant allowed.","code":"flatten_sharp(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <d_g_b_> <d_'g_'b_''> sharpen_flat(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d#, g#, a#, <c#f#a#> <c#'f#'a#''> naturalize(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e, a, b, <cfa> <c'f'a''> note_set_key(x, \"c\") # no change possible #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <d_g_b_> <d_'g_'b_''> note_set_key(x, \"f\") # key of F has a flat #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <d_g_b_> <d_'g_'b_''> note_set_key(x, \"g\") # key of G has a sharp #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d#, g#, a#, <c#f#a#> <c#'f#'a#''>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"octave-numbering","dir":"Articles","previous_headings":"Coercion functions","what":"Octave numbering","title":"Note functions","text":"Octave numbering can ambiguous, including tick integer numbering format. can coerce noteworthy string strictly one : general, functions operate return noteworthy strings perform coercion internally consistent format. formatting ambiguous, default tick octave numbering flats accidentals.","code":"x <- \"c, c c' c2 c c4\" as_integer_octaves(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c2 c c4 c2 c c4 as_tick_octaves(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c, c c' c, c c'"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"timestep-format","dir":"Articles","previous_headings":"Coercion functions","what":"Timestep format","title":"Note functions","text":"Similarly, can coerce time format noteworthy string space-delimited time vectorized time:","code":"(x <- as_space_time(c(\"c\", \"e\", \"g\", \"ceg\"))) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e g <ceg> (y <- as_vector_time(\"c e g ceg\")) #> <Noteworthy string> #>   Format: vectorized time #>   Values: c e g <ceg> as.character(x) #> [1] \"c e g ceg\" as.character(y) #> [1] \"c\"   \"e\"   \"g\"   \"ceg\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"comparative-equivalence","dir":"Articles","previous_headings":"","what":"Comparative equivalence","title":"Note functions","text":"note_is_* functions mentioned earlier vectorized, operations perform self checks. functions available comparative checks identity equivalence two notes. functions also vectorized. note input can entire noteworthy string. different dimensions along strictness equality varies worth taking moment break properties clearly: functions come *_is_equal *is_identical pairs. Equality relaxed identity. note_is_* pairs also offer argument ignore_octave. weakens requirements passing equality identity comparisons two notes. functions perform noteworthy check, require anything stricter. means comparisons work notes, even belonging chords. general distinction notes equal notes identical sound vs. transcription/written notation. two notes sound , e.g. e_ d#, equal, identical. additional nuances octave comparisons using octave_is_* pairs. First look note pitch comparisons. main difference pitch complete note former implicitly carries octave position. Setting ignore_octave = FALSE note comparisons makes equivalent pitch comparison counterparts. minimal requirements equivalence precede forms degrees equivalence described shown . bare minimum, two noteworthy strings must number time steps available pairwise comparison. Otherwise simple NA returned. following example, strings x y number notes, order, first three times steps second two. next example, x y number notes, order, even equal number timesteps. number timesteps makes pairwise comparisons possible. return FALSE unequal. Finally, octave comparisons, must defined behave somewhat differently. octave_is_equal() octave_is_identical() allow much weaker forms equivalence ignore notes completely. functions concerned comparing octave numbers spanned pitches present timestep. checking equality, octave_is_equal() looks octave number associated first note step, e.g., root note chord. octave_is_identical() compares octaves spanned given timestep considering notes chord present. still leaves open definitions equivalence. clarify: matter comparing two chords may comprised different numbers notes. set unique octaves spanned one chord identical set spanned , considered identical octave coverage. Consider example: a1b2c3 identical d1e1f2g3. notes irrelevant. number notes irrelevant. fact octave number one occurs different number times chord irrelevant. matters set unique octave positions {1, 2, 3}. equal, even less required. case matters two chords begin x1, x note. One alternative, octave_is_identical() , set single_octave = TRUE. increases requirement identity require notes chords compared given timestep share single octave.","code":"x <- \"b_2 ce_g\" y <- \"b_ cd#g\" note_is_equal(x, y) #> [1] TRUE TRUE note_is_identical(x, y) #> [1]  TRUE FALSE pitch_is_equal(x, y) #> [1] FALSE  TRUE pitch_is_identical(x, y) #> [1] FALSE FALSE x <- \"b_2 ce_g b_\" y <- \"b_2 ce_gb_\" note_is_equal(x, y) #> [1] NA x <- \"b_2 ce_g b_\" y <- \"b_2 ce_ gb_\" note_is_equal(x, y) #> [1]  TRUE FALSE FALSE x <- \"a1 b_2 a1b2c3 a1b4 g1a1b1\" y <- \"a_2 g#2 d1e1f2g3 a1b2b4 d1e1\" octave_is_equal(x, y) #> [1] FALSE  TRUE  TRUE  TRUE  TRUE octave_is_identical(x, y) #> [1] FALSE  TRUE  TRUE FALSE  TRUE octave_is_identical(x, y, single_octave = TRUE) #> [1] FALSE  TRUE FALSE FALSE  TRUE x <- \"a,, b_, a,,b,c a,,b' g,,a,,b,,\" y <- \"a_, g#, d,,e,,f,g a,,b,b' d,,e,,\" octave_is_equal(x, y) #> [1] FALSE  TRUE  TRUE  TRUE  TRUE octave_is_identical(x, y) #> [1] FALSE  TRUE  TRUE FALSE  TRUE octave_is_identical(x, y, single_octave = TRUE) #> [1] FALSE  TRUE FALSE FALSE  TRUE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"slice-sort-rotate-shift-arpeggiate","dir":"Articles","previous_headings":"","what":"Slice, sort, rotate, shift, arpeggiate","title":"Note functions","text":"noteworthy string can subset index. can specific integers logical vector length number time steps. Vectorized time trivial course handled way still applies noteworthiness check class assignment. Sorting pitch works chords sorting successively across notes chord. example, , sorted lower ,ce, turn lower ,e. example notes chords sorted pitch. final chord sequence also spans three octaves. also ba, ordered, accounted sorting successive pitches chords. Rotating cycling sequence notes chords noteworthy string done note_rotate(). simple function. rotates sequence left right. transposition. break chords, rather rotates intact. note_shift() also rotates notes, pitch like moving window. requires breaking chords separate notes, ordering notes pitch, shifting sorted notes n times, negative positive indicating direction. note_arpeggiate() like note_shift() repeats entire sequence rather shifting note time maintaining fixed size. n refers number repeats must positive. steps refers semitone offset.","code":"x <- \"a b ceg\" note_slice(x, 2:3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b <ceg> note_slice(x, c(FALSE, TRUE, TRUE)) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b <ceg> x <- c(\"a\", \"b\", \"ceg\") note_slice(x, 2:3) #> <Noteworthy string> #>   Format: vectorized time #>   Values: b <ceg> note_slice(x, c(FALSE, TRUE, TRUE)) #> <Noteworthy string> #>   Format: vectorized time #>   Values: b <ceg> x <- \"bd'f#' a c'e'g' b ba c'g' gd'g'd''\" note_sort(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <gd'g'd''> a <ba> b <bd'f#'> <c'e'g'> <c'g'> note_sort(x, decreasing = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <c'g'> <c'e'g'> <bd'f#'> b <ba> a <gd'g'd''> note_rotate(x, 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a <c'e'g'> b <ba> <c'g'> <gd'g'd''> <bd'f#'> note_rotate(x, -1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <gd'g'd''> <bd'f#'> a <c'e'g'> b <ba> <c'g'> note_shift(\"c e g\", 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e g c' note_shift(\"c e g\", -4) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g,, c, e, note_arpeggiate(\"c e_ g_ a\", 3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e_ g_ a c' e_' g_' a' c'' e_'' g_'' a'' c''' e_''' g_''' a''' note_arpeggiate(\"c e_ g_ a\", 3, -3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e_ g_ a a, c e_ g_ g_, a, c e_ e_, g_, a, c"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-notes.html","id":"transpose","dir":"Articles","previous_headings":"","what":"Transpose","title":"Note functions","text":"important function tabr manipulating music notation transpose() function, also alias tp(). Transposing done negative integers. transpose also offers arguments found as_noteworthy() direct control format transposed output. can specify key signature key optional override accidentals. anything enforce desired format accidentals. transpose() also works chords present. next section music programming covers various functions related chords.","code":"notes1 <- \"c b, c d e e d c b, c c c'\" notes2 <- \"c' b c' d' e' e' d' c' b c' c' c''\" transpose(notes1, 12, octaves = \"integer\") == as_noteworthy(notes2) #>  [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE transpose(\"a_ b_' c'\", 0) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_ b_' c' tp(\"a_ b_' c'\", -1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g a' b tp(\"a_ b_' c'\", 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b' d_' tp(\"a# b' c#'\", 11) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a' a#'' c'' tp(\"a# b' c#'\", -12) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a#, b c# tp(\"a# b' c#'\", 13) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b' c''' d'' tp(\"a3 b4 c5\", 2, key = \"f\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b d_5 d5 tp(\"a3 b4 c5\", 2, octaves = \"tick\", key = \"g\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b c#'' d'' tp(\"a b' c''\", 2, accidentals = \"flat\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b d_'' d'' tp(\"a, b c'e'g'\", 2, octaves = \"integer\", accidentals = \"sharp\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b2 c#4 <d4f#4a4>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-nw.html","id":"noteworthy-strings","dir":"Articles","previous_headings":"","what":"Noteworthy strings","title":"Noteworthiness","text":"exploring many music programming functions package, worth introducing important concept expressed throughout tabr: noteworthiness. Prior construction phrase class objects can passed LilyPond sheet music engraving, start simple character strings. strings contain letters representing musical notes, possibly characters indicate things sharps flats, octave number, rests. number requirements strings must meet valid tabr music notation syntax can transformed meaningfully unambiguously LilyPond syntax. string considered noteworthy meets requirements differentiate arbitrary character strings. important familiar requirements noteworthy string can construct properly. also noteworthy class object built upon strings valid music notation syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-nw.html","id":"checking-noteworthiness","dir":"Articles","previous_headings":"Noteworthy strings","what":"Checking noteworthiness","title":"Noteworthiness","text":"string can checked directly noteworthy(). reports whether entire string conforms requirements valid noteworthy syntax.","code":"x <- \"a, r b,*2 ce_g cd#g\" noteworthy(x) #> [1] TRUE noteworthy(\"h\") #> [1] FALSE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-nw.html","id":"the-noteworthy-class","dir":"Articles","previous_headings":"Noteworthy strings","what":"The noteworthy class","title":"Noteworthiness","text":"Functions tabr take noteworthy strings input perform internal checks noteworthiness throw error provide unworthy string. checks skipped input already noteworthy class. function returns noteworthy string, class also noteworthy. important understand notion noteworthy strings implemented throughout tabr. One purpose thorough strict input validation. leads robust function behavior consistent user programming experience rejecting problematic string input early. as_noteworthy() can used coerce noteworthy class. Coercion fail string noteworthy. class offers print summary methods noteworthy strings well number generic method implementations. functions intended aggressively interpret character string noteworthy, performing check coercion directly, many functions package require explicit noteworthy object. especially true generics, dispatch methods based class input object. Functions like as_noteworthy() added benefit conforming notes formatting. clean presence combined flats sharps combined tick integer octave numbering. coercing noteworthy character string one noteworthy class, formatting inferred notes input. Precedence given ticks octave numbering flats accidentals. can specify formatting attributes providing explicit arguments. useful coercing another format. functions like transpose() also expose formatting arguments directly. functions, format strictly inferred input notes, can always coerce another format as_noteworthy(). aside, tick octave notation default just used LilyPond. vignettes transcription show conversion integers ticks phrase objects used transcription automatic. Another reason use tick format regardless robust. tabr, integer octaves go zero without leading problematic syntax, can always add commas octaves decrease. even critical reason music class, assembles noteworthy class object noteinfo class object together, strictly uses tick format octave numbering numbers needed unambiguously describe time juxtaposed octave numbering.","code":"x <- \"a# b_*2 c, d'' e3*2 g_4 c2e_2g2*2\" x <- as_noteworthy(x) x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b_ b_ b_ c, d'' e e g_' <c,e_,g,> <c,e_,g,> summary(x) #> <Noteworthy string> #>   Timesteps: 10 (8 notes, 2 chords) #>   Octaves: tick #>   Accidentals: flat #>   Format: space-delimited time #>   Values: b_ b_ b_ c, d'' e e g_' <c,e_,g,> <c,e_,g,> x <- as_noteworthy(x, format = \"vector\", octaves = \"tick\", accidentals = \"flat\") x #> <Noteworthy string> #>   Format: vectorized time #>   Values: b_ b_ b_ c, d'' e e g_' <c,e_,g,> <c,e_,g,> summary(x) #> <Noteworthy string> #>   Timesteps: 10 (8 notes, 2 chords) #>   Octaves: tick #>   Accidentals: flat #>   Format: vectorized time #>   Values: b_ b_ b_ c, d'' e e g_' <c,e_,g,> <c,e_,g,>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-nw.html","id":"stricter-note-and-chord-validation","dir":"Articles","previous_headings":"Noteworthy strings","what":"Stricter note and chord validation","title":"Noteworthiness","text":"noteworthy() built upon specific, vectorized functions is_note() is_chord(), provide detailed information space-delimited entries string. is_note() is_chord() return logical vector reporting whether entry contains valid note valid chord representation, respectively. Notice vectorized results account expansion operator b,*2. Functions like serve simple purposes unlikely use writing sheet music. However, can highly useful music data analysis, particularly building complex musical manipulations top simpler functions.","code":"x <- \"a, r b,*2 ce_g cd#g HELLO_WORLD\" is_note(x) #> [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE is_chord(x) #> [1] FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-nw.html","id":"notable-phrases","dir":"Articles","previous_headings":"","what":"Notable phrases","title":"Noteworthiness","text":"moving , briefly consider quasi-counterpart noteworthy strings: notable phrases. used tabr, familiar turning strings phrases, assembling phrases tracks scores, sending LilyPond create sheet music. context, might think phrase objects fundamental unit musical information strings create seem like raw data. tabr offers ability reverse direction decompose phrases back component parts: notes, info string character strings. done using notify(), returns tibble data frame. complex phrases, can challenging. expectation true one one functional transformation. example, notify() complex enough handle unfolding repeat sections text notations attached notes inside phrases. Certainly, work LilyPond syntax originally created LilyPond rather tabr tabr provides access tiny fraction LilyPond can . many simpler cases, can successfully invert phrase previously created strings R. phrase considered notable. phrasey() can used check string least loosely resembles content valid phrase object. Additional related functions shown , take phrase complete cycle deconstruction reconstruction. understanding noteworthy strings, next section covers number functions related programming around musical scales.","code":"p1 <- phrase(\"b, c d ec'g'~ ec'g'\", \"4( 4)- 2*3\", \"5*3 432*2\") p1 #> <Musical phrase> #> <b,\\5>4( <c\\5>4)\\glissando <d\\5>2 <e~\\4 c'~\\3 g'~\\2>2 <e\\4 c'\\3 g'\\2>2 x <- as.character(p1) phrasey(x) #> [1] TRUE identical(as_phrase(x), p1) #> [1] TRUE notable(p1) # safe logical check #> [1] TRUE notify(p1) #> # A tibble: 5 × 3 #>   notes    info  string #>   <chr>    <chr> <chr>  #> 1 b,       4(    5      #> 2 c        4)-   5      #> 3 d        2     5      #> 4 e~c'~g'~ 2     432    #> 5 ec'g'    2     432 p2 <- p(phrase_notes(p1), phrase_info(p1), phrase_strings(p1)) identical(p1, p2) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-scales.html","id":"key-signatures","dir":"Articles","previous_headings":"","what":"Key signatures","title":"Musical scales","text":"key signatures, keys lists valid key signature abbreviation strings key used tabr. several key_is_* functions return logical result regarding properties keys: key_is_natural() key_is_sharp() key_is_flat() key_is_major() key_is_minor() also functions, key_n_flats() key_n_sharps(), give number respective accidentals key signature. previous section gave overview noteworthy strings. functions help enforce proper notation R seemed like offer much utility terms direct use, clear integral robustness tabr functions. Now, looking key signature helpers, may tempting dismiss utility even quickly trained musician need invoke command line know result return. functions provided answer basic questions interactive R session much programming. initial building blocks top complex functions built, including many functions tabr. collection music programming helper functions tabr grows, becomes easy less.","code":"keys() #>  [1] \"c\"   \"g\"   \"d\"   \"a\"   \"e\"   \"b\"   \"f#\"  \"c#\"  \"f\"   \"b_\"  \"e_\"  \"a_\"  #> [13] \"d_\"  \"g_\"  \"c_\"  \"am\"  \"em\"  \"bm\"  \"f#m\" \"c#m\" \"g#m\" \"d#m\" \"a#m\" \"dm\"  #> [25] \"gm\"  \"cm\"  \"fm\"  \"b_m\" \"e_m\" \"a_m\" key_is_flat(\"f\") #> [1] TRUE key_n_flats(\"f\") #> [1] 1"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-scales.html","id":"scales","dir":"Articles","previous_headings":"","what":"Scales","title":"Musical scales","text":"Several predefined musical scales provided accessible calling various scale_* functions. scale_chromatic scale_diatonic scale_minor scale_major scale_harmonic_minor scale_hungarian_minor scale_melodic_minor scale_jazz_minor can specify whether vector result returned , convenient vectorized programming pipelines, collapsed single string keeping space-delimited time syntax format common throughout tabr. Many functions tabr accept formats inputs /offer outputs. can also specify octave numbering included stripped. Octave numbering included default maintains pitch order scale start C. Every note noteworthy string implicit octave-3 (octave middle C, C4) position explicitly stated. Octave numbering attempts somewhat balanced around C3. result desired, can shifted 12 semitones transpose(). See help(\"scale-helpers\") details. Depending scale, arguments available.","code":"scale_hungarian_minor(key = \"am\", collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, b, c d# e f g# scale_major(\"f\", TRUE, ignore_octave = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: f g a b_ c d e scale_major(\"f\", TRUE, ignore_octave = FALSE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: f g a b_ c' d' e'"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-scales.html","id":"modes","dir":"Articles","previous_headings":"","what":"Modes","title":"Musical scales","text":"seven modern modes also available mode_* functions modern_mode() passing mode string name. functions include is_mode rotate_mode. mode_ionian() mode_dorian() mode_phrygian() mode_lydian() mode_mixolydian() mode_aeolian() mode_locrian()","code":"modes() #> [1] \"ionian\"     \"dorian\"     \"phrygian\"   \"lydian\"     \"mixolydian\" #> [6] \"aeolian\"    \"locrian\" mode_aeolian(\"c\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: c d e_ f g a_ b_"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-scales.html","id":"diatonic-scale-chords","dir":"Articles","previous_headings":"","what":"Diatonic scale chords","title":"Musical scales","text":"scale_chords() function provides list diatonic scale chords based root note scale chosen. returns triads default can also return seventh chords.","code":"scale_chords(\"b_\", \"major\", \"seventh\", collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_,dfa> <ce_gb_> <dfac'> <e_gb_d'> <fac'e_'> <gb_d'f'> <ac'e_'g'> scale_chords(\"f#\", \"minor\", \"triad\", collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <f#ac#'> <g#bd'> <ac#'e'> <bd'f#'> <c#'e'g#'> <d'f#'a'> <e'g#'b'>"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-scales.html","id":"scale-degrees","dir":"Articles","previous_headings":"","what":"Scale degrees","title":"Musical scales","text":"functions scale_note() scale_degree() map notes degree given scale. chords noteworthy string, root note considered. scale_degree(), note diatonic scale, NA returned. NA also used rests occur. Octaves ignored. scale_note(), degrees outside range scale recycled. See . see chords fully diatonic, use is_diatonic() general is_in_scale(). chord_degree() return list comparable scale_degree(). functions tabr also work scales build upon functions introduced .","code":"x <- \"c e gb'd'\" scale_degree(x) #> [1] 1 3 2 scale_degree(x, key = \"a\") #> [1] NA  5  4 scale_degree(x, key = \"am\") #> [1] 3 5 4 scale_degree(x, scale = \"chromatic\") #> [1] 1 5 3 scale_note(1:7, \"d\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: d e f# g a b c# scale_note(c(1:8), \"dm\", \"harmonic minor\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: d e f g a b_ d_ d note_in_scale(\"a_ g#\", \"a_\", strict_accidentals = FALSE) #> [1] TRUE TRUE x <- \"r d dfa df#a f#ac#\" chord_degree(x, \"d\") #> [[1]] #> [1] NA #>  #> [[2]] #> [1] 1 #>  #> [[3]] #> [1]  1 NA  5 #>  #> [[4]] #> [1] 1 3 5 #>  #> [[5]] #> [1] 3 5 7 is_in_scale(x, \"d\") #> [1]    NA  TRUE FALSE  TRUE  TRUE is_diatonic(x, \"d\") #> [1]    NA  TRUE FALSE  TRUE  TRUE"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-prog-scales.html","id":"musical-intervals","dir":"Articles","previous_headings":"","what":"Musical intervals","title":"Musical scales","text":"Musical intervals can referenced name numeric value defining separation two notes. interval_semitones() returns positive integer describing number semitones spanned common interval. takes name abbreviation common interval input. Essentially, entry column mainIntervals dataset can used obtain interval semitones. ’s simple filter match, convenient map different representations property tabr without typing extra bit code time. Likely useful programming, function pitch_interval() provides number semitones two input notes. function relate specific scales, worth mentioning topic interval helpers. provides magnitude direction. result negative first note higher pitch second. vectorized inputs must number timesteps. Chords can reduced root note (lowest pitch) comparison forced yield NA interval respect two adjacent timesteps (e.g., c ceg NA ceg c). Rests r silent rests s also yield NA interval prior note. Next scale_interval(). function similar pitch_interval() takes two noteworthy strings, together define intervals element-wise. almost inverse interval_semitones() except provide notes rather semitone distance intervals. function returns main interval name abbreviation mainIntervals, depending format. results name-. signed. Use pitch_interval() obtain direction. also lagged difference versions functions. can adjust lag n. can also retain (convenient data frames) trim n leading NAs. trim meaningful NAs like resulting rests. Lagged intervals respect rest timesteps. timestep positions including rests retained, lag-n difference computation ignores .","code":"mainIntervals #> # A tibble: 26 × 5 #>    semitones mmp            mmp_abb ad                                ad_abb #>        <int> <chr>          <chr>   <chr>                             <chr>  #>  1         0 perfect unison P1      diminished second                 d2     #>  2         1 minor second   m2      augmented unison                  A1     #>  3         2 major second   M2      diminished third                  d3     #>  4         3 minor third    m3      augmented second                  A2     #>  5         4 major third    M3      diminished fourth                 d4     #>  6         5 perfect fourth P4      augmented third                   A3     #>  7         6 tritone        TT      diminished fifth/augmented fourth d5/A4  #>  8         7 perfect fifth  P5      diminished sixth                  d6     #>  9         8 minor sixth    m6      augmented fifth                   A5     #> 10         9 major sixth    M6      diminished seventh                d7     #> # ℹ 16 more rows interval_semitones(c(\"m3\", \"M7\")) #> [1]  3 11 pitch_interval(\"a2\", \"c\") #> [1] 3 pitch_interval(\"c d e\", \"c c c\") #> [1]  0 -2 -4 pitch_interval(\"r c ceg c e g s\", \"a c d d f# a e\") #> [1] NA  0  2  2  2  2 NA pitch_interval(\"r c ceg c e g s\", \"a c d d f# a e\", use_root = FALSE) #> [1] NA  0 NA  2  2  2 NA scale_interval(\"c c c c\", \"c, e g b\") #> [1] \"P8\" \"M3\" \"P5\" \"M7\" scale_interval(\"a2\", \"c\", format = \"mmp\") #> [1] \"minor third\" pitch_diff(\"c d e f g a b\") #> [1] NA  2  2  1  2  2  2 pitch_diff(\"c d e f g a b\", trim = TRUE) #> [1] 2 2 1 2 2 2 scale_diff(\"c d e f g a b\") #> [1] NA   \"M2\" \"M2\" \"m2\" \"M2\" \"M2\" \"M2\" scale_diff(\"c d e f g a b\", n = 2) #> [1] NA   NA   \"M3\" \"m3\" \"m3\" \"M3\" \"M3\" x <- \"a, c r r r r g\" pitch_diff(x) #> [1] NA  3 NA NA NA NA  7 scale_diff(x) #> [1] NA   \"m3\" NA   NA   NA   NA   \"P5\" pitch_diff(x, n = 2) #> [1] NA NA NA NA NA NA 10 scale_diff(x, n = 2, trim = TRUE) #> [1] NA   NA   NA   NA   \"m7\""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-repeats.html","id":"unfolded-repeats","dir":"Articles","previous_headings":"","what":"Unfolded repeats","title":"Repeats","text":"already seen pn() used repeat phrases character strings n times. helps keep R code shorter repetitive music. However, nothing resulting LilyPond markup final sheet music output. strictly limit repetitive typing used generally section repeats. rp() achieves result. shorten music transcription. simplest collection repeat functions apply LilyPond repeat tags around phrase objects. Take following phrase example. Note difference n results pn() vs. rp(). Usually argument like n refers total number times, pn(). tabr repeat functions, n always refers number repeats added initial play, one less total number plays. Therefore, n always begins counting one (default), since reason use repeat functions repeating anything.  tablature output , first two measures pertaining use pn() identical last two resulting rp(). Unfolding repeated section different writing fully. rp() represents shortening LilyPond markup applying \\repeat \\unfold tag around music. 2 shown LilyPond markup output total number plays, n + 1. Think pn() general purpose helper function tabr pasting copies strings together whereas rp() might used thinking specifically meaningful, discrete section music.","code":"p1 <- p(\"c e g c' e' c' g e\", 8) pn(p1, 2) # repeat n = 2 times #> <Musical phrase> #> <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 rp(p1, 1) # repeat once (n = 1), or play twice (n + 1) #> <Musical phrase> #> \\repeat unfold 2 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 } #> pc(pn(p1, 2), rp(p1)) |> track() |> score() |> tab(\"example17.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-repeats.html","id":"percent-repeats","dir":"Articles","previous_headings":"","what":"Percent repeats","title":"Repeats","text":"Like rp(), pct() remove measures music tablature output. However, percent repeat symbols can shorten sheet music much may make measures music smaller size result nothing else print measure repeat symbol . can also make transcription less messy straining eyes particularly section repeated percent symbols one uses lot ink page. next example uses pct() previous phrase follows high ink measure using percent repeats another four measures.  nice stare rapid bar chords every measure. earlier measures also shorter result display notes.","code":"pct(p1, 3) #> <Musical phrase> #> \\repeat percent 4 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 } #> p2 <- p(\"g,b,dgbg'*16\", 16) pc(pct(p1, 3), pct(p2, 3)) |> track() |> score() |> tab(\"example18.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-repeats.html","id":"volta-repeats","dir":"Articles","previous_headings":"","what":"Volta repeats","title":"Repeats","text":"Finally volta() repeat function. Unlike rp() pct(), volta must applied whole measures music. endings also must whole measures. also way specify repeats alternate endings, though required. either case, type repeat notation remove entire measures music output. examples uses volta() original phrase various endings. endings.","code":"e1 <- p(\"f a c' f'\", 4) e2 <- p(\"c*8\", 8) e3 <- p(\"cegc'e'\", 1)"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-repeats.html","id":"no-alternate-endings","dir":"Articles","previous_headings":"Volta repeats","what":"No alternate endings","title":"Repeats","text":"n = 1 repeat, volta() simply adds double bars around section. annotation sheet music, assumed section repeated one time. n greater one, annotation appears clarifying number times play section. brevity, concatenate . Note volta repeat bar beginning repeated section omitted staff occurs start song.  instances want suppress annotation. Specifically, multiple tab staffs present, need print annotation every staff top one. Also, edge case notes section may already annotations attached via notate(), case annotation may get way. can suppressed volta() silent = TRUE.","code":"volta(p1) #> <Musical phrase> #> \\repeat volta 2 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> volta(p1, 2) #> <Musical phrase> #> \\repeat volta 3 { <c>8^\"Play 3 times.\" <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> pc(volta(p1), volta(p1, 2)) |> track() |> score() |> tab(\"example19.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-repeats.html","id":"single-alternate-ending","dir":"Articles","previous_headings":"Volta repeats","what":"Single alternate ending","title":"Repeats","text":"alternate endings used volta(), annotation staff never included number times section played clear explicit endings numbering. Note number repeats exceeds number alternate endings, initial alternate ending reused first number remaining repeats covered alternate endings. subsequent alternate endings recycled. clear, phrase passed volta() contain represent implicit default ending. used without alternate endings, “ending”; just phrase. alternate endings provided, represent endings. first alternate “default” want think way. , concatenate two examples. remaining examples using alternate endings, single measure whole note C added repeated sections separate provide better sense context.","code":"volta(p1, 1, e1) #> <Musical phrase> #> \\repeat volta 2 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> \\alternative { #>   { <f>4 <a>4 <c'>4 <f'>4 | } #> } volta(p1, 2, e1) #> <Musical phrase> #> \\repeat volta 3 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> \\alternative { #>   { <f>4 <a>4 <c'>4 <f'>4 | } #> } c1 <- p(\"c\", 1) pc(volta(p1, 1, e1), c1, volta(p1, 2, e1), c1) |> track() |> score() |> tab(\"example20.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-repeats.html","id":"multiple-alternate-endings","dir":"Articles","previous_headings":"Volta repeats","what":"Multiple alternate endings","title":"Repeats","text":"Multiple alternate endings work similarly single. first ending recycled necessary. Subsequent endings used . want use subsequent ending , just provide accordingly. Clearly, reason provide endings number times section played. extra endings providing, LilyPond issue warning rendering document notifying alternates repeats excess ignored.","code":"x1 <- volta(p1, 2, list(e1, e2, e3)) x2 <- volta(p1, 2, list(e1, e2)) x3 <- volta(p1, 2, e1) x1 #> <Musical phrase> #> \\repeat volta 3 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> \\alternative { #>   { <f>4 <a>4 <c'>4 <f'>4 | } #>   { <c>8 <c>8 <c>8 <c>8 <c>8 <c>8 <c>8 <c>8 | } #>   { <c e g c' e'>1 | } #> } x2 #> <Musical phrase> #> \\repeat volta 3 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> \\alternative { #>   { <f>4 <a>4 <c'>4 <f'>4 | } #>   { <c>8 <c>8 <c>8 <c>8 <c>8 <c>8 <c>8 <c>8 | } #> } x3 #> <Musical phrase> #> \\repeat volta 3 { <c>8 <e>8 <g>8 <c'>8 <e'>8 <c'>8 <g>8 <e>8 | } #> \\alternative { #>   { <f>4 <a>4 <c'>4 <f'>4 | } #> } pc(x1, c1, x2, c1, x3, c1) |> track() |> score() |> tab(\"example21.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-snippets.html","id":"music-objects","dir":"Articles","previous_headings":"","what":"Music objects","title":"Music snippets in R markdown","text":"","code":"g <- as_music(\"a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\") b <- as_music(\"a,,4;3*5 b,,4- c,4 c,g,c~4 c,g,c1 c4;1 g,;2 c,;3 g,;2 c,c1;31\") summary(g) #> <Music string> #>   Timesteps: 14 (11 notes, 3 chords) #>   Octaves: tick #>   Accidentals: flat #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: NA #>   Strings: 5 5 5 5 5 5 5 5432 5432 2... #>   Format: space-delimited time #>   Values: a,4 a,4 a,4 a,4 a,4 b,4- c4 <cgc'e'~>4 <cgc'e'>1 e'4 c'4 g4 c4 <ce'>1 summary(b) #> <Music string> #>   Timesteps: 14 (11 notes, 3 chords) #>   Octaves: tick #>   Accidentals: flat #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: NA #>   Strings: 3 3 3 3 3 3 3 321 321 1... #>   Format: space-delimited time #>   Values: a,,4 a,,4 a,,4 a,,4 a,,4 b,,4- c,4 <c,g,c~>4 <c,g,c>1 c4 g,4 c,4 g,4 <c,c>1"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-snippets.html","id":"snippet-in-r-markdown-chunk","dir":"Articles","previous_headings":"","what":"Snippet in R markdown chunk","title":"Music snippets in R markdown","text":"defaults plot_music() include treble clef tab staff. Plot music object, g. can see, appears octave guitar transcription use clef = \"treble_8\" instead default clef = \"treble\".  can see call plot_music(g)document since echo = TRUE code chunk. interactive R session, call draws plot active graphics device. R markdown code chunk inserting plot document looks like Rmd file. image scale properly R distort. However, graphics device dimensions still matter. want avoid excessive whitespace example, may want specify knitr figure options, e.g. fig.height=2, fig.width=7, globally code chunk. values choose depend tall sheet music snippet . enter long snippet code, LilyPond may wrap around multiple lines png file creates. Therefore, may require trial error. Sheet music snippets intended curated one-offs inserting documents.","code":"plot_music(g) ```{r} plot_music(g) ```"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-snippets.html","id":"additional-wrappers","dir":"Articles","previous_headings":"","what":"Additional wrappers","title":"Music snippets in R markdown","text":"various wrapper functions offering convenient, sensible default arguments based function name.     Depending function, additional relevant arguments include clef, tab, tuning string_names. Layout arguments include header, paper, colors, transparent res. function plot_music_tc() equivalent plot_music().","code":"plot_music_tab(g) # tab staff only plot_music_guitar(g) # 8va treble clef for guitar, plus tab staff plot_music_bc(b) # bass clef plot_music_bass(b) # bass clef and tab staff"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"adding-phrases-to-a-track","dir":"Articles","previous_headings":"","what":"Adding phrases to a track","title":"Tracks and scores","text":"Phrases added track using first argument track(), strictly accepts phrase object. Except briefest examples, typically concatenate sequence multiple phrases rests longer section music, usually lasting full duration piece. new single phrase object passed track(). Taking earlier example breaking though multiple phrases illustration. general process seen many times already. , examples given use various arguments available functions, beginning tracks. Briefly exploring arguments, note track() equivalent track_guitar() appropriate default arguments. However, wrappers around track() available take different defaults. track_bass() defaults standard four-string bass tuning includes tab staff. sheet music treble clef bass clef tracks without tablature staff, can use track_tc() track_bc(), respectively.","code":"notesC <- \"c e g c' e' c' g e g b d' g' f a c' f' c e g e c\" strings <- \"5 4 3 2 1 2 3 4 4 3 2 1 4 3 2 1 5 4 3 4 5\" p1 <- p(notesC, \"8*20 2\", strings)  track(p1) #> # A tibble: 1 × 7 #>   phrase       clef     key   tab   tuning    voice lyrics #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA trackbind(track_tc(p1), track_bc(p1)) #> # A tibble: 2 × 8 #>   phrase       clef   key   tab   tuning    voice lyrics    id #>   <list>       <chr>  <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble NA    FALSE e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> bass   NA    FALSE e,a,dgbe'     1 NA         2"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"single-voice","dir":"Articles","previous_headings":"","what":"Single voice","title":"Tracks and scores","text":"default, phrase passed track_* function treated part single voice. See multiple voices. functions assign integer ID 1 voice phrase transformed track. can ignored now. arguments, depending context particular track function, include clef, key, tab, tuning lyrics. use cases, tracks likely contain single voice. can suppress tablature staff tab = FALSE music staff clef = NA, . included music staff given clef symbol appears tablature staff. key specifies key signature music staff, ignored staff suppressed. tab = FALSE suppresses tab staff. tuning specifies string tuning tab staff, ignored staff suppressed.","code":"trackbind(track(p1, clef = NA), track(p1, key = \"g\", tab = FALSE)) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> NA       NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 g     FALSE e,a,dgbe'     1 NA         2"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"multiple-tracks","dir":"Articles","previous_headings":"","what":"Multiple tracks","title":"Tracks and scores","text":"Multiple tracks automatically designated unique staves. default track binding iterate id entries track table row unless specify otherwise keep constant single voice staff. output containing two tracks; case two sets music/tab staff pairs since staves suppressed either track.  example , assume song key C. guitar played standard tuning capo second fret. means tablature written relative capo appears C based chord shapes fret numbers, sounds like D, two semitones . However, say want music staff written D heard. requires two tracks, case, suppress music staff one track tab staff track. necessary first step transpose notes transpose() prior converting LilyPond syntax phrase(). looks rendered. tab staff remains C, written respect capo 2. key D inferred. However, music staff now shows transposition music D, two sharps. notes moved staff accordingly. Simply setting key signature staff key transposed notes .","code":"t1 <- p(\"c'' d'' e'' f'' g''\", \"1 2 4 4 1\", 5) |> track() t2 <- track(p1) trackbind(t1, t2) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         2 trackbind(t1, t2) |> score() |> tab(\"ex22.pdf\") p2 <- tp(notesC, 2, key = \"d\") |> p(\"8*20 2\", strings) t1 <- track(p2, key = \"d\", tab = FALSE) t2 <- track(p1, clef = NA) trackbind(t1, t2) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 d     FALSE e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> NA       NA    TRUE  e,a,dgbe'     1 NA         2 trackbind(t1, t2) |> score() |> tab(\"ex23.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"multiple-voices","dir":"Articles","previous_headings":"","what":"Multiple voices","title":"Tracks and scores","text":"Multiple voices special case multiple tracks tab staff ID constant voice ID varies, allowing voices transcribed distinctly single staff. Phrase objects may associated different voices, still part track. example, standard transcribe fingerstyle guitar using two voices: one thumb plays bass line one fingers play higher melody. voices belong music staff tab staff therefore must share track ID tabr. phrase objects corresponding voice must still transformed two unique track objects. change one must explicitly assigned voice ID 2. Make second voice. Let new, higher voice voice one. first use shown trackbind() combine tracks (single-row track tables) multi-row track tables. result intended result. two voices intended share staff, notice default assigned incremental track IDs id column, just previous examples. voice increments intended based values supplied track() call. However, force voices share staff, necessary override track ID follows. Also note trackbind() takes number tracks via ... argument. providing id , must named argument. two voices distinguished different stem direction notes. first voice ID value stem second stem .","code":"p2 <- p(\"c'' d'' e'' f'' g''\", \"1 2 4 4 1\", 5) t1 <- track(p2, voice = 1) t2 <- track(p1, voice = 2) trackbind(t1, t2) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     2 NA         2 trackbind(t1, t2, id = c(1, 1)) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     2 NA         1 trackbind(t1, t2, id = c(1, 1)) |> score() |> tab(\"ex24.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"putting-it-all-together","dir":"Articles","previous_headings":"","what":"Putting it all together","title":"Tracks and scores","text":"Multiple voices tracks engraved output based order values voice id, respectively. id column created call trackbind(), score() case single track input prior call trackbind() needed. example multiple tracks. first two tracks combine two voices one staff set. third track goes unique staff. Since bottom track (track three) simple, suppress music staff. Even though means bottom tab staff rhythm information associated , rhythm can least inferred tab staff note spacing respect notes first tab staff, explicit rhythm information provided treble clef staff. information still going absent bottom staff, whether rhythm staccato, made eighth notes quarter notes. course, provide definition t3 , doesn’t change fact one else looking sheet music know sure. Suppressing music staves generally trade unambiguous saving space. Remember specify id trackbind() since multiple voices per staff means rely automatic iterated track IDs.  Another important fact worth mentioning multiple simultaneous tracks can bound vertically, never bound horizontally, sequentially time. Tracks always complete segments music fixed beginning end never concatenated serially like phrase objects.","code":"t1 <- track(p2, voice = 1) t2 <- track(p1, voice = 2) t3 <- track(p(\"ce*4 g,*2 f,*2 ce*3\", \"4*10 2\", \"54*4 6*4 54*3\"), clef = NA) t_all <- trackbind(t1, t2, t3, id = c(1, 1, 2)) t_all #> # A tibble: 3 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     2 NA         1 #> 3 <phrase [1]> NA       NA    TRUE  e,a,dgbe'     1 NA         2 score(t_all) |> tab(\"ex25.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"string-tuning","dir":"Articles","previous_headings":"Putting it all together","what":"String tuning","title":"Tracks and scores","text":"String tuning can unique track, intended translate tab staff. means entirely different tracks (destined different tab staves output) may tuned differently. However, distinct voices share staff passed different tunings respective track() calls. next example shows change tuning first tab staff.  Rendering tracks, three look expected given different string tuning. default staff based non-standard tunings indicates tuning beginning staff. tunings, see later tutorial section non-standard tunings. control display alternate tunings whole score rendered sheet music available via various rendering functions.","code":"x <- p(\"e, b, e g b e'\", 8) t1 <- track(x) t2 <- track(x, tuning = \"dropD\") t3 <- track(x, tuning = \"dropC\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"adding-tracks-to-a-score","dir":"Articles","previous_headings":"","what":"Adding tracks to a score","title":"Tracks and scores","text":"Music tracks combined single score passing track table object score(). Like basic track usage, also seen many times point. two arguments score can take, chords chord_seq seen well earlier section chord usage tabr. much add go details three arguments score behave.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"single-vs--multiple-tracks","dir":"Articles","previous_headings":"Adding tracks to a score","what":"Single vs. multiple tracks","title":"Tracks and scores","text":"consistency, single track stored track table even though table one row. tracks track tables. general, track tables can number rows seen. row track table translates new music /tablature staff combined set two staves. single track wrapped call trackbind(), id column yet exist. case score() creates assigns value 1. score() accepts single track table first argument; multiple tracks must bound together trackbind() passing score().","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"chords-and-chord-sequences","dir":"Articles","previous_headings":"Adding tracks to a score","what":"Chords and chord sequences","title":"Tracks and scores","text":"score() accepts additional arguments, chords chord_seq. See tutorial section chords refresher. first informs chord fretboard diagrams make chord chart placed top center rendered tabs. chords provided, simply chord chart inserted top first page. chord_seq informs chord symbols places chord chart (present) well topmost music tab staff. elements incorporated final music score score() function stage diagrams associated entire score specific phrase track, voice staff. Similarly, chord symbol sequence appears time music topmost staff, staff, pertains entire score. redundancy arguments provided score(). contain names chords inform chord symbols. example, provide chord_seq, might wonder makes chords redundant unnecessary make chord chart, . names chord sequence vector used internally define chords (fact, many common chord positions predefined LilyPond), really lose much control specifications actual chord positions inform fretboard diagrams. Besides, defining named vector chord_seq, highly likely named sequence using previously defined chords vector anyhow. Finally, separation two arguments essentially necessary good control definitions, allows use combination two. may want chord chart feel need chord sequence written top staff, vice versa. examples show combination.","code":""},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tracks-scores.html","id":"score-examples","dir":"Articles","previous_headings":"","what":"Score examples","title":"Tracks and scores","text":"make interesting, examples use three track example earlier. However, time convert bottom tab staff bass tab. Specify tuning = \"bass\" track(). shorthand standard four string bass tuning. details tunings instruments, see later tutorial section strings tunings. Instead suppressing music staff track like done last time, use bass clef staff see looks brought together: music_staff = \"bass_8\". bass tuning one octave lower guitar tuning. Drop notes phrase track three one octave. guitar bass respective standard tunings, means four strings bass match bottom four guitar terms notes: E D G. makes simple shift string numbers phrase; bottom string now string four. Finally, repeat every phrase two additional times wrapping phrase rp() n = 2 two unfolded repeats three plays. simply provide better sense rendered score tends look like allowing short phrases actually extend across full page width sheet music. first example, still chord chart chord sequence.  Notice bass tuning automatically leads four line tab. t_all remains unchanged forward. next examples, needed alter chords chord_seq arguments score(). First, define named vectors. chord progression C G F C. C chords last measures one three. F G chords split second measure, one half . can define chords however like. necessarily refer broken chords represented second voice guitar track output, though common. Let’s say chords chord chart refer generally chords can use strum along, generic strumming actually shown tab explicit track pattern meant whatever want make . Let C chord open C chord, matching melody voice two, F G chords refer six string bar chords. Remember order chords chords order appear chord chart. customary show order first appear song, C G F , certainly rule. important part complete control . Also, repeated piece music, repeat named chord sequence integers similarly sequence chord symbols top staff terminate prematurely. Now create version adds chord chart.  chart example matches order defined chord positions. Next, remake score adding chord symbol sequence top staff. Remove chord chart.  Finally, combine .  examples demonstrate level control type content, can elect include exclude depending preferences important helpful supplemental information given song.","code":"t1 <- track(rp(p2, 2), voice = 1) t2 <- track(rp(p1, 2), voice = 2) t3 <- track(rp(p(\"c,e,*4 g,,*2 f,,*2 c,e,*3\", \"4*10 2\", \"32*4 4*4 32*3\"), 2),              clef = \"bass_8\", tuning = \"bass\") t_all <- trackbind(t1, t2, t3, id = c(1, 1, 2)) t_all #> # A tibble: 3 × 8 #>   phrase       clef     key   tab   tuning     voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>      <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'      1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'      2 NA         1 #> 3 <phrase [1]> bass_8   NA    TRUE  e,,a,,d,g,     1 NA         2 score(t_all) |> tab(\"ex28.pdf\") chords <- chord_set(c(c = \"x32o1o\", g = \"355433\", f = \"133211\")) chord_seq <- rep(setNames(c(1, 2, 2, 1), names(chords)[c(1:3, 1)]), 3) chords #>              c              g              f  #> \"x;3;2;o;1;o;\" \"3;5;5;4;3;3;\" \"1;3;3;2;1;1;\" chord_seq #> c g f c c g f c c g f c  #> 1 2 2 1 1 2 2 1 1 2 2 1 score(t_all, chords = chords) |> tab(\"ex29.pdf\") score(t_all, chord_seq = chord_seq) |> tab(\"ex30.pdf\") score(t_all, chords, chord_seq) |> tab(\"ex31.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tunings.html","id":"predefined-tunings","dir":"Articles","previous_headings":"","what":"Predefined tunings","title":"Strings and tunings","text":"tuning argument track accepts variety predefined commonly used string tunings, defaulting standard. table 32 predefined tunings various instruments available.","code":"head(tunings) #>         id        value #> 1 standard    e,a,dgbe' #> 2    seven b,,e,a,dgbe' #> 3    dropD    d,a,dgbe' #> 4    dropC    c,g,cfad' #> 5    openG    d,g,dgbd' #> 6    openD   d,a,df#ad'"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tunings.html","id":"arbitrary-tunings","dir":"Articles","previous_headings":"","what":"Arbitrary tunings","title":"Strings and tunings","text":"importantly, track tuning can also expressed using explicit pitch completely arbitrary tunings number strings (tabr technically supports seven strings general rule). predefined set convenient, necessary use use alternate tunings really shines. explicit tunings shown tunings table can supplied track() exactly shown instead using given names, explicit tuning. Tuning can provided using tick integer octave numbering style. providing tuning, names checked first IDs tunings. match, assumed explicit tuning already. additional checks performed catch common user errors entering tuning. Tuning track defaults standard tuning six string guitar. following calls equivalent result explicit tuning stored track tables.","code":"p1 <- p(\"a\", 1) track(p1, tuning = \"standard\") #> # A tibble: 1 × 7 #>   phrase       clef     key   tab   tuning    voice lyrics #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA track(p1, tuning = \"e2 a2 d g b e4\") #> # A tibble: 1 × 7 #>   phrase       clef     key   tab   tuning    voice lyrics #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA track(p1, tuning = \"e, a, d g b e'\") #> # A tibble: 1 × 7 #>   phrase       clef     key   tab   tuning    voice lyrics #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tunings.html","id":"number-of-strings","dir":"Articles","previous_headings":"","what":"Number of strings","title":"Strings and tunings","text":"tabr focus guitar tablature, offer built support string instruments generally. convenient approach taken tabr number strings instrument , turn number horizontal lines rendered tablature staff, inferred directly explicit tuning. Take predefined bass tuning (standard bass tuning) explicit tuning converted track(), e,, ,, d, g,. tuning specifies four strings. tabr needs know pass along LilyPond yield tablature staff four staff lines opposed standard six line staff used typical guitar tabs. next example shows three different tablature staves: six string guitar standard tuning, four string bass standard tuning, just illustration, one string instrument tuning fourth octave C note.  Notice tunings standard guitar, default show note string tuned start tablature staff. can turning score() using string_names = FALSE. example, making pure bass tab standard tuning, might opt exclude . must still familiarity instrument course. case made one string instrument, one know octave open C belongs , person instrument surely know expect. Take another look example, time including music staves. different octave ranges different instruments, best use appropriate clef. Recall default (used guitar) treble_8 guitar transposing instrument. Compare treble used third instrument higher octave. different notations help prevent difficult read transcriptions notes go far staff lines.","code":"guitar <- tuplet(\"e, a, d g b e'\", 4) bass <- p(\"e,, a,, d, g,\", 4) one_string <- p(\"c' d' e' f'\", 4) tracks <- trackbind(   track(guitar, clef = NA),    track(bass, clef = NA, tuning = \"bass\"),    track(one_string, clef = NA, tuning = \"c'\") ) tracks #> # A tibble: 3 × 8 #>   phrase       clef  key   tab   tuning     voice lyrics    id #>   <list>       <chr> <chr> <lgl> <chr>      <int> <chr>  <int> #> 1 <phrase [1]> NA    NA    TRUE  e,a,dgbe'      1 NA         1 #> 2 <phrase [1]> NA    NA    TRUE  e,,a,,d,g,     1 NA         2 #> 3 <phrase [1]> NA    NA    TRUE  c'             1 NA         3 score(tracks) |> tab(\"out.pdf\") tracks <- trackbind(   track(guitar),    track(bass, clef = \"bass_8\", tuning = \"bass\"),    track(one_string, clef = \"treble\", tuning = \"c'\") ) tracks #> # A tibble: 3 × 8 #>   phrase       clef     key   tab   tuning     voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>      <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'      1 NA         1 #> 2 <phrase [1]> bass_8   NA    TRUE  e,,a,,d,g,     1 NA         2 #> 3 <phrase [1]> treble   NA    TRUE  c'             1 NA         3 score(tracks) |> tab(\"out.pdf\")"},{"path":"https://leonawicz.github.io/tabr/articles/tabr-tunings.html","id":"current-limitations","dir":"Articles","previous_headings":"","what":"Current limitations","title":"Strings and tunings","text":"Although tabr infers instrument’s number strings tuning, limitations. Chord fretboard diagrams supported guitar, six string guitar specifically. attempting pass four five strings information chord_set() bass, ukulele banjo example, incompletely fill six string guitar fretboard diagram chord chart output. Similarly, attempting provide seven strings seven string guitar, chord chart show additional note, floating side chart. seventh string line added diagram. Number strings inferred instrument tuning displays tablature staff, generalize fretboard diagrams.","code":""},{"path":"https://leonawicz.github.io/tabr/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Matthew Leonawicz. Author, maintainer.","code":""},{"path":"https://leonawicz.github.io/tabr/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Leonawicz M (2025). tabr: Music Notation Syntax, Manipulation, Analysis Transcription R. R package version 0.5.4, https://github.com/leonawicz/tabr.","code":"@Manual{,   title = {tabr: Music Notation Syntax, Manipulation, Analysis and Transcription in R},   author = {Matthew Leonawicz},   year = {2025},   note = {R package version 0.5.4},   url = {https://github.com/leonawicz/tabr}, }"},{"path":"https://leonawicz.github.io/tabr/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (https://www.contributor-covenant.org), version 1.0.0, available https://contributor-covenant.org/version/1/0/0/.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"tabr package provides music notation syntax collection music programming functions generating, manipulating, organizing analyzing musical information R. music notation framework facilitates creating analyzing music data notation form; .e, perspective language musician , say, audio engineer.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Matthew Leonawicz (2025). tabr: Music Notation Syntax, Manipulation, Analysis Transcription R. R package version 0.5.4. https://CRAN.R-project.org/package=tabr","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"contribute","dir":"","previous_headings":"","what":"Contribute","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Contributions welcome. Contribute GitHub via pull request. Please create issue first regarding substantive feature add change.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Install CRAN release tabr Install development version GitHub ","code":"install.packages(\"tabr\") # install.packages(\"remotes\") remotes::install_github(\"leonawicz/tabr\")"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"motivating-example","dir":"","previous_headings":"","what":"Motivating example","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"","code":"as_music(\"r8 c d e f g a b c'1\") |> plot_music_guitar()"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"music-data-structures","dir":"","previous_headings":"","what":"Music data structures","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"’s easiest begin high level view using basic examples. Music data can viewed, manipulated analyzed different forms representation based around different data structures: strings data frames. representation offers advantages different use cases. Music syntax can entered directly represented character strings minimize formatting overhead data entry using simple data structures, example wanting quickly enter transcribe short pieces music syntax R sheet music tablature files. can also enter sound time together music class, need repeat consecutive durations change. example making string pitches noteworthy string combined pitch duration music object. objects carry various musical information based syntax input string. Functions exist directly performing various mathematical, logical organizational operations musical transformations strings like one checking music syntax validity adding custom classes methods strings (). tabr offers special object classes facilitate working music data notation ways natural R, robust, tidy, lend well transcription well analysis. course, none work character strings “noteworthy” “musical”, example. Invalid, unworthy syntax rejected early error, preventing corrupted music syntax causing unexpected issues later . music data can also organized tidy data frames, allowing familiar powerful approach analysis large amounts structured music data. Several functions available mapping seamlessly manipulating data structures representations musical information.","code":"library(tabr)  x <- \"a, c e g# a ac'e' ac'e'~ ac'e' a c' e' a'\" x <- as_noteworthy(x) x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c e g# a <ac'e'> <ac'e'~> <ac'e'> a c' e' a'  summary(x) #> <Noteworthy string> #>   Timesteps: 12 (9 notes, 3 chords) #>   Octaves: tick #>   Accidentals: sharp #>   Format: space-delimited time #>   Values: a, c e g# a <ac'e'> <ac'e'~> <ac'e'> a c' e' a'  y <- \"a,8 c et8 g# a ac'e'4. ac'e'~8 ac'e'4 at4 c' e' a'1\" y <- as_music(y) summary(y) #> <Music string> #>   Timesteps: 12 (9 notes, 3 chords) #>   Octaves: tick #>   Accidentals: sharp #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: NA #>   Format: space-delimited time #>   Values: a,8 c8 et8 g#t8 at8 <ac'e'>4. <ac'e'~>8 <ac'e'>4 at4 c't4 e't4 a'1  music_split(y) #> $notes #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c e g# a <ac'e'> <ac'e'~> <ac'e'> a c' e' a' #>  #> $info #> <Note info string> #>   Format: space-delimited time #>   Values: 8 8 t8 t8 t8 4. 8 4 t4 t4 t4 1 #>  #> $lyrics #> [1] NA #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\" x <- \"a,8 c e r r c a, g#, a ac'e'\" as_music(x) |> as_music_df() #> # A tibble: 10 × 14 #>    duration pitch note  semitone octave  freq pitch_int scale_int slur  slide #>    <chr>    <chr> <chr>    <int>  <int> <dbl>     <int> <chr>     <chr> <lgl> #>  1 8        a,    a           57      2  110.        NA <NA>      <NA>  FALSE #>  2 8        c     c           48      3  131.         3 m3        <NA>  FALSE #>  3 8        e     e           52      3  165.         4 M3        <NA>  FALSE #>  4 8        r     r           NA     NA   NA         NA <NA>      <NA>  FALSE #>  5 8        r     r           NA     NA   NA         NA <NA>      <NA>  FALSE #>  6 8        c     c           48      3  131.        -4 M3        <NA>  FALSE #>  7 8        a,    a           57      2  110.        -3 m3        <NA>  FALSE #>  8 8        g#,   g#          56      2  104.        -1 m2        <NA>  FALSE #>  9 8        a     a           57      3  220         13 m9        <NA>  FALSE #> 10 8        ac'e' ace         57      3  220          0 P1        <NA>  FALSE #> # ℹ 4 more variables: bend <lgl>, dotted <int>, articulation <chr>, #> #   annotation <chr>"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"noteworthy-strings","dir":"","previous_headings":"","what":"Noteworthy strings","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"helpful deeper understanding music notation syntax informs data structures operations integrated throughout package. quick introduction get oriented music notation syntax offered tabr, consider concept noteworthy string. like character string, except makes string noteworthy content consists strictly valid tabr music notation syntax. can parsed unambiguously meaningfully input package functions inspect manipulate musical information.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"a-bit-about-basic-syntax","dir":"","previous_headings":"Noteworthy strings","what":"A bit about basic syntax","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"simple character string like \"c e g\", alternatively vector, c(\"c\", \"e\", \"g\"), noteworthy string. single lowercase letter \"\" noteworthy. \"a_\" \"#\" (flat sharp). However, \"\" (case sensitivity), \"z\". course, seen , valid syntax just lowercase musical note letters g sharp flat notation. important piece syntax octave. conjunction note, specifying unique pitch requires octave number, either tick format (comma single quote, c, c c') integer format (c2 c c4). Octave 3 implicit default; tick tick format explicitly adding 3 integer format unnecessary. pitches c d e f g b (default octave) notes octave middle C (c'). ’ve already seen example using music object noteworthy string can one part complete piece musical information. Tick format necessary avoid ambiguity respect temporal information two pieces information merged together. reason, tick format preferred general. Tick format also matches used LilyPond music engraving software, used tabr LilyPond API anything transcription related like rendering sheet music PDF R markdown documents. available syntax specifications related details see package vignettes.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"the-noteworthy-class","dir":"","previous_headings":"Noteworthy strings","what":"The noteworthy class","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Noteworthiness can checked character string. defining noteworthy strings can define like character vector. However, notice package functions operate noteworthy strings whose output another noteworthy string yield string supplemental noteworthy class. print() summary() methods. Several generic methods also implemented noteworthy class, making easy perform simple powerful operations objects familiar way. many functions attempt coerce string noteworthy, methods implemented specifically class. just examples. many functions tabr intuitively operate noteworthy strings, abstracting interpretation relatively simple symbolic text specifications quantitative /structured musical information. also noteinfo class, music class (seen ). can learn vignettes. music class particularly useful efficient music data entry basic transcription tasks.","code":"x <- \"g#, c d# g#c'd#'\" as_noteworthy(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g#, c d# <g#c'd#'>  is_note(x) #> [1]  TRUE  TRUE  TRUE FALSE is_chord(x) #> [1] FALSE FALSE FALSE  TRUE chord_is_major(x) #> [1]   NA   NA   NA TRUE (x <- transpose(x, 1)) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c# e <ac#'e'>  summary(x) #> <Noteworthy string> #>   Timesteps: 4 (3 notes, 1 chord) #>   Octaves: tick #>   Accidentals: sharp #>   Format: space-delimited time #>   Values: a, c# e <ac#'e'>  distinct_pitches(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c# e a c#' e' distinct_pitches(x) |> pitch_freq() # in Hz #> [1] 110.0000 138.5913 164.8138 220.0000 277.1826 329.6276"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"tidy-music-analysis","dir":"","previous_headings":"","what":"Tidy music analysis","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Ideally music data already exists data frame format. doesn’t, just wrote new note sequence like , getting data data frame tidy approach analysis easy. Conversion can also populate several derivative variables process. earlier example saw result calling as_music_df() noteworthy string. may noticed rests (r) allowed timesteps functions compute lagged intervals respect gaps. Since as_music_df() provided string pitches, explicit time variables data frame. However, discrete timesteps still exist contain notes. number derivative columns. working large sequence music, need carry variables along analysis need . can created using various package functions can build onto data frame transform variables later function like mutate() dplyr. fact, ’s much powerful create columns according needs using specific functions various arguments. as_music_df() convenient also offers additional arguments. Adding key scale allows scale degrees. scale diatonic default . tabr offers many functions manipulating analyzing music data working music notation. See collection vignettes information music programming analysis.","code":"x <- \"a, c e r r c a, g#, a ac'e'\" as_music_df(x) library(dplyr) x <- \"a, c e r r c a, g#, a ac'e'\" tibble(pitch = as_vector_time(x)) |>    mutate(scale_int = scale_diff(pitch)) #> # A tibble: 10 × 2 #>    pitch      scale_int #>    <notwrthy> <chr>     #>  1 a,         <NA>      #>  2 c          m3        #>  3 e          M3        #>  4 r          <NA>      #>  5 r          <NA>      #>  6 c          M3        #>  7 a,         m3        #>  8 g#,        m2        #>  9 a          m9        #> 10 ac'e'      P1 x <- \"g g#\" as_music_df(x, key = \"am\") |>    select(pitch, key, scale, scale_deg) #> # A tibble: 2 × 4 #>   pitch key   scale    scale_deg #>   <chr> <chr> <chr>        <int> #> 1 g     am    diatonic         7 #> 2 g#    am    diatonic        NA  as_music_df(x, key = \"am\", scale = \"harmonic_minor\") |>    select(pitch, key, scale, scale_deg) #> # A tibble: 2 × 4 #>   pitch key   scale          scale_deg #>   <chr> <chr> <chr>              <int> #> 1 g     am    harmonic_minor        NA #> 2 g#    am    harmonic_minor         7"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"transcription","dir":"","previous_headings":"","what":"Transcription","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Music programming notation syntax provided tabr can used variety purposes, also integrates cohesively package’s transcription functions. package also provides API wrapper functions transcribing music notation R basic sheet music guitar tablature (“tabs”) using LilyPond. LilyPond open source music engraving program generating high quality sheet music based markup syntax. tabr generates LilyPond files R code can pass LilyPond rendered sheet music pdf files. LilyPond caters sheet music general tabr can used create basic sheet music, transcription functions focus leveraging LilyPond specifically creating quality guitar tablature. need use guitar tablature, vocal instrument tracks, can change settings, suppressing tab staff sheet music. LilyPond listed system requirement tabr, can use package music analysis without installing LilyPond intend render tabs. can even use lilypond() function write LilyPond files disk without software installed, since case R writing plain text files proper format. functions package require LilyPond installation tab(), midily(), miditab() render_* functions.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"use-case-considerations","dir":"","previous_headings":"Transcription","what":"Use case considerations","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"tabr offers useful limited LilyPond API intended access LilyPond functionality R, transcription via API entire scope tabr. creating sheet music case case basis, write LilyPond files manually. need use tabr limit existing LilyPond API guitar tablature focus. However, generating music notation programmatically, tabr provides ability R offers added benefit converting write R code LilyPond file format rendered printable sheet music. ongoing development, music programming side tabr continue grow much transcription functionality. transcription represents half introduction, provide thorough context overview features. Transcription wonderful option fully integrated package, optional use case, working music data broader primary thrust package.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"why-lilypond-for-transcription","dir":"","previous_headings":"Transcription","what":"Why LilyPond for transcription?","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"LilyPond exceptional sheet music engraving program. produces professional, high quality output. open source. offers command line access point programmatic approach music notation. developed utilized large community. GUI-based applications WYSIWYG force greater limitation can look like . better tabr bottleneck transcription limitations rather music engraving software wraps around.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"transcription-functionality-and-support","dir":"","previous_headings":"Transcription","what":"Transcription functionality and support","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"tabr package offers following transcription: Render guitar tablature sheet music pdf png. Create insert sheet music snippets directly R Markdown documents. Write accompanying MIDI files can respect repeat notation transposition sheet music (reasonable conditions). Support tablature string instruments besides guitar bass banjo. Support instruments different numbers strings. Support arbitrary instrument tuning. Offers inclusion (exclusion) formal music staves tab staves, treble bass clef staves complete rhythm timing information. music staff included, tab staff can suppressed, e.g., vocal tracks. Track-specific setup features like instrument type, tuning supplemental music staves. Provides common notation slide, bend, hammer , pull , slur, tie, staccato, dotted notes, visible silent rests. Allows arbitrary tuplet structure. -staff text annotation. Percent volta repeat section notation. Note transposition. Staff transposition. Multiple voices per track multiple tracks per score. Chord symbols staff Chord fretboard diagrams chord chart top score. variety layout control options covering settings score attributions font size. Optional alternative input format allowing user provide string/fret combinations (along key signature instrument tuning) map pitch.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"basic-transcription-example","dir":"","previous_headings":"","what":"Basic transcription example","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Rendering sheet music based building pieces musical information culminating score. fundamental object consider transcription context phrase. phrase created noteworthy string incorporates additional information, importantly time rhythm. can also include positional information instrument string note played. Outside rendering tabs, reason construct phrase objects. Everything phrase object using R LilyPond pipeline render kind sheet music document. music analysis noteworthy strings combining note, pitch chord information time, can done corresponding variable; using phrase object way phrase objects intended construction LilyPond markup syntax. brief example, recreate tablature shown image . steps. Define musical phrase phrase() shorthand alias p(). Add phrase track(). Add track score(). Render score pdf tab() another render_* function. code shown , first context.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"constructing-a-musical-phrase","dir":"","previous_headings":"Basic transcription example","what":"Constructing a musical phrase","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"term phrase simply means arbitrary piece musical structure string together. phrase() takes three main arguments building phrase component parts. first gives pitches (rests) separated time spaces. chords, remove spaces indicate simultaneous notes. example, rest followed sequence pitches might notes = \"r , c f d f\". info note metadata duration. Whole notes given 1, half notes 2, quarter notes 4, , e.g., info = \"4 8 8 8 8 8 8\" (shorten info = \"4 8*6\"). example require additional information dotted notes, staccato notes, ties/slurs, slides, bends, hammer ons pull offs, etc. third argument, string applies fretted string instruments always optional. Providing information conjunction pitch fixes frets LilyPond guess . applies tablature output. Explicit string numbers needed example since lowest fret numbers (LilyPond default) intended. Building phrase component parts may necessary programmatic contexts. However, manual data entry simple, interactive examples, music class offers higher level abstraction, sparing typing well cognitive load.","code":"p(\"r a, c f d a f\", \"4 8*6\") #> <Musical phrase> #> r4 <a,>8 <c>8 <f>8 <d>8 <a>8 <f>8"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"music-syntax","dir":"","previous_headings":"Basic transcription example","what":"Music syntax","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"aside, working music class, can enter notes, note info, optionally string numbers applicable, one string. efficient data entry. can also easier follow binds otherwise separate arguments timestep. See vignettes help documentation music objects details. define music object can passed directly phrase(), understands syntax interprets notes argument music syntax info argument provided (info = NULL). fact, music object even need previously defined. string format can directly provided phrase(). Notice timestep complete within single character string . Also, durations (string numbers) can repeat implicitly explicit change occurs.","code":"as_music(\"r4 a,8 c f d a f\") #> <Music string> #>   Format: space-delimited time #>   Values: r4 a,8 c8 f8 d8 a8 f8 (p1 <- p(\"r4 a,8 c f d a f\")) #> <Musical phrase> #> r4 <a,>8 <c>8 <f>8 <d>8 <a>8 <f>8"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"score-metadata-and-accessing-lilypond","dir":"","previous_headings":"Basic transcription example","what":"Score metadata and accessing LilyPond","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"Finally, specify score metadata: key signature, time signature tempo. LilyPond installed system (added system path variable Windows systems), tab() render_* functions call successfully. Windows users recommended just add LilyPond’s bin directory system path. take care LilyPond well bundled Python MIDI support. example Windows users, example LilyPond executable C:/lilypond-2.24.2/bin/lilypond.exe, add C:/lilypond-2.24.2/bin system path.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"minimal-r-code-example","dir":"","previous_headings":"Basic transcription example","what":"Minimal R code example","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"pdf output looks like :","code":"p1 |> track() |> score() |>   tab(\"phrase.pdf\", key = \"dm\", time = \"4/4\", tempo = \"4 = 120\") #> #### Engraving score to phrase.pdf #### #> GNU LilyPond 2.24.2 (running Guile 2.2) #> Processing `./phrase.ly' #> Parsing... #> Interpreting music... #> Preprocessing graphical objects... #> Interpreting music... #> MIDI output to `./phrase.mid'... #> Finding the ideal number of pages... #> Fitting music on 1 page... #> Drawing systems... #> Converting to `./phrase.pdf'... #> Success: compilation successfully completed"},{"path":"https://leonawicz.github.io/tabr/index.html","id":"midi-support","dir":"","previous_headings":"","what":"MIDI support","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"package offers nominal MIDI file output support conjunction rendering sheet music. MIDI file writing still handled LilyPond, means must based valid LilyPond file output created tabr. can read MIDI files R. support relies tuneR package read MIDI files attempts structure MIDI data integrate best possible data structures functionality found throughout tabr. existing MIDI file can also passed directly LilyPond attempt create sheet music MIDI file possible, using one LilyPond’s command line utilities MIDI LilyPond conversion followed rendering generated LilyPond file sheet music.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"references-and-resources","dir":"","previous_headings":"","what":"References and resources","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"several vignette tutorials examples tabr website.  See R-Music organization GitHub R packages related music data extraction analysis. R-Music blog provides package introductions examples.","code":""},{"path":"https://leonawicz.github.io/tabr/index.html","id":"other-packages","dir":"","previous_headings":"References and resources","what":"Other packages","title":"Music Notation Syntax, Manipulation, Analysis and Transcription in R","text":"tuneR package Analysis Music Speech Uwe Ligges, Sebastian Krey, Olaf Mersmann, Sarah Schnackenberg, others. Please note tabr project released Contributor Code Conduct. contributing project, agree abide terms.","code":""},{"path":"https://leonawicz.github.io/tabr/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2018-2019 Matthew Leonawicz Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/append_phrases.html","id":null,"dir":"Reference","previous_headings":"","what":"Concatenate and repeat — append_phrases","title":"Concatenate and repeat — append_phrases","text":"Helper functions concatenating musical phrases raw strings together well repetition.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/append_phrases.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concatenate and repeat — append_phrases","text":"","code":"pc(...)  pn(x, n = 1)"},{"path":"https://leonawicz.github.io/tabr/reference/append_phrases.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concatenate and repeat — append_phrases","text":"... character, phrase non-phrase string. x character, phrase non-phrase string. n integer, number repetitions.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/append_phrases.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Concatenate and repeat — append_phrases","text":"phrase non-phrase character string, noteworthy string applicable.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/append_phrases.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Concatenate and repeat — append_phrases","text":"Note: working special tabr classes, can simply use generics like c() rep() many custom methods exist classes. additional respective helper functions, pc() pn(), specifically phrase objects still working character strings, yet converted phrase object (numbers yet string form allowed). See examples. functions pc() pn() based base functions paste() rep(), respectively, tailored efficiency creating musical phrases. functions respect retain phrase class applied phrases. aggressive phrases secondarily noteworthy strings. Combining phrase non-phrase string assume compatibility result new phrase object. phrase objects present, presence noteworthy string turn attempt force conversion strings noteworthy strings. aggressiveness provides convenience, counter expected coercion rules. user ensure inputs can forced specific child class. especially useful repeated instances. function applies general slur notation well. Multiple input formats allowed. Total number note durations must even slurs require start stop points.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/append_phrases.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Concatenate and repeat — append_phrases","text":"","code":"pc(8, \"16-\", \"8^\") #> [1] \"8 16- 8^\" pn(1, 2) #> [1] \"1 1\" x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 432 432\") y <- phrase(\"a\", 1, 5) pc(x, y) #> <Musical phrase> #> <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 <a\\5>1 pc(x, pn(y, 2)) #> <Musical phrase> #> <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 <a\\5>1 <a\\5>1 pc(x, \"r1\") # add a simple rest instance #> <Musical phrase> #> <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 r1 class(pc(x, y)) #> [1] \"phrase\"    \"character\" class(pn(y, 2)) #> [1] \"phrase\"    \"character\" class(pc(x, \"r1\")) #> [1] \"phrase\"    \"character\" class(pn(\"r1\", 2)) #> [1] \"character\" class(pc(\"r1\", \"r4\")) #> [1] \"character\""},{"path":"https://leonawicz.github.io/tabr/reference/articulations.html","id":null,"dir":"Reference","previous_headings":"","what":"Single note articulations and syntax — articulations","title":"Single note articulations and syntax — articulations","text":"data frame containing categorized sets articulations can used phrase construction.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/articulations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single note articulations and syntax — articulations","text":"","code":"articulations"},{"path":"https://leonawicz.github.io/tabr/reference/articulations.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Single note articulations and syntax — articulations","text":"data frame 3 column 44 rows.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/as_music_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Noteworthy string to data frame — as_music_df","title":"Noteworthy string to data frame — as_music_df","text":"Convert noteworthy string tibble data frame include additional derivative variables.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/as_music_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noteworthy string to data frame — as_music_df","text":"","code":"as_music_df(   notes,   info = NULL,   key = NULL,   scale = \"diatonic\",   chords = c(\"root\", \"list\", \"character\"),   si_format = c(\"mmp_abb\", \"mmp\", \"ad_abb\", \"ad\") )"},{"path":"https://leonawicz.github.io/tabr/reference/as_music_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noteworthy string to data frame — as_music_df","text":"notes character, noteworthy string. Alternatively, music object phrase object, case info ignored. info NULL character, note info string. key character, key signature, required inclusion scale degrees. scale character, defaults \"diatonic\". used conjunction key, can used alter scale degrees. arbitrary combination valid key valid scale valid. See scale_degree(). chords character, structure columns containing multiple values per chord/row data frame. See details. si_format character, format scale intervals. See scale_interval().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/as_music_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noteworthy string to data frame — as_music_df","text":"tibble data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/as_music_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Noteworthy string to data frame — as_music_df","text":"info provided notes phrase object, resulting data frame also contains note durations info variables. duration column always included output even vector NAs info = NULL. makes explicit given music data frame generated without time information timesteps. note info columns included case. derived column variables root note (lowest pitch) chord used. done pitch intervals scale intervals adjacent timesteps. also occurs scale degrees. chord = \"root\" additionally collapses columns like semitone, octave, frequency value root note rows contain one numeric value. chord = \"list\" retains full information list columns. chord = \"character\" collapses strings values readily visible printing table, information stripped can recovered without recomputing original pitches.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/as_music_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noteworthy string to data frame — as_music_df","text":"","code":"x <- \"a, b, c d e f g# a r ac'e' a c' e' c' r r r a\" as_music_df(x, key = \"c\", scale = \"major\") #> # A tibble: 18 × 11 #>    duration pitch note  semitone octave  freq key   scale scale_deg pitch_int #>    <chr>    <chr> <chr>    <int>  <int> <dbl> <chr> <chr>     <int>     <int> #>  1 NA       a,    a           57      2  110. c     major         6        NA #>  2 NA       b,    b           59      2  123. c     major         7         2 #>  3 NA       c     c           48      3  131. c     major         1         1 #>  4 NA       d     d           50      3  147. c     major         2         2 #>  5 NA       e     e           52      3  165. c     major         3         2 #>  6 NA       f     f           53      3  175. c     major         4         1 #>  7 NA       g#    g#          56      3  208. c     major        NA         3 #>  8 NA       a     a           57      3  220  c     major         6         1 #>  9 NA       r     r           NA     NA   NA  c     major        NA        NA #> 10 NA       ac'e' ace         57      3  220  c     major         1         0 #> 11 NA       a     a           57      3  220  c     major         6         0 #> 12 NA       c'    c           48      4  262. c     major         1         3 #> 13 NA       e'    e           52      4  330. c     major         3         4 #> 14 NA       c'    c           48      4  262. c     major         1        -4 #> 15 NA       r     r           NA     NA   NA  c     major        NA        NA #> 16 NA       r     r           NA     NA   NA  c     major        NA        NA #> 17 NA       r     r           NA     NA   NA  c     major        NA        NA #> 18 NA       a     a           57      3  220  c     major         6        -3 #> # ℹ 1 more variable: scale_int <chr> as_music_df(x, key = \"am\", scale = \"harmonic_minor\", si_format = \"ad_abb\") #> # A tibble: 18 × 11 #>    duration pitch note  semitone octave  freq key   scale    scale_deg pitch_int #>    <chr>    <chr> <chr>    <int>  <int> <dbl> <chr> <chr>        <int>     <int> #>  1 NA       a,    a           57      2  110. am    harmoni…         1        NA #>  2 NA       b,    b           59      2  123. am    harmoni…         2         2 #>  3 NA       c     c           48      3  131. am    harmoni…         3         1 #>  4 NA       d     d           50      3  147. am    harmoni…         4         2 #>  5 NA       e     e           52      3  165. am    harmoni…         5         2 #>  6 NA       f     f           53      3  175. am    harmoni…         6         1 #>  7 NA       g#    g#          56      3  208. am    harmoni…         7         3 #>  8 NA       a     a           57      3  220  am    harmoni…         1         1 #>  9 NA       r     r           NA     NA   NA  am    harmoni…        NA        NA #> 10 NA       ac'e' ace         57      3  220  am    harmoni…         3         0 #> 11 NA       a     a           57      3  220  am    harmoni…         1         0 #> 12 NA       c'    c           48      4  262. am    harmoni…         3         3 #> 13 NA       e'    e           52      4  330. am    harmoni…         5         4 #> 14 NA       c'    c           48      4  262. am    harmoni…         3        -4 #> 15 NA       r     r           NA     NA   NA  am    harmoni…        NA        NA #> 16 NA       r     r           NA     NA   NA  am    harmoni…        NA        NA #> 17 NA       r     r           NA     NA   NA  am    harmoni…        NA        NA #> 18 NA       a     a           57      3  220  am    harmoni…         1        -3 #> # ℹ 1 more variable: scale_int <chr>  a <- notate(\"8\", \"Start here.\") time <- paste(a, \"8^*2 16-_ 4.. 16( 16)( 2) 2 4. t8- t8 t8- 8[accent]*4 1\") d1 <- as_music_df(x, time) d1 #> # A tibble: 18 × 14 #>    duration pitch note  semitone octave  freq pitch_int scale_int slur  slide #>    <chr>    <chr> <chr>    <int>  <int> <dbl>     <int> <chr>     <chr> <lgl> #>  1 8        a,    a           57      2  110.        NA NA        NA    FALSE #>  2 8        b,    b           59      2  123.         2 M2        NA    FALSE #>  3 8        c     c           48      3  131.         1 m2        NA    FALSE #>  4 16       d     d           50      3  147.         2 M2        NA    FALSE #>  5 4..      e     e           52      3  165.         2 M2        NA    FALSE #>  6 16       f     f           53      3  175.         1 m2        on    FALSE #>  7 16       g#    g#          56      3  208.         3 m3        hold  FALSE #>  8 2        a     a           57      3  220          1 m2        off   FALSE #>  9 2        r     r           NA     NA   NA         NA NA        NA    FALSE #> 10 4.       ac'e' ace         57      3  220          0 P1        NA    FALSE #> 11 t8       a     a           57      3  220          0 P1        NA    TRUE  #> 12 t8       c'    c           48      4  262.         3 m3        NA    FALSE #> 13 t8       e'    e           52      4  330.         4 M3        NA    TRUE  #> 14 8        c'    c           48      4  262.        -4 M3        NA    FALSE #> 15 8        r     r           NA     NA   NA         NA NA        NA    FALSE #> 16 8        r     r           NA     NA   NA         NA NA        NA    FALSE #> 17 8        r     r           NA     NA   NA         NA NA        NA    FALSE #> 18 1        a     a           57      3  220         -3 m3        NA    FALSE #> # ℹ 4 more variables: bend <lgl>, dotted <int>, articulation <chr>, #> #   annotation <chr>  # Go directly from music object to data frame m1 <- as_music(x, time) d2 <- as_music_df(m1) identical(d1, d2) #> [1] TRUE  # Go directly from phrase object to data frame p1 <- phrase(\"a b cgc'\", \"4-+ 4[accent] 2\", 5) identical(as_music_df(as_music(\"a4-+;5 b[accent] cgc'2\")), as_music_df(p1)) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/chord-compare.html","id":null,"dir":"Reference","previous_headings":"","what":"Rank, order and sort chords and notes — chord-compare","title":"Rank, order and sort chords and notes — chord-compare","text":"Rank, order sort chords notes various definitions.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-compare.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rank, order and sort chords and notes — chord-compare","text":"","code":"chord_rank(notes, pitch = c(\"min\", \"mean\", \"max\"), ...)  chord_order(notes, pitch = c(\"min\", \"mean\", \"max\"), ...)  chord_sort(notes, pitch = c(\"min\", \"mean\", \"max\"), decreasing = FALSE, ...)"},{"path":"https://leonawicz.github.io/tabr/reference/chord-compare.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Rank, order and sort chords and notes — chord-compare","text":"notes character, noteworthy string. pitch character, ranking chords determined; lowest pitch, mean pitch, highest pitch. ... additional arguments passed rank() order(). decreasing logical, sort decreasing order.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-compare.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rank, order and sort chords and notes — chord-compare","text":"integer rank order, character sort","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-compare.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Rank, order and sort chords and notes — chord-compare","text":"three options comparing relative pitch position chords provided: comparison lowest root note chord, highest pitch note, taking mean notes chord.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-compare.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Rank, order and sort chords and notes — chord-compare","text":"","code":"x <- \"a2 c a2 ceg ce_g cea\" chord_rank(x, \"min\") #> [1] 1.5 4.5 1.5 4.5 4.5 4.5 chord_rank(x, \"max\") #> [1] 1.5 3.0 1.5 4.5 4.5 6.0 chord_rank(x, \"mean\") #> [1] 1.5 3.0 1.5 5.0 4.0 6.0  chord_order(x) #> [1] 1 3 2 4 5 6 chord_order(x, \"mean\") #> [1] 1 3 2 5 4 6 chord_sort(x, \"mean\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a2 a2 c <ce_g> <ceg> <cea>"},{"path":"https://leonawicz.github.io/tabr/reference/chord-filter.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract notes from chords — chord-filter","title":"Extract notes from chords — chord-filter","text":"Filter slice chords extract individual notes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-filter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract notes from chords — chord-filter","text":"","code":"chord_root(notes)  chord_top(notes)  chord_slice(notes, index)"},{"path":"https://leonawicz.github.io/tabr/reference/chord-filter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract notes from chords — chord-filter","text":"notes character, noteworthy string. index integer, order note chord pitch (scale degrees).","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-filter.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract notes from chords — chord-filter","text":"noteworthy string","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-filter.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract notes from chords — chord-filter","text":"functions extract notes chords root note, highest pitch, specific position among notes pitch, trim chords simplify . operate based ordered pitches. chord_slice(), entry empty slicing dropped. error thrown index completely bounds chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-filter.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract notes from chords — chord-filter","text":"","code":"x <- \"a_2 c#eg# e_gc egc,cc'\" chord_root(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_, d_ c c, chord_top(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_, a_ g c' identical(chord_slice(x, 1), chord_root(x)) #> [1] TRUE chord_slice(x, 2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e e_ c chord_slice(x, 4) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g chord_slice(x, 3:5) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g# g <egc'>"},{"path":"https://leonawicz.github.io/tabr/reference/chord-mapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Chord mapping — chord-mapping","title":"Chord mapping — chord-mapping","text":"Helper functions chord mapping.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-mapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chord mapping — chord-mapping","text":"","code":"gc_info(   name,   root_octave = NULL,   root_fret = NULL,   min_fret = NULL,   bass_string = NULL,   open = NULL,   key = \"c\",   ignore_octave = TRUE )  gc_fretboard(   name,   root_octave = NULL,   root_fret = NULL,   min_fret = NULL,   bass_string = NULL,   open = NULL,   key = \"c\",   ignore_octave = TRUE )  gc_notes_to_fb(   notes,   root_octave = NULL,   root_fret = NULL,   min_fret = NULL,   bass_string = NULL,   open = NULL )  gc_notes(   name,   root_octave = NULL,   root_fret = NULL,   min_fret = NULL,   bass_string = NULL,   open = NULL,   key = \"c\",   ignore_octave = TRUE )  gc_is_known(notes)  gc_name_split(name)  gc_name_root(name)  gc_name_mod(name)"},{"path":"https://leonawicz.github.io/tabr/reference/chord-mapping.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chord mapping — chord-mapping","text":"name character, chord name tabr format, e.g., \"bM b_m b_m7#5\", etc. root_octave integer, optional filter chords whose root note set octave numbers. May vector. root_fret integer, optional filter chords whose root note matches specific fret. May vector. min_fret integer, optional filter chords whose notes specific fret. May vector. bass_string integer, optional filter chords whose lowest pitch string matches specific string, 6, 5, 4. May vector. open logical, optional filter open movable chords. NULL retains types. key character, key signature, used enforce type accidentals. ignore_octave logical, TRUE, functions like gc_info() gc_fretboard() return results. notes character, noteworthy string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-mapping.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chord mapping — chord-mapping","text":"various, see details regarding function.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-mapping.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chord mapping — chord-mapping","text":"functions assist mapping different information define chords. gc_is_known(), check done chords guitarChords dataset. simple noteworthy string permitted, single-note entry automatically yield FALSE result. gc_info() returns tibble data frame containing complete information subset predefined guitar chords specified name key. accidentals present chord root name (chord modifier, e.g., m7_5 m7#5) converted according key necessary. gc_notes() gc_fretboard() wrappers around gc_info(), return noteworthy strings chord notes named vector LilyPond fretboard diagram data, respectively. Note although input functions can contain multiple chord names, whether vector single space-delimited string, result intended equal length. functions filter guitarChords. result set chords matched supplied input filters. gc_name_split() splits vector space-delimited set chord names tibble data frame containing separate chord root chord modifier columns. gc_name_root() gc_name_mod() wrappers around .","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord-mapping.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chord mapping — chord-mapping","text":"","code":"gc_is_known(\"a b_,fb_d'f'\") #> [1] FALSE  TRUE  gc_name_root(\"a aM b_,m7#5\") #> [1] \"a\"   \"a\"   \"b_,\" gc_name_mod(\"a aM b_,m7#5\") #> [1] \"M\"    \"M\"    \"m7#5\"  gc_info(\"a\") # a major chord, not a single note #> # A tibble: 6 × 12 #>   id    lp_name root  octave root_fret min_fret bass_string notes        frets   #>   <fct> <chr>   <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>        <chr>   #> 1 M     a,:5    a          2         0        0           5 a,ead_'e'    xo222o  #> 2 M     a,:5    a          2         5        5           6 a,ead_'e'a'  577655  #> 3 M     a,:5    a          2         5        2           6 a,d_ead_'a'  542225  #> 4 M     a:5     a          3         7        7           4 ae'a'd_''    xx79(1… #> 5 M     a:5     a          3        12       12           5 ae'a'd_''e'' x(12)(… #> 6 M     a:5     a          3        12        9           5 ad_'e'a'd_'' x(12)(… #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl> gc_info(\"ceg a#m7_5\") # only second entry is a guitar chord #> # A tibble: 6 × 12 #>   id    lp_name  root  octave root_fret min_fret bass_string notes        frets  #>   <fct> <chr>    <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>        <chr>  #> 1 m7_5  b_,:m7_5 b_         2         1        0           5 b_,a_d_'e'   x1x12o #> 2 m7_5  b_,:m7_5 b_         2         1        1           5 b_,ea_d_'    x1212x #> 3 m7_5  b_,:m7_5 b_         2         6        5           6 b_,a_d_'e'   6x665x #> 4 m7_5  b_:m7_5  b_         3         8        4           4 b_d_'e'a_'   xx8654 #> 5 m7_5  b_:m7_5  b_         3         8        8           4 b_e'a_'d_''  xx8999 #> 6 m7_5  b_:m7_5  b_         3        13       12           5 b_a_'d_''e'' x(13)… #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl> gc_info(\"ceg a#m7_5\", key = \"f\") #> # A tibble: 6 × 12 #>   id    lp_name  root  octave root_fret min_fret bass_string notes        frets  #>   <fct> <chr>    <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>        <chr>  #> 1 m7_5  b_,:m7_5 b_         2         1        0           5 b_,a_d_'e'   x1x12o #> 2 m7_5  b_,:m7_5 b_         2         1        1           5 b_,ea_d_'    x1212x #> 3 m7_5  b_,:m7_5 b_         2         6        5           6 b_,a_d_'e'   6x665x #> 4 m7_5  b_:m7_5  b_         3         8        4           4 b_d_'e'a_'   xx8654 #> 5 m7_5  b_:m7_5  b_         3         8        8           4 b_e'a_'d_''  xx8999 #> 6 m7_5  b_:m7_5  b_         3        13       12           5 b_a_'d_''e'' x(13)… #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl>  gc_info(\"a,m c d f,\") #> # A tibble: 23 × 12 #>    id    lp_name root  octave root_fret min_fret bass_string notes       frets   #>    <fct> <chr>   <chr>  <dbl>     <dbl>    <dbl>       <int> <chr>       <chr>   #>  1 m     a,:m    a          2         0        0           5 a,eac'e'    xo221o  #>  2 m     a,:m    a          2         5        5           6 a,eac'e'a'  577555  #>  3 m     a,:m    a          2         5        2           6 a,cea       5322xx  #>  4 m     a:m     a          3         7        7           4 ae'a'c''    xx79(1… #>  5 m     a:m     a          3        12       12           5 ae'a'c''e'' x(12)(… #>  6 m     a:m     a          3        12        9           5 ac'e'a'     x(12)(… #>  7 M     c:5     c          3         3        3           5 cgc'e'g'    x35553  #>  8 M     c:5     c          3         3        0           5 cegc'e'     x32o1o  #>  9 M     c:5     c          3         8        8           6 cgc'e'g'c'' 8(10)(… #> 10 M     c:5     c          3         8        5           6 cegc'e'c''  875558  #> # ℹ 13 more rows #> # ℹ 3 more variables: semitones <list>, fretboard <chr>, open <lgl> gc_fretboard(\"a,m c d f,\", root_fret = 0:3) #>           a,:m            c:5            c:5            d:5           f,:5  #> \"x;o;2;2;1;o;\" \"x;3;5;5;5;3;\" \"x;3;2;o;1;o;\" \"x;x;o;2;3;2;\" \"1;3;3;2;1;1;\"  #>            f:5  #> \"x;x;3;5;6;5;\"  gc_notes_to_fb(\"a,eac'e' cgc'e'g'\") #>           a,:m            c:5  #> \"x;o;2;2;1;o;\" \"x;3;5;5;5;3;\"   x <- gc_notes(\"a, b,\", root_fret = 0:2) summary(x) #> <Noteworthy string> #>   Timesteps: 2 (0 notes, 2 chords) #>   Octaves: tick #>   Accidentals: flat #>   Format: space-delimited time #>   Values: <a,ead_'e'> <b,g_be_'g_'>"},{"path":"https://leonawicz.github.io/tabr/reference/chords.html","id":null,"dir":"Reference","previous_headings":"","what":"Chord constructors — chords","title":"Chord constructors — chords","text":"functions construct basic chord string notation root notes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chord constructors — chords","text":"","code":"chord_min(notes, key = \"c\", octaves = \"tick\")  chord_maj(notes, key = \"c\", octaves = \"tick\")  chord_min7(notes, key = \"c\", octaves = \"tick\")  chord_dom7(notes, key = \"c\", octaves = \"tick\")  chord_7s5(notes, key = \"c\", octaves = \"tick\")  chord_maj7(notes, key = \"c\", octaves = \"tick\")  chord_min6(notes, key = \"c\", octaves = \"tick\")  chord_maj6(notes, key = \"c\", octaves = \"tick\")  chord_dim(notes, key = \"c\", octaves = \"tick\")  chord_dim7(notes, key = \"c\", octaves = \"tick\")  chord_m7b5(notes, key = \"c\", octaves = \"tick\")  chord_aug(notes, key = \"c\", octaves = \"tick\")  chord_5(notes, key = \"c\", octaves = \"tick\")  chord_sus2(notes, key = \"c\", octaves = \"tick\")  chord_sus4(notes, key = \"c\", octaves = \"tick\")  chord_dom9(notes, key = \"c\", octaves = \"tick\")  chord_7s9(notes, key = \"c\", octaves = \"tick\")  chord_maj9(notes, key = \"c\", octaves = \"tick\")  chord_add9(notes, key = \"c\", octaves = \"tick\")  chord_min9(notes, key = \"c\", octaves = \"tick\")  chord_madd9(notes, key = \"c\", octaves = \"tick\")  chord_min11(notes, key = \"c\", octaves = \"tick\")  chord_7s11(notes, key = \"c\", octaves = \"tick\")  chord_maj7s11(notes, key = \"c\", octaves = \"tick\")  chord_11(notes, key = \"c\", octaves = \"tick\")  chord_maj11(notes, key = \"c\", octaves = \"tick\")  chord_13(notes, key = \"c\", octaves = \"tick\")  chord_min13(notes, key = \"c\", octaves = \"tick\")  chord_maj13(notes, key = \"c\", octaves = \"tick\")  xm(notes, key = \"c\", octaves = \"tick\")  xM(notes, key = \"c\", octaves = \"tick\")  xm7(notes, key = \"c\", octaves = \"tick\")  x7(notes, key = \"c\", octaves = \"tick\")  x7s5(notes, key = \"c\", octaves = \"tick\")  xM7(notes, key = \"c\", octaves = \"tick\")  xm6(notes, key = \"c\", octaves = \"tick\")  xM6(notes, key = \"c\", octaves = \"tick\")  xdim(notes, key = \"c\", octaves = \"tick\")  xdim7(notes, key = \"c\", octaves = \"tick\")  xm7b5(notes, key = \"c\", octaves = \"tick\")  xaug(notes, key = \"c\", octaves = \"tick\")  x5(notes, key = \"c\", octaves = \"tick\")  xs2(notes, key = \"c\", octaves = \"tick\")  xs4(notes, key = \"c\", octaves = \"tick\")  x9(notes, key = \"c\", octaves = \"tick\")  x7s9(notes, key = \"c\", octaves = \"tick\")  xM9(notes, key = \"c\", octaves = \"tick\")  xadd9(notes, key = \"c\", octaves = \"tick\")  xm9(notes, key = \"c\", octaves = \"tick\")  xma9(notes, key = \"c\", octaves = \"tick\")  xm11(notes, key = \"c\", octaves = \"tick\")  x7s11(notes, key = \"c\", octaves = \"tick\")  xM7s11(notes, key = \"c\", octaves = \"tick\")  x_11(notes, key = \"c\", octaves = \"tick\")  xM11(notes, key = \"c\", octaves = \"tick\")  x_13(notes, key = \"c\", octaves = \"tick\")  xm13(notes, key = \"c\", octaves = \"tick\")  xM13(notes, key = \"c\", octaves = \"tick\")"},{"path":"https://leonawicz.github.io/tabr/reference/chords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chord constructors — chords","text":"notes character, noteworthy string chord root notes. key key signature. See details. octaves character, passed transpose().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chord constructors — chords","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chords.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chord constructors — chords","text":"Providing key signature used ensure flats sharps accidentals. additional set aliases efficient names, form x* * chord modifier abbreviation, provided complement set chord_* functions. functions create standard chords, multi-octave spanning types chords commonly played guitar.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/chords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chord constructors — chords","text":"","code":"chord_min(\"d\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <dfa> chord_maj(\"d\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <dg_a> xM(\"d\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <dg_a> xm(\"c f g\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ce_g> <fa_c'> <gb_d'> xm(\"c, f, g,\", key = \"e_\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <c,e_,g,> <f,a_,c> <g,b_,d>"},{"path":"https://leonawicz.github.io/tabr/reference/chord_arpeggiate.html","id":null,"dir":"Reference","previous_headings":"","what":"Arpeggiate a chord — chord_arpeggiate","title":"Arpeggiate a chord — chord_arpeggiate","text":"Create arpeggio chord.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_arpeggiate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arpeggiate a chord — chord_arpeggiate","text":"","code":"chord_arpeggiate(   chord,   n = 0,   by = c(\"note\", \"chord\"),   broken = FALSE,   collapse = FALSE )"},{"path":"https://leonawicz.github.io/tabr/reference/chord_arpeggiate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Arpeggiate a chord — chord_arpeggiate","text":"chord character, single chord. n integer, number steps, negative indicates reverse direction (decreasing pitch). whether n steps refers individual notes chord (inversion) raising entire chord given position one octave. broken logical, return result arpeggio broken chords. collapse logical, collapse result single string ready phrase construction.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_arpeggiate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Arpeggiate a chord — chord_arpeggiate","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_arpeggiate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Arpeggiate a chord — chord_arpeggiate","text":"function based chord_invert. n = 0 chord returned immediately; arguments ignored.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_arpeggiate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arpeggiate a chord — chord_arpeggiate","text":"","code":"chord_arpeggiate(\"ce_gb_\", 2) #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce_gb_> <e_gb_c4> <gb_c4e_4> chord_arpeggiate(\"ce_gb_\", -2) #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce_gb_> <b_2ce_g> <g2b_2ce_> chord_arpeggiate(\"ce_gb_\", 2, by = \"chord\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce_gb_> <c4e_4g4b_4> <c5e_5g5b_5> chord_arpeggiate(\"ce_gb_\", 1, broken = TRUE, collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e_ g b_ e_ g b_ c4"},{"path":"https://leonawicz.github.io/tabr/reference/chord_break.html","id":null,"dir":"Reference","previous_headings":"","what":"Broken chords — chord_break","title":"Broken chords — chord_break","text":"Convert chords noteworthy string vector broken chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_break.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Broken chords — chord_break","text":"","code":"chord_break(notes)"},{"path":"https://leonawicz.github.io/tabr/reference/chord_break.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Broken chords — chord_break","text":"notes character, noteworthy string may contain chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_break.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Broken chords — chord_break","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_break.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Broken chords — chord_break","text":"","code":"chord_break(\"c e g ceg ceg\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e g c e g c e g"},{"path":"https://leonawicz.github.io/tabr/reference/chord_def.html","id":null,"dir":"Reference","previous_headings":"","what":"Define chords — chord_def","title":"Define chords — chord_def","text":"Function creating new chord definition tables.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_def.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define chords — chord_def","text":"","code":"chord_def(fret, id, optional = NA, tuning = \"standard\", ...)"},{"path":"https://leonawicz.github.io/tabr/reference/chord_def.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define chords — chord_def","text":"fret integer vector defining fretted chord. See details. id character, chord type. See details. optional NA notes required. Otherwise integer vector giving indices offret considered optional notes chord. tuning character, string tuning. See tunings predefined tunings. Custom tunings specified similar value string. ... additional arguments passed transpose().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_def.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define chords — chord_def","text":"data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_def.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Define chords — chord_def","text":"function creates tibble data frame containing information defining various attributes chords. used create guitarChords dataset, can used create pre-defined chord collections. tibble one row, providing information defined chord. user can decide arguments vectorize creating chord collection. See examples. function uses vector fret integers (NA muted string) define chord, conjunction string tuning (defaults standard tuning, six-string guitar). fret lowest highest pitch strings, e.g., strings six one. id passed directly output. represents type chord conform accepted tabr notation. See id column guitarChords examples. Note semitones column gives semitone intervals chord notes. count zero lowest pitch based tuning instrument, e.g., zero E2 standard guitar tuning. convert semitone intervals standard semitone values assigned pitches, use e.g., pitch_semitones(\"e2\") (40) lowest pitch add value instrument semitone interval values. explanation, necessary. can use chord_semitones() compute semitones directly pitches chord.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_def.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define chords — chord_def","text":"","code":"frets <- c(NA, 0, 2, 2, 1, 0) chord_def(frets, \"m\") #> # A tibble: 1 × 13 #>   id    lp_name root  octave root_fret min_fret bass_string notes    frets  #>   <chr> <chr>   <chr>  <int>     <dbl>    <dbl>       <int> <chr>    <chr>  #> 1 m     a,:m    a          2         0        0           5 a,eac'e' xo221o #> # ℹ 4 more variables: semitones <list>, optional <lgl>, fretboard <chr>, #> #   open <lgl> chord_def(frets, \"m\", 6) #> # A tibble: 1 × 13 #>   id    lp_name root  octave root_fret min_fret bass_string notes    frets  #>   <chr> <chr>   <chr>  <int>     <dbl>    <dbl>       <int> <chr>    <chr>  #> 1 m     a,:m    a          2         0        0           5 a,eac'e' xo221o #> # ℹ 4 more variables: semitones <list>, optional <chr>, fretboard <chr>, #> #   open <lgl>  purrr::map_dfr(c(0, 2, 3), ~chord_def(frets + .x, \"m\")) #> # A tibble: 3 × 13 #>   id    lp_name root  octave root_fret min_fret bass_string notes      frets  #>   <chr> <chr>   <chr>  <int>     <dbl>    <dbl>       <int> <chr>      <chr>  #> 1 m     a,:m    a          2         0        0           5 a,eac'e'   xo221o #> 2 m     b,:m    b          2         2        2           5 b,g_bd'g_' x24432 #> 3 m     c:m     c          3         3        3           5 cgc'e_'g'  x35543 #> # ℹ 4 more variables: semitones <list>, optional <lgl>, fretboard <chr>, #> #   open <lgl>"},{"path":"https://leonawicz.github.io/tabr/reference/chord_invert.html","id":null,"dir":"Reference","previous_headings":"","what":"Chord inversion — chord_invert","title":"Chord inversion — chord_invert","text":"function inverts single chord given character string. n = 0, chord returned immediately. Otherwise, notes chord inverted. abs(n) greater number inversions (excluding root position), error thrown.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_invert.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chord inversion — chord_invert","text":"","code":"chord_invert(chord, n = 0, limit = FALSE)"},{"path":"https://leonawicz.github.io/tabr/reference/chord_invert.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chord inversion — chord_invert","text":"chord character, single chord. n inversion. limit logical, limit inversions either direction one less number notes chord.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_invert.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chord inversion — chord_invert","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_invert.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chord inversion — chord_invert","text":"Note chord_invert() knowledge whether chord might considered root position inversion already, informed key signature, chord name user's intent. function simply inverts receives, treating defined chord string root position. Octave number applies function. Chords always defined notes increasing pitch. Remember unspecified octave number note octave 3. chord inverted, moves scale. lowest note moved top chord, increasing octave necessary, ensure note takes lowest octave number highest pitch. second lowest note becomes lowest. octave change. pattern repeated higher order inversions. opposite happens n negative. procedure ensures resulting inverted chord still defined notes increasing pitch. However, construct unusual chord spans multiple octaves, extra space condensed inversion.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_invert.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chord inversion — chord_invert","text":"","code":"chord_invert(\"ce_gb_\", 3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_c4e_4g4>"},{"path":"https://leonawicz.github.io/tabr/reference/chord_is_major.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if chords are major or minor — chord_is_major","title":"Check if chords are major or minor — chord_is_major","text":"Check chords major minor possible.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_is_major.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if chords are major or minor — chord_is_major","text":"","code":"chord_is_major(notes)  chord_is_minor(notes)"},{"path":"https://leonawicz.github.io/tabr/reference/chord_is_major.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if chords are major or minor — chord_is_major","text":"notes character, noteworthy string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_is_major.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if chords are major or minor — chord_is_major","text":"logical vector","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_is_major.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if chords are major or minor — chord_is_major","text":"functions operate based ordered pitches. recognize human might interpret name inverted chord root lowest pitch. imposes limitations utility functions, scan intervals minor major third chord whose notes sorted pitch. several cases including single notes major minor third interval present, NA returned. TRUE FALSE returned interval present. one present, based lowest pitch. prioritizes major/minor minor/major adjacent intervals (recognizing common triad). occur adjacent, lowest third selected. still imperfect, useful method. Second higher unknown chord inversions problematic.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_is_major.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if chords are major or minor — chord_is_major","text":"","code":"x <- \"c cg, ce ce_ ceg ce_gb g,ce g,ce_ e_,g,c e_,g,ce_ e_,g,c\" chord_is_major(x) #>  [1]    NA    NA  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE  TRUE  TRUE identical(chord_is_major(x), !chord_is_minor(x)) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/chord_set.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a chord set — chord_set","title":"Generate a chord set — chord_set","text":"Generate chord set music score.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_set.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a chord set — chord_set","text":"","code":"chord_set(x, id = NULL, n = 6)"},{"path":"https://leonawicz.github.io/tabr/reference/chord_set.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a chord set — chord_set","text":"x character, n-string chord description lowest highest pitch, strings n 1. E.g., \"xo221o\". can use spaces semicolons 2-digit fret numbers present, e.g., \"8 10 10 9 o\". mix formats. Leading x inferred number entries less n. id character, name chord LilyPond readable format, e.g., \":m\". Ignored x already named vector. n number instrument strings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_set.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a chord set — chord_set","text":"named list.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_set.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a chord set — chord_set","text":"chord set list returned chord_set() used top center placement full set chord fretboard diagrams music score. chord_set() returns named list. names chords list elements strings defining string fret fingering readable LilyPond. Multiple chord positions can defined chord name. Instruments number strings six currently supported. defining chords, may also wish define rests silent rests chords added score placement staff time, chord played explicitly written. Therefore, occasions may pass chord names positions happen include entries r /s NA shown example. two special cases passed chord_set() ignored chord chart generated.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/chord_set.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a chord set — chord_set","text":"","code":"chord_names <- c(\"e:m\", \"c\", \"d\", \"e:m\", \"d\", \"r\", \"s\") chord_position <- c(\"997x\", \"5553x\", \"7775x\", \"ooo22o\", \"232oxx\", NA, NA) chord_set(chord_position, chord_names) #>            e:m              c              d            e:m              d  #> \"x;x;9;9;7;x;\" \"x;5;5;5;3;x;\" \"x;7;7;7;5;x;\" \"o;o;o;2;2;o;\" \"2;3;2;o;x;x;\"  #>              r              s  #>             NA             NA"},{"path":"https://leonawicz.github.io/tabr/reference/double-bracket.html","id":null,"dir":"Reference","previous_headings":"","what":"Double bracket methods for tabr classes — double-bracket","title":"Double bracket methods for tabr classes — double-bracket","text":"Double bracket indexing assignment. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/double-bracket.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Double bracket methods for tabr classes — double-bracket","text":"","code":"# S3 method for class 'noteworthy' x[[i]]  # S3 method for class 'noteinfo' x[[i]]  # S3 method for class 'music' x[[i]]  # S3 method for class 'lyrics' x[[i]]  # S3 method for class 'noteworthy' x[[i]] <- value  # S3 method for class 'noteinfo' x[[i]] <- value  # S3 method for class 'music' x[[i]] <- value  # S3 method for class 'lyrics' x[[i]] <- value"},{"path":"https://leonawicz.github.io/tabr/reference/double-bracket.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Double bracket methods for tabr classes — double-bracket","text":"x object. index. value values assign index.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/double-bracket.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Double bracket methods for tabr classes — double-bracket","text":"","code":"# noteworthy class examples x <- as_noteworthy(\"a, b, c ce_g\") x[[3]] #> [1] \"c\" x[[2]] <- paste0(transpose(x[2], 1), \"~\") x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c~ c <ce_g>  # noteinfo class examples x <- as_noteinfo(c(\"4-\", \"t8(\", \"t8)\", \"t8x\")) x[[3]] #> [1] \"t8)\" x[[3]] <- c(\"t8]\") x #> <Note info string> #>   Format: vectorized time #>   Values: 4- t8( t8] t8x  # music class examples x <- as_music(\"c,~4 c,1 c'e_'g'4-.*2\") x[[3]] #> [1] \"c'e_'g'4-.\" x[[3]] <- \"c'e'g'8\" x #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e'g'>8 <c'e_'g'>4-."},{"path":"https://leonawicz.github.io/tabr/reference/dyad.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a dyad — dyad","title":"Construct a dyad — dyad","text":"Construct dyad given one note, interval, direction.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/dyad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a dyad — dyad","text":"","code":"dyad(   notes,   interval,   reverse = FALSE,   octaves = c(\"tick\", \"integer\"),   accidentals = c(\"flat\", \"sharp\"),   key = NULL )"},{"path":"https://leonawicz.github.io/tabr/reference/dyad.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a dyad — dyad","text":"notes character, noteworthy string, single notes , chords. Number timesteps must equal length interval. interval integer character vector; semitones interval ID, respectively. See details. reverse logical, reverse transposition direction. Useful interval character. octaves, accidentals, key See transpose().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/dyad.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a dyad — dyad","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/dyad.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct a dyad — dyad","text":"interval may specified semitones common interval name abbreviation. See examples. complete list valid interval names abbreviations see mainIntervals(). key enforces use sharps flats. function based transpose(). notes interval may vectors, must equal length. Recycling occurs one argument scalar.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/dyad.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a dyad — dyad","text":"","code":"dyad(\"a\", 4) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ad_'> x <- c(\"minor third\", \"m3\", \"augmented second\", \"A2\") dyad(\"a\", x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'> <ac'> <ac'> <ac'> dyad(\"c'\", x, reverse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ac'> <ac'> <ac'> <ac'>  x <- c(\"M3\", \"m3\", \"m3\", \"M3\", \"M3\", \"m3\", \"m3\") dyad(letters[c(3:7, 1, 2)], x) #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ce> <df> <eg> <fa> <gb> <ac'> <bd'>  x <- c(\"P1\", \"m3\", \"M3\", \"P4\", \"P5\", \"P8\", \"M9\") dyad(\"c\", x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c <ce_> <ce> <cf> <cg> <cc'> <cd'> dyad(\"c\", x, reverse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c <a,c> <a_,c> <g,c> <f,c> <c,c> <b_,,c> dyad(\"d e\", \"m3\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <df> <eg>"},{"path":"https://leonawicz.github.io/tabr/reference/freq_ratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Frequency ratios — freq_ratio","title":"Frequency ratios — freq_ratio","text":"Obtain frequency ratios data frame.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/freq_ratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Frequency ratios — freq_ratio","text":"","code":"freq_ratio(x, ...)"},{"path":"https://leonawicz.github.io/tabr/reference/freq_ratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Frequency ratios — freq_ratio","text":"x noteworthy music object, numeric vector list numeric vectors frequencies. ... additional arguments: ratios, one \"\" (default), \"root\", \"range\" filtering results. frequency input, may also specify octaves accidentals. See details examples.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/freq_ratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Frequency ratios — freq_ratio","text":"tibble data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/freq_ratio.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Frequency ratios — freq_ratio","text":"generic function returns data frame frequency ratios vector list frequencies, noteworthy object, music object. frequency inputs, list can used represent multiple timesteps. Octave numbering accidentals inferred noteworthy music objects, can specified frequency. See examples. default ratios returned combinations intervals chord (ratios = \"\"). ratios = \"root\" filters result include chord ratios respect root note chord. ratios = \"range\" filters chord ratio root highest note.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/freq_ratio.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Frequency ratios — freq_ratio","text":"","code":"x <- as_music(\"c4 e_ g ce_g\") (fr <- freq_ratio(x)) #> # A tibble: 6 × 5 #>   timestep notes      freq1 freq2 ratio #>      <int> <notwrthy> <dbl> <dbl> <dbl> #> 1        1 c           131.   NA  NA    #> 2        2 e_          156.   NA  NA    #> 3        3 g           196.   NA  NA    #> 4        4 ce_         131.  156.  1.19 #> 5        4 cg          131.  196.  1.50 #> 6        4 e_g         156.  196.  1.26  x <- music_notes(x) identical(fr, freq_ratio(x)) #> [1] TRUE  x <- chord_freq(x) identical(fr, freq_ratio(x)) #> [1] TRUE  freq_ratio(x, accidentals = \"sharp\") #> # A tibble: 6 × 5 #>   timestep notes      freq1 freq2 ratio #>      <int> <notwrthy> <dbl> <dbl> <dbl> #> 1        1 c           131.   NA  NA    #> 2        2 d#          156.   NA  NA    #> 3        3 g           196.   NA  NA    #> 4        4 cd#         131.  156.  1.19 #> 5        4 cg          131.  196.  1.50 #> 6        4 d#g         156.  196.  1.26  freq_ratio(x, ratios = \"root\") #> # A tibble: 5 × 5 #>   timestep notes      freq1 freq2 ratio #>      <int> <notwrthy> <dbl> <dbl> <dbl> #> 1        1 c           131.   NA  NA    #> 2        2 e_          156.   NA  NA    #> 3        3 g           196.   NA  NA    #> 4        4 ce_         131.  156.  1.19 #> 5        4 cg          131.  196.  1.50  freq_ratio(x, ratios = \"range\") #> # A tibble: 4 × 5 #>   timestep notes      freq1 freq2 ratio #>      <int> <notwrthy> <dbl> <dbl> <dbl> #> 1        1 c           131.   NA  NA    #> 2        2 e_          156.   NA  NA    #> 3        3 g           196.   NA  NA    #> 4        4 cg          131.  196.  1.50"},{"path":"https://leonawicz.github.io/tabr/reference/guitarChords.html","id":null,"dir":"Reference","previous_headings":"","what":"Predefined guitar chords — guitarChords","title":"Predefined guitar chords — guitarChords","text":"data frame containing information many predefined guitar chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/guitarChords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predefined guitar chords — guitarChords","text":"","code":"guitarChords"},{"path":"https://leonawicz.github.io/tabr/reference/guitarChords.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Predefined guitar chords — guitarChords","text":"data frame 12 columns 3,967 rows","code":""},{"path":"https://leonawicz.github.io/tabr/reference/hp.html","id":null,"dir":"Reference","previous_headings":"","what":"Hammer ons and pull offs — hp","title":"Hammer ons and pull offs — hp","text":"Helper function generating hammer pull syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/hp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hammer ons and pull offs — hp","text":"","code":"hp(...)"},{"path":"https://leonawicz.github.io/tabr/reference/hp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hammer ons and pull offs — hp","text":"... character, note durations. Numeric allowed lists single inputs. See examples.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/hp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hammer ons and pull offs — hp","text":"character.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/hp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hammer ons and pull offs — hp","text":"especially useful repeated instances. function applies general slur notation well. Multiple input formats allowed. Total number note durations must even slurs require start stop points.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/hp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hammer ons and pull offs — hp","text":"","code":"hp(16, 16) #> [1] \"16( 16)\" hp(\"16 16\") #> [1] \"16( 16)\" hp(\"16 8 16\", \"8 16 8\") #> [1] \"16( 8) 16( 8) 16( 8)\""},{"path":"https://leonawicz.github.io/tabr/reference/intervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval helpers — intervals","title":"Interval helpers — intervals","text":"Helper functions musical intervals defined two notes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/intervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval helpers — intervals","text":"","code":"pitch_interval(notes1, notes2, use_root = TRUE)  pitch_diff(notes, use_root = TRUE, n = 1, trim = FALSE)  scale_interval(   notes1,   notes2,   use_root = TRUE,   format = c(\"mmp_abb\", \"mmp\", \"ad_abb\", \"ad\") )  scale_diff(   notes,   use_root = TRUE,   n = 1,   trim = FALSE,   format = c(\"mmp_abb\", \"mmp\", \"ad_abb\", \"ad\") )  tuning_intervals(tuning = \"standard\")"},{"path":"https://leonawicz.github.io/tabr/reference/intervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval helpers — intervals","text":"use_root logical, use lowest pitch chord pitch intervals scale intervals adjacent timesteps. Otherwise intervals involving chords NA. notes, notes1, notes2 character, noteworthy string. notes1 notes2 must equal number timesteps. n integer, size lag. trim logical, trim n leading NA values lagged intervals. format character, format scale notation: major/minor/perfect, augmented/diminished, respective abbreviations. See argument options defaults. tuning character, string tuning.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/intervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval helpers — intervals","text":"musical interval, integer character depending function.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/intervals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Interval helpers — intervals","text":"Numeric intervals directional. pitch_interval() returns signed number semitones defining distance two notes. Named scale intervals names . Use pitch direction. scale_interval() returns character string provides named main interval, simple compound, defined  two notes. function returns NA uncommon range large interval listed named interval mainIntervals(). pitch_interval() scale_interval() compute intervals element-wise two noteworthy strings. pitch_diff() scale_diff() work similarly compute lagged intervals elements notes.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/intervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval helpers — intervals","text":"","code":"pitch_interval(\"b\", \"c4\") #> [1] 1 pitch_interval(\"c, e_, g_, a,\", \"e_, g_, a, c\") #> [1] 3 3 3 3 pitch_interval(\"c r\", \"dfa d\") #> [1]  2 NA pitch_interval(\"c r\", \"dfa d\", use_root = FALSE) #> [1] NA NA scale_interval(\"c\", \"e_\") #> [1] \"m3\" scale_interval(\"ceg\", \"egd'\") #> [1] \"M3\"  x <- \"a, b, c d e f g# ac'e' a c' e'\" pitch_diff(x) #>  [1] NA  2  1  2  2  1  3  1  0  3  4 pitch_diff(x, use_root = FALSE) #>  [1] NA  2  1  2  2  1  3 NA NA  3  4 scale_diff(x) #>  [1] NA   \"M2\" \"m2\" \"M2\" \"M2\" \"m2\" \"m3\" \"m2\" \"P1\" \"m3\" \"M3\" scale_diff(x, n = 2, trim = TRUE, use_root = FALSE) #> [1] \"m3\" \"m3\" \"M3\" \"m3\" \"M3\" NA   \"m2\" NA   \"P5\"  # Lagged intervals respect rest timesteps. # All timestep position including rests are retained. # But the lag-n difference skips rest entries. x <- \"a, c r r r r g\" pitch_diff(x) #> [1] NA  3 NA NA NA NA  7 scale_diff(x) #> [1] NA   \"m3\" NA   NA   NA   NA   \"P5\" pitch_diff(x, n = 2) #> [1] NA NA NA NA NA NA 10 scale_diff(x, n = 2) #> [1] NA   NA   NA   NA   NA   NA   \"m7\" pitch_diff(x, n = 2, trim = TRUE) #> [1] NA NA NA NA 10 scale_diff(x, n = 2, trim = TRUE) #> [1] NA   NA   NA   NA   \"m7\""},{"path":"https://leonawicz.github.io/tabr/reference/interval_semitones.html","id":null,"dir":"Reference","previous_headings":"","what":"Interval semitones — interval_semitones","title":"Interval semitones — interval_semitones","text":"Convert named intervals numbers semitones. complete list valid interval names abbreviations see mainIntervals(). interval may vector.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/interval_semitones.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interval semitones — interval_semitones","text":"","code":"interval_semitones(interval)"},{"path":"https://leonawicz.github.io/tabr/reference/interval_semitones.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interval semitones — interval_semitones","text":"interval character, interval ID. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/interval_semitones.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interval semitones — interval_semitones","text":"integer","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/interval_semitones.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interval semitones — interval_semitones","text":"","code":"x <- c(\"minor third\", \"m3\", \"augmented second\", \"A2\") y <- c(\"P1\", \"m2\", \"M2\", \"m3\", \"M3\", \"P4\", \"TT\", \"P5\") interval_semitones(x) #> [1] 3 3 3 3 interval_semitones(y) #> [1] 0 1 2 3 4 5 6 7"},{"path":"https://leonawicz.github.io/tabr/reference/is_diatonic.html","id":null,"dir":"Reference","previous_headings":"","what":"Check if notes and chords are diatonic — is_diatonic","title":"Check if notes and chords are diatonic — is_diatonic","text":"Check notes chords diatonic given key.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/is_diatonic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check if notes and chords are diatonic — is_diatonic","text":"","code":"is_diatonic(notes, key = \"c\")"},{"path":"https://leonawicz.github.io/tabr/reference/is_diatonic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check if notes and chords are diatonic — is_diatonic","text":"notes character, noteworthy string. key character, key signature.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/is_diatonic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check if notes and chords are diatonic — is_diatonic","text":"logical","code":""},{"path":"https://leonawicz.github.io/tabr/reference/is_diatonic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check if notes and chords are diatonic — is_diatonic","text":"function wrapper around is_in_scale(). check individual notes scale, see note_in_scale().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/is_diatonic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check if notes and chords are diatonic — is_diatonic","text":"","code":"is_diatonic(\"ceg ace ce_g\", \"c\") #> [1]  TRUE  TRUE FALSE is_diatonic(c(\"r\", \"d\", \"dfa\", \"df#a\"), \"d\") #> [1]    NA  TRUE FALSE  TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/keys.html","id":null,"dir":"Reference","previous_headings":"","what":"Key signatures — keys","title":"Key signatures — keys","text":"Helper functions key signature information.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/keys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Key signatures — keys","text":"","code":"keys(type = c(\"all\", \"sharp\", \"flat\"))  key_is_natural(key)  key_is_sharp(key)  key_is_flat(key)  key_n_sharps(key)  key_n_flats(key)  key_is_major(key)  key_is_minor(key)"},{"path":"https://leonawicz.github.io/tabr/reference/keys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Key signatures — keys","text":"type character, defaults \"\". key character, key signature.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/keys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Key signatures — keys","text":"character vector.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/keys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Key signatures — keys","text":"keys() function returns vector valid key signature IDs. IDs key signatures specified throughout tabr, including helper functions via key. Like functions , key_is_sharp() key_is_flat() key signatures, single pitches whose sharp flat status always self-evident notation. Major minor keys also self-evident notation, key_is_major() key_is_minor() can still useful programming.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/keys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Key signatures — keys","text":"","code":"keys() #>  [1] \"c\"   \"g\"   \"d\"   \"a\"   \"e\"   \"b\"   \"f#\"  \"c#\"  \"f\"   \"b_\"  \"e_\"  \"a_\"  #> [13] \"d_\"  \"g_\"  \"c_\"  \"am\"  \"em\"  \"bm\"  \"f#m\" \"c#m\" \"g#m\" \"d#m\" \"a#m\" \"dm\"  #> [25] \"gm\"  \"cm\"  \"fm\"  \"b_m\" \"e_m\" \"a_m\" key_is_natural(c(\"c\", \"am\", \"c#\")) #> [1]  TRUE  TRUE FALSE x <- c(\"a\", \"e_\") key_is_sharp(x) #> [1]  TRUE FALSE key_is_flat(x) #> [1] FALSE  TRUE key_n_sharps(x) #> [1] 3 0 key_n_flats(x) #> [1] 0 3"},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":null,"dir":"Reference","previous_headings":"","what":"Save score to LilyPond file — lilypond","title":"Save score to LilyPond file — lilypond","text":"Write score LilyPond format (.ly) text file later use LilyPond subsequent editing outside R.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Save score to LilyPond file — lilypond","text":"","code":"lilypond(   score,   file,   key = \"c\",   time = \"4/4\",   tempo = \"2 = 60\",   header = NULL,   paper = NULL,   string_names = NULL,   endbar = \"|.\",   midi = TRUE,   colors = NULL,   crop_png = TRUE,   simplify = TRUE )"},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Save score to LilyPond file — lilypond","text":"score score object. file character, LilyPond output file ending .ly. May include absolute relative path. key character, key signature, e.g., c, b_, f#m, etc. time character, defaults \"4/4\". tempo character, defaults \"2 = 60\". Set NA NULL suppress metronome mark output. suppressed midi = TRUE, error thrown. header named list arguments passed header LilyPond file. See details. paper named list arguments LilyPond file page layout. See details. string_names label strings beginning tab staff. NULL (default) non-standard tunings , TRUE FALSE force completely. endbar character, global end bar. midi logical, add midi inclusion specification LilyPond file. colors named list LilyPond element color overrides. See details. crop_png logical, alter template cropped height. See details. simplify logical, uses simplify_phrase() convert simpler, efficient LilyPond syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Save score to LilyPond file — lilypond","text":"nothing returned; file written.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Save score to LilyPond file — lilypond","text":"function writes LilyPond file disk. require LilyPond installation. checks version number installation, LilyPond required found. function can used directly commonly used render_* functions, call function internally create LilyPond file call LilyPond render file sheet music.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"header-options","dir":"Reference","previous_headings":"","what":"Header options","title":"Save score to LilyPond file — lilypond","text":"header list elements character strings. options header include following. title subtitle composer album arranger instrument meter opus piece poet copyright tagline","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"paper-options","dir":"Reference","previous_headings":"","what":"Paper options","title":"Save score to LilyPond file — lilypond","text":"paper list elements numeric except page_numbers print_first_page_number, logical. page_numbers = FALSE suppresses page numbering. page_numbers = TRUE, can set print_first_page_number = FALSE suppress printing first page number. first_page_number number first page, defaulting 1, determines subsequent page numbers. arguments correspond LilyPond paper block variables. options paper include following following default values provided. textheight = 220 linewidth = 150 indent = 0 fontsize = 10 page_numbers = TRUE print_first_page_number = TRUE first_page_number = 1","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"png-related-options","dir":"Reference","previous_headings":"","what":"PNG-related options","title":"Save score to LilyPond file — lilypond","text":"default crop_png = TRUE. alters template LilyPond output file created, contains specifications cropping image content file rendered LilyPond png. image width height automatically cropped rather retain standard page dimensions. applies png outputs made LilyPond file, pdf. argument also ignored explicitly providing textheight paper. may still provide linewidth paper find need increase beyond default 150mm, generally result using large fontsize. Various render_* functions wrap lilypond make use argument well.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"color-options","dir":"Reference","previous_headings":"","what":"Color options","title":"Save score to LilyPond file — lilypond","text":"can provide named list global color overrides various sheet music elements colors argument lilypond one associated rendering functions. default, everything black. Overrides inserted generated LilyPond file given. Values character; either hex color named R color. named list options include following. color background staff time key clef bar beam head stem accidental slur tabhead lyrics color global font color entire score. affects staff elements header elements. affect everything, e.g., page numbers. background controls background color entire page. use making transparent background png transparent argument available various render_* functions. options also global override color. can change color elements broadly color change color specific elements using options. currently limitations. Specifically, provide background color override, header elements display.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/lilypond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Save score to LilyPond file — lilypond","text":"","code":"if (FALSE) { # \\dontrun{ x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 432 432\") x <- track(x) x <- score(x) outfile <- file.path(tempdir(), \"out.ly\") lilypond(x, outfile, midi = FALSE) } # }"},{"path":"https://leonawicz.github.io/tabr/reference/lilypond_root.html","id":null,"dir":"Reference","previous_headings":"","what":"LilyPond installation information — lilypond_root","title":"LilyPond installation information — lilypond_root","text":"Details local LilyPond installation package API.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond_root.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LilyPond installation information — lilypond_root","text":"","code":"lilypond_root()  lilypond_version()  tabr_lilypond_api()"},{"path":"https://leonawicz.github.io/tabr/reference/lilypond_root.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LilyPond installation information — lilypond_root","text":"message system standard output.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond_root.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LilyPond installation information — lilypond_root","text":"Version information installation directory returned installation can found. LilyPond API references currently loaded version tabr.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lilypond_root.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LilyPond installation information — lilypond_root","text":"","code":"lilypond_root() #> C:/Program Files (x86)/LilyPond/usr/bin/lilypond.exe lilypond_version() tabr_lilypond_api() #> The tabr 0.5.4 LilyPond API was built and tested against LilyPond 2.23.6 on Windows."},{"path":"https://leonawicz.github.io/tabr/reference/lp_chord_id.html","id":null,"dir":"Reference","previous_headings":"","what":"LilyPond chord notation — lp_chord_id","title":"LilyPond chord notation — lp_chord_id","text":"Obtain LilyPond quasi-chord notation.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lp_chord_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LilyPond chord notation — lp_chord_id","text":"","code":"lp_chord_id(root, chord, exact = FALSE, ...)  lp_chord_mod(root, chord, exact = FALSE, ...)"},{"path":"https://leonawicz.github.io/tabr/reference/lp_chord_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LilyPond chord notation — lp_chord_id","text":"root character, root note. chord character, tabr format chord name. exact logical, return exact LilyPond chord representation. ... additional arguments passed transpose().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lp_chord_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LilyPond chord notation — lp_chord_id","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lp_chord_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"LilyPond chord notation — lp_chord_id","text":"functions take tabr syntax representation chord name convert quasi-LilyPond syntax; \"quasi\" result still uses _ flats # sharps, whereas LilyPond uses es (mostly). format used tabr functions involved communicating LilyPond music transcription, make final conversions fly. can overridden exact = TRUE.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lp_chord_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LilyPond chord notation — lp_chord_id","text":"","code":"lp_chord_id(\"a a a\", \"m M m7_5\") #> [1] \"a:m\"    \"a:5\"    \"a:m7_5\" lp_chord_mod(\"a a a\", \"m M m7_5\") #> [1] \"m\"    \"5\"    \"m7_5\" lp_chord_id(\"a a a\", \"m M m7_5\", exact = TRUE) #> [1] \"a:m\"     \"a:5\"     \"a:m7es5\" lp_chord_mod(\"a a a\", \"m M m7_5\", exact = TRUE) #> [1] \"m\"     \"5\"     \"m7es5\""},{"path":"https://leonawicz.github.io/tabr/reference/lyrics.html","id":null,"dir":"Reference","previous_headings":"","what":"Create lyrics and check lyrics string validity — lyrics","title":"Create lyrics and check lyrics string validity — lyrics","text":"Functions creating checking lyrics objects.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lyrics.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create lyrics and check lyrics string validity — lyrics","text":"","code":"lyrical(x)  as_lyrics(x, format = NULL)  is_lyrics(x)  lyrics_template(x, format = NULL)"},{"path":"https://leonawicz.github.io/tabr/reference/lyrics.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create lyrics and check lyrics string validity — lyrics","text":"x character lyrics object. lyrics_template(), integer one classes noteworthy, noteinfo music derive number timesteps . format NULL character, timestep delimiter format, \"space\" \"vector\".","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lyrics.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create lyrics and check lyrics string validity — lyrics","text":"depends function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lyrics.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create lyrics and check lyrics string validity — lyrics","text":"lyrics class simple class arranging lyrics text timestep. structure behavior aligns classes noteworthy, noteinfo music. lyrical() trivial function returns scalar logical result essentially object inherits character, though check may become specific future. as_lyrics() can used coerce lyrics class. Coercion fail string lyrical. lyrics class print() summary() methods. format = NULL, timestep delimiter format inferred lyrical string input.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/lyrics.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create lyrics and check lyrics string validity — lyrics","text":"","code":"# space-delimited lyrics; use periods for timesteps with no lyric x <- \"These are the ly- rics . . . to this song\" is_lyrics(x) #> [1] FALSE lyrical(x) #> [1] TRUE as_lyrics(x) #> <Lyrics string> #>   Format: space-delimited time #>   Values: These are the ly- rics . . . to this song  # character vector; empty, period or NA for no lyric x <- c(\"These\", \"are\", \"the\", \"ly-\", \"rics\",        \"\", \".\", NA, \"to\", \"this\", \"song\") # as_lyrics(x) #> <Lyrics string> #>   Format: vectorized time #>   Values: These are the ly- rics . . . to this song  # generate empty lyrics object from noteworthy, noteinfo or music object notes <- as_noteworthy(\"c d e d c r*3 e g c'\") x <- lyrics_template(notes) x #> <Lyrics string> #>   Format: space-delimited time #>   Values: . . . . . . . . . . .  x[1:5] <- strsplit(\"These are the ly- rics\", \" \")[[1]] x[9:11] <- c(\"to\", \"this\", \"song\") x #> <Lyrics string> #>   Format: space-delimited time #>   Values: These are the ly- rics . . . to this song  summary(x) #> <Lyrics string> #>   Timesteps: 11 (8 lyrics, 3 pauses) #>   Format: space-delimited time #>   Values: These are the ly- rics . . . to this song  attributes(x) #> $steps #> [1] 11 #>  #> $n_lyric #> [1] 8 #>  #> $n_pause #> [1] 3 #>  #> $format #> [1] \"space-delimited time\" #>  #> $class #> [1] \"lyrics\"    \"character\" #>"},{"path":"https://leonawicz.github.io/tabr/reference/mainIntervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Main musical intervals — mainIntervals","title":"Main musical intervals — mainIntervals","text":"data frame containing descriptions main intervals, simple compound.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/mainIntervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Main musical intervals — mainIntervals","text":"","code":"mainIntervals"},{"path":"https://leonawicz.github.io/tabr/reference/mainIntervals.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Main musical intervals — mainIntervals","text":"data frame 5 columns 26 rows","code":""},{"path":"https://leonawicz.github.io/tabr/reference/midily.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert MIDI to LilyPond file — midily","title":"Convert MIDI to LilyPond file — midily","text":"Convert MIDI file (.mid) LilyPond format (.ly) text file.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/midily.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert MIDI to LilyPond file — midily","text":"","code":"midily(   midi_file,   file,   key = \"c\",   absolute = FALSE,   quantize = NULL,   explicit = FALSE,   start_quant = NULL,   allow_tuplet = c(\"4*2/3\", \"8*2/3\", \"16*2/3\"),   details = FALSE,   lyric = FALSE )"},{"path":"https://leonawicz.github.io/tabr/reference/midily.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert MIDI to LilyPond file — midily","text":"midi_file character, MIDI file (.mid). May include absolute relative path. file LilyPond output file ending .ly. key key signature, defaults \"c\". absolute logical, print absolute pitches (unavailable current package version). quantize integer, duration, quantize notes duration. explicit logical, print explicit durations. start_quant integer, duration, quantize note starts duration. allow_tuplet character vector, allow tuplet durations. See details. details logical, print additional information console. lyric logical, treat text lyrics.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/midily.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert MIDI to LilyPond file — midily","text":"nothing returned; file written.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/midily.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert MIDI to LilyPond file — midily","text":"development/testing. See warning details . function wrapper around midi2ly() command line utility provided LilyPond. inherits limitations thereof. LilyPond intended used produce meaningful sheet music arbitrary MIDI files. lilypond() converts R code score() objects LilyPond markup directly, MIDI conversion LilyPond markup midily() requires LilyPond. WARNING: Even though purpose command line utility convert existing MIDI file LilyPond file, nevertheless generates LilyPond file specifies inclusion MIDI output. means subsequently process LilyPond file LilyPond use miditab() go straight MIDI file pdf output, command line tool also produce MIDI file output. overwrite original MIDI file file name location! allow_tuplets = NULL disallow tuplets. Fourth, eighth sixteenth note triplets allowed. format character vector element duration*numerator/denominator, spaces. See default argument. Windows systems, may necessary specify path tabr_options() midi2ly python already added system PATH variable.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/midily.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert MIDI to LilyPond file — midily","text":"","code":"if (FALSE) { # \\dontrun{ if(tabr_options()$midi2ly != \"\"){   midi <- system.file(\"example.mid\", package = \"tabr\")   outfile <- file.path(tempdir(), \"out.ly\")   midily(midi, outfile) # requires LilyPond installation } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/miditab.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert MIDI to tablature — miditab","title":"Convert MIDI to tablature — miditab","text":"Convert MIDI file  sheet music/guitar tablature.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/miditab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert MIDI to tablature — miditab","text":"","code":"miditab(midi_file, file, keep_ly = FALSE, details = FALSE, ...)"},{"path":"https://leonawicz.github.io/tabr/reference/miditab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert MIDI to tablature — miditab","text":"midi_file character, MIDI file (.mid). May include absolute relative path. file character, output file ending .pdf .png. keep_ly logical, keep LilyPond file. details logical, set TRUE print LilyPond log output console. Windows . ... additional arguments passed midily().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/miditab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert MIDI to tablature — miditab","text":"nothing returned; file written.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/miditab.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert MIDI to tablature — miditab","text":"development/testing. See warning details . Convert MIDI file pdf png music score using LilyPond music engraving program. Output format inferred file extension. function wrapper around midily(), function converts MIDI file LilyPond (.ly) file using LilyPond command line utility. WARNING: Even though purpose command line utility convert existing MIDI file LilyPond file, nevertheless generates LilyPond file specifies inclusion MIDI output. means subsequently process LilyPond file LilyPond use miditab() go straight MIDI file pdf output, command line tool also produce MIDI file output. overwrite original MIDI file file name location! Windows systems, may necessary specify path tabr_options() midi2ly python already added system PATH variable.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/miditab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert MIDI to tablature — miditab","text":"","code":"if (FALSE) { # \\dontrun{ if(tabr_options()$midi2ly != \"\"){   midi <- system.file(\"example.mid\", package = \"tabr\")   outfile <- file.path(tempdir(), \"out.pdf\")   miditab(midi, outfile, details = FALSE) # requires LilyPond installation } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/mode-helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Mode helpers — mode-helpers","title":"Mode helpers — mode-helpers","text":"Helper functions working musical modes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/mode-helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mode helpers — mode-helpers","text":"","code":"modes(mode = c(\"all\", \"major\", \"minor\"))  is_mode(notes, ignore_octave = FALSE)  mode_rotate(notes, n = 0, ignore_octave = FALSE)  mode_modern(   mode = \"ionian\",   key = \"c\",   collapse = FALSE,   ignore_octave = FALSE )  mode_ionian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  mode_dorian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  mode_phrygian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  mode_lydian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  mode_mixolydian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  mode_aeolian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  mode_locrian(key = \"c\", collapse = FALSE, ignore_octave = FALSE)"},{"path":"https://leonawicz.github.io/tabr/reference/mode-helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mode helpers — mode-helpers","text":"mode character, mode. notes character, mode, may noteworthy string seven notes, space- vector-delimited. ignore_octave logical, strip octave numbering modes rooted C. n integer, degree rotation. key character, key signature. collapse logical, collapse result single string ready phrase construction.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/mode-helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mode helpers — mode-helpers","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/mode-helpers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Mode helpers — mode-helpers","text":"valid key signatures, see keys(). Modern modes based major scales available key signature using mode_* functions. seven modes can listed modes. Noteworthy strings proper length can checked match mode is_mode(). Modes can rotated mode_rotate(), wrapper around note_rotate().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/mode-helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mode helpers — mode-helpers","text":"","code":"modes() #> [1] \"ionian\"     \"dorian\"     \"phrygian\"   \"lydian\"     \"mixolydian\" #> [6] \"aeolian\"    \"locrian\"    mode_dorian(\"c\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: c d e_ f g a b_ mode_modern(\"dorian\", \"c\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: c d e_ f g a b_ mode_modern(\"dorian\", \"c\", ignore_octave = TRUE) #> <Noteworthy string> #>   Format: vectorized time #>   Values: c d e_ f g a b_  identical(mode_rotate(mode_ionian(\"c\"), 1), mode_dorian(\"d\")) #> [1] TRUE identical(   mode_rotate(mode_ionian(\"c\", ignore_octave = TRUE), 1),   mode_dorian(\"d\", ignore_octave = TRUE) ) #> [1] TRUE  x <- sapply(modes(), mode_modern, ignore_octave = TRUE) setNames(data.frame(t(x)), as.roman(1:7)) #>            I II III IV  V VI VII #> ionian     c  d   e  f  g  a   b #> dorian     c  d  e_  f  g  a  b_ #> phrygian   c d_  e_  f  g a_  b_ #> lydian     c  d   e g_  g  a   b #> mixolydian c  d   e  f  g  a  b_ #> aeolian    c  d  e_  f  g a_  b_ #> locrian    c d_  e_  f g_ a_  b_"},{"path":"https://leonawicz.github.io/tabr/reference/music-helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Accessing music object values and attributes — music-helpers","title":"Accessing music object values and attributes — music-helpers","text":"Helper functions accessing music object values attributes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/music-helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Accessing music object values and attributes — music-helpers","text":"","code":"music_notes(x)  music_info(x)  music_strings(x)  music_key(x)  music_time(x)  music_tempo(x)  music_lyrics(x)"},{"path":"https://leonawicz.github.io/tabr/reference/music-helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Accessing music object values and attributes — music-helpers","text":"x music object.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/music-helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Accessing music object values and attributes — music-helpers","text":"depends function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/music-helpers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Accessing music object values and attributes — music-helpers","text":"Note lyrics always shows attribute even NA, strings completely absent value part object construction new character string.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/music-helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Accessing music object values and attributes — music-helpers","text":"","code":"# Starting string = 5: use ';5'. Carries over until an explicit change. x <- \"a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\" x <- as_music(x)  y <- lyrics_template(x) y[3:8] <- strsplit(\"These are some song ly- rics\", \" \")[[1]] y #> <Lyrics string> #>   Format: space-delimited time #>   Values: . . These are some song ly- rics . . . . . .  x <- as_music(x, lyrics = y)  attributes(x) #> $steps #> [1] 14 #>  #> $n_note #> [1] 11 #>  #> $n_chord #> [1] 3 #>  #> $octave #> [1] \"tick\" #>  #> $accidentals #> [1] \"flat\" #>  #> $format #> [1] \"space-delimited time\" #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\" #>  #> $lyrics #> <Lyrics string> #>   Format: space-delimited time #>   Values: . . These are some song ly- rics . . . . . . #>  #> $string #>  [1] \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5432\" \"5432\" \"2\"    #> [11] \"3\"    \"4\"    \"5\"    \"51\"   #>  #> $class #> [1] \"music\"     \"character\" #>   music_split(x) #> $notes #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, a, a, a, a, b, c <cgc'e'~> <cgc'e'> e' c' g c <ce'> #>  #> $info #> <Note info string> #>   Format: space-delimited time #>   Values: 4 4 4 4 4 4- 4 4 1 4 4 4 4 1 #>  #> $string #>  [1] \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5432\" \"5432\" \"2\"    #> [11] \"3\"    \"4\"    \"5\"    \"51\"   #>  #> $lyrics #> <Lyrics string> #>   Format: space-delimited time #>   Values: . . These are some song ly- rics . . . . . . #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\" #>   music_notes(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, a, a, a, a, b, c <cgc'e'~> <cgc'e'> e' c' g c <ce'> music_info(x) #> <Note info string> #>   Format: space-delimited time #>   Values: 4 4 4 4 4 4- 4 4 1 4 4 4 4 1 music_key(x) #> [1] \"c\" music_time(x) #> [1] \"4/4\" music_tempo(x) #> [1] \"2 = 60\" music_lyrics(x) #> <Lyrics string> #>   Format: space-delimited time #>   Values: . . These are some song ly- rics . . . . . . music_strings(x) #>  [1] \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5432\" \"5432\" \"2\"    #> [11] \"3\"    \"4\"    \"5\"    \"51\""},{"path":"https://leonawicz.github.io/tabr/reference/music.html","id":null,"dir":"Reference","previous_headings":"","what":"Create music objects and check music string validity — music","title":"Create music objects and check music string validity — music","text":"Check whether string comprised exclusively valid syntax music strings. music object can built string. combines noteworthy string note info string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/music.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create music objects and check music string validity — music","text":"","code":"musical(x)  as_music(   notes,   info = NULL,   lyrics = NA,   key = \"c\",   time = \"4/4\",   tempo = \"2 = 60\",   accidentals = NULL,   format = NULL,   labels = NULL,   at = seq_along(labels) )  is_music(x)  music_split(x)"},{"path":"https://leonawicz.github.io/tabr/reference/music.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create music objects and check music string validity — music","text":"x character music, string coerced existing music object. notes, info noteworthy note info strings. as_music(), complete music string assumed notes info = NULL. lyrics optional lyrics object NA, attached output attribute. key character, store key signature music attribute. Defaults \"c\". See details. time character, store time signature music attribute. Defaults \"4/4\". See details. tempo character NA, defaults \"2 = 60\". See details. accidentals NULL character, represent accidentals, \"flat\" \"sharp\". format NULL character, timestep delimiter format, \"space\" \"vector\". labels character, text annotations attach timesteps using notate. integer, timesteps labels, defaults starting time one.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/music.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create music objects and check music string validity — music","text":"depends function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/music.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create music objects and check music string validity — music","text":"note info strings, required enter something every timestep, even duration. makes sense enter something, simply indication timestep. nice feature music strings explicit timesteps achieved just notes present, allowing leave durations entirely repeat, inheriting previous timestep duration given explicitly. need enter number across consecutive timesteps; first suffice rest automatically filled object constructed. musical() returns scalar logical result indicating whether timesteps contain exclusively valid entries. as_music() can used coerce music class. Coercion fail string musical. music class print() summary() methods. music objects primarily intended represent aggregation noteworthy object noteinfo. can optionally fold lyrics object well. However, music data analysis, operations involve first splitting object component parts. value class efficient data entry provides. accidentals format NULL, settings inferred musical string input. mixed formats present, flats default accidentals. attributes attached music object. key uses tabr syntax, e.g., \"c\", \"b_\", \"f#m\", etc. time tempo use LilyPond string format. music programming analysis, key, time tempo can likely ignored. primarily relevant rendering music snippet directly music object LilyPond. additional attributes provide complete context rendered sheet music. plan render music snippets music object defining new character string, context mind stringed fretted instrument like guitar, can specify string numbers end timestep numbers following semicolon delimiter. still precede * timestep multiplier number. See examples. Note convert music object phrase object, changing contexts. phrase object simplest LilyPond-format music structure. Coercion phrase() strips attributes music object retains notes, note info string numbers.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/music.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create music objects and check music string validity — music","text":"","code":"# note durations inherit from previous timestep if missing x <- \"a#4-+ b_[staccato] c,x d''t8( e)( g_')- a4 c,e_,g, ce_g4. a~8 a1\" is_music(x) #> [1] FALSE musical(x) #> [1] TRUE x <- as_music(x) is_music(x) #> [1] TRUE x #> <Music string> #>   Format: space-delimited time #>   Values: b_4-+ b_4[staccato] c,4x d''t8( et8)( g_'t8)- a4 <c,e_,g,>4 <ce_g>4. a~8 a1  y <- lyrics_template(x) y[3:8] <- strsplit(\"These are some song ly- rics\", \" \")[[1]] y #> <Lyrics string> #>   Format: space-delimited time #>   Values: . . These are some song ly- rics . . .  x <- as_music(x, lyrics = y, accidentals = \"sharp\") summary(x) #> <Music string> #>   Timesteps: 11 (9 notes, 2 chords) #>   Octaves: tick #>   Accidentals: sharp #>   Key signature: c #>   Time signature: 4/4 #>   Tempo: 2 = 60 #>   Lyrics: . . These are some song ly- rics . ... #>   Format: space-delimited time #>   Values: a#4-+ a#4[staccato] c,4x d''t8( et8)( f#'t8)- a4 <c,d#,g,>4 <cd#g>4. a~8 a1  # Starting string = 5: use ';5'. Carries over until an explicit change. x <- \"a,4;5*5 b,4-+ c4[staccato] cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\" x <- as_music_df(as_music(x)) x$string #>  [1] \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5\"    \"5432\" \"5432\" \"2\"    #> [11] \"3\"    \"4\"    \"5\"    \"51\""},{"path":"https://leonawicz.github.io/tabr/reference/notate.html","id":null,"dir":"Reference","previous_headings":"","what":"Add text to music staff — notate","title":"Add text to music staff — notate","text":"Annotate music staff, vertically aligned music staff specific note/time.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/notate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add text to music staff — notate","text":"","code":"notate(x, text, position = \"top\")"},{"path":"https://leonawicz.github.io/tabr/reference/notate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add text to music staff — notate","text":"x character. text character. position character, top bottom.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/notate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add text to music staff — notate","text":"character string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/notate.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Add text to music staff — notate","text":"function binds text annotation LilyPond syntax note's associated info entry. Technically, syntax hybrid form, later updated safely unambiguously LilyPond syntax respect rest note info substring fed phrase() musical phrase assembly.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/notate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add text to music staff — notate","text":"","code":"notate(\"8\", \"Solo\") #> [1] \"8;^\\\"Solo\\\"\" phrase(\"c'~ c' d' e'\", pc(notate(8, \"First solo\"), \"8 8 4.\"), \"5 5 5 5\") #> <Musical phrase> #> <c'~\\5>8^\"First solo\" <c'\\5>8 <d'\\5>8 <e'\\5>4."},{"path":"https://leonawicz.github.io/tabr/reference/note-checks.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic noteworthy string checks — note-checks","title":"Basic noteworthy string checks — note-checks","text":"simplest functions inspecting noteworthy strings see notes certain properties.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-checks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic noteworthy string checks — note-checks","text":"","code":"note_is_accidental(notes)  note_is_natural(notes)  note_is_flat(notes)  note_is_sharp(notes)  note_has_accidental(notes)  note_has_natural(notes)  note_has_flat(notes)  note_has_sharp(notes)"},{"path":"https://leonawicz.github.io/tabr/reference/note-checks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic noteworthy string checks — note-checks","text":"notes character, noteworthy string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-checks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic noteworthy string checks — note-checks","text":"logical","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-checks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basic noteworthy string checks — note-checks","text":"Note functions weakest terms checking noteworthiness. simple regular expression-based wrappers. often used internally complex functions without wasting computational overhead performing input validity checks, exported package user convenience. results make sense strings define accordance noteworthy string rules. note_is_* functions return logical vector length equal number timesteps notes. note_has_* functions summarize single logical value.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/note-checks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic noteworthy string checks — note-checks","text":"","code":"x <- \"r a_2 a a#' s\" note_has_accidental(x) #> [1] TRUE note_has_natural(x) #> [1] TRUE note_has_flat(x) #> [1] TRUE note_has_sharp(x) #> [1] TRUE note_is_accidental(x) #> [1] FALSE  TRUE FALSE  TRUE FALSE note_is_natural(x) #> [1]  TRUE FALSE  TRUE FALSE  TRUE note_is_flat(x) #> [1] FALSE  TRUE FALSE FALSE FALSE note_is_sharp(x) #> [1] FALSE FALSE FALSE  TRUE FALSE note_has_tick(x) #> [1] TRUE note_has_integer(x) #> [1] TRUE note_is_tick(x) #> [1] FALSE FALSE FALSE  TRUE FALSE note_is_integer(x) #> [1] FALSE  TRUE FALSE FALSE FALSE note_has_rest(x) #> [1] TRUE note_is_rest(x) #> [1]  TRUE FALSE FALSE FALSE  TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":null,"dir":"Reference","previous_headings":"","what":"Basic noteworthy strings formatting and coercion helpers — note-coerce","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"Helper functions setting formatting attributes noteworthy strings including representation timesteps, octaves accidentals.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"","code":"naturalize(notes, type = c(\"both\", \"flat\", \"sharp\"))  sharpen_flat(notes)  flatten_sharp(notes)  note_set_key(notes, key = \"c\")  as_tick_octaves(notes)  as_integer_octaves(notes)  as_space_time(x)  as_vector_time(x)  pretty_notes(notes, ignore_octave = TRUE)"},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"notes character, noteworthy string, space-delimited vector individual entries. type character, type note naturalize. key character, key signature coerce accidentals appropriate form key. May also specify \"sharp\" \"flat\". x generic functions: notes, info music string. ignore_octave logical, strip octave notation may present, returning basic notes without explicit pitch.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"sharpen_flat() flatten_sharp(), sharpening flats flattening sharps refer inverting respective notation, raising lowering flatted sharped note one semitone. latter, use naturalize(), removes flat /sharp notation string. note_set_key() used coercing noteworthy string specific consistent notation accidentals based key signature. wrapper around sharpen_flat() flatten_sharp(). as_tick_octaves(), as_integer_octaves(), as_space_time() as_vector_time() similarly affect octave timestep format. simultaneous control representation timesteps, octave numbering accidentals, three available arguments as_noteworthy().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":"a-note-on-generic-functions","dir":"Reference","previous_headings":"","what":"A note on generic functions","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"as_space_time() as_vector_time() generic since apply clearly useful noteworthy strings, also note info music objects. x still simple character string, functions attempt guess three . recommended set class using functions. many package functions operate noteworthy strings concept work music objects, expectation sound time/info disentangled. music class convenient data entry, e.g., transcription purposes, sensible perform data analysis quantities like pitch time tightly bound together. lead repetitive deconstructions reconstructions music class objects. functions operate noteworthy strings note info strings strictly apply one . Generic functions reserved fundamental generally applicable metadata retrieval format coercion.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/note-coerce.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basic noteworthy strings formatting and coercion helpers — note-coerce","text":"","code":"x <- \"e_2 a_, b_, c#f#a# c#'f#'a#''\" note_set_key(x, \"f\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <d_g_b_> <d_'g_'b_''> note_set_key(x, \"g\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d#, g#, a#, <c#f#a#> <c#'f#'a#''> as_tick_octaves(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <d_g_b_> <d_'g_'b_''> as_integer_octaves(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_2 a_2 b_2 <d_g_b_> <d_4g_4b_5> y <- as_vector_time(x) is_vector_time(y) #> [1] TRUE is_space_time(as_space_time(y)) #> [1] TRUE  naturalize(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e, a, b, <cfa> <c'f'a''> naturalize(x, \"sharp\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <cfa> <c'f'a''> sharpen_flat(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d#, g#, a#, <c#f#a#> <c#'f#'a#''> flatten_sharp(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, b_, <d_g_b_> <d_'g_'b_''> pretty_notes(x) #> [1] \"Eb Ab Bb C#F#A# C#F#A#\""},{"path":"https://leonawicz.github.io/tabr/reference/note-equivalence.html","id":null,"dir":"Reference","previous_headings":"","what":"Note, pitch and chord equivalence — note-equivalence","title":"Note, pitch and chord equivalence — note-equivalence","text":"Helper functions check equivalence two noteworthy strings, related functions.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-equivalence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Note, pitch and chord equivalence — note-equivalence","text":"","code":"note_is_equal(notes1, notes2, ignore_octave = TRUE)  note_is_identical(notes1, notes2, ignore_octave = TRUE)  pitch_is_equal(notes1, notes2)  pitch_is_identical(notes1, notes2)  octave_is_equal(notes1, notes2)  octave_is_identical(notes1, notes2, single_octave = FALSE)"},{"path":"https://leonawicz.github.io/tabr/reference/note-equivalence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Note, pitch and chord equivalence — note-equivalence","text":"notes1 character, noteworthy string, space-delimited vector individual entries. notes2 character, noteworthy string, space-delimited vector individual entries. ignore_octave logical, ignore octave position considering equivalence. single_octave logical, octave equality, require notes share octave. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-equivalence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Note, pitch and chord equivalence — note-equivalence","text":"logical","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-equivalence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Note, pitch and chord equivalence — note-equivalence","text":"Noteworthy strings may contain notes, pitches chords. Noteworthy strings equal sound . means one string contains Eb (e_) contains D# (d#) two strings may equal, identical. pitch_is_equal() pitch_is_identical() perform respective tests equivalence notes chords. strictest functions terms equivalent sound pitch includes octave number. note_is_equal() note_is_identical() similar include default argument ignore_octave = TRUE, focusing notes chords. allows even relaxed definition equivalence. Setting argument FALSE calling pitch_is_* variant. Chords can checked notes. Every timestep sequence checked pairwise note1 note2. functions return TRUE FALSE every timestep sequence. two noteworthy strings contain number notes specific step, single note compared chord, yields FALSE value, even case octave dyad octave number ignored. two sequences unequal length NA returned. bare minimum requirements equivalence. See examples. octave_is_equal() octave_is_identical() allow much weaker forms equivalence ignore notes completely. functions concerned comparing octave numbers spanned pitches present timestep. checking equality, octave_is_equal() looks octave number associated first note step, e.g., root note chord. octave_is_identical() compares octaves spanned given timestep. matter comparing two chords may comprised different numbers notes. set unique octaves spanned one chord identical set spanned , considered identical octave coverage. example, a1b2c3 identical d1e1f2g3. equal, matters two chords begin x1, x note. Alternatively, octave_is_identical() , setting single_octave = TRUE additionally requires notes chords compared given timestep share single octave.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-equivalence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Note, pitch and chord equivalence — note-equivalence","text":"","code":"x <- \"b_2 ce_g\" y <- \"b_ cd#g\" note_is_equal(x, y) #> [1] TRUE TRUE note_is_identical(x, y) #> [1]  TRUE FALSE  x <- \"b_2 ce_g\" y <- \"b_2 cd#g\" pitch_is_equal(x, y) #> [1] TRUE TRUE pitch_is_identical(x, y) #> [1]  TRUE FALSE  # same number of same notes, same order: unequal sequence length x <- \"b_2 ce_g b_\" y <- \"b_2 ce_gb_\" note_is_equal(x, y) #> [1] NA  # same number of same notes, order, equal length: unequal number per timestep x <- \"b_2 ce_g b_\" y <- \"b_2 ce_ gb_\" note_is_equal(x, y) #> [1]  TRUE FALSE FALSE  x <- \"a1 b_2 a1b2c3 a1b4 g1a1b1\" y <- \"a_2 g#2 d1e1f2g3 a1b2b4 d1e1\" octave_is_equal(x, y) #> [1] FALSE  TRUE  TRUE  TRUE  TRUE octave_is_identical(x, y) #> [1] FALSE  TRUE  TRUE FALSE  TRUE octave_is_identical(x, y, single_octave = TRUE) #> [1] FALSE  TRUE FALSE FALSE  TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/note-logic.html","id":null,"dir":"Reference","previous_headings":"","what":"Relational operators for noteworthy class — note-logic","title":"Relational operators for noteworthy class — note-logic","text":"Relational operators comparing two noteworthy class objects.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-logic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Relational operators for noteworthy class — note-logic","text":"","code":"# S3 method for class 'noteworthy' e1 == e2  # S3 method for class 'noteworthy' e1 != e2  # S3 method for class 'noteworthy' e1 < e2  # S3 method for class 'noteworthy' e1 <= e2  # S3 method for class 'noteworthy' e1 > e2  # S3 method for class 'noteworthy' e1 >= e2"},{"path":"https://leonawicz.github.io/tabr/reference/note-logic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Relational operators for noteworthy class — note-logic","text":"e1 noteworthy string. e2 noteworthy string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-logic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Relational operators for noteworthy class — note-logic","text":"logical vector","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-logic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Relational operators for noteworthy class — note-logic","text":"Equality assessed manner used note_sort() sorting pitches. matters underlying semitone value associated pitch, string notation flat vs. sharp (see pitch_is_identical()). comparing chords, chord vs. single note, comparison favors root. Comparison made respective lowest pitches, proceeds next pitch equal. operators, objects left right side operator must noteworthy error returned. examples include chord pitches entered pitch order. affect results pitches within chords sorted note note comparisons timestep done e1 e2.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-logic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Relational operators for noteworthy class — note-logic","text":"","code":"x <- as_noteworthy(\"f# a d'f#'a' d'f#'a'\") y <- as_noteworthy(\"g_ b f#'a'd' d'd''\") x == y #> [1]  TRUE FALSE  TRUE FALSE x != y #> [1] FALSE  TRUE FALSE  TRUE x < y #> [1] FALSE  TRUE FALSE  TRUE x > y #> [1] FALSE FALSE FALSE FALSE x <= y #> [1] TRUE TRUE TRUE TRUE x >= y #> [1]  TRUE FALSE  TRUE FALSE"},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":null,"dir":"Reference","previous_headings":"","what":"Noteworthy string metadata — note-metadata","title":"Noteworthy string metadata — note-metadata","text":"Inspect basic metadata noteworthy strings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noteworthy string metadata — note-metadata","text":"","code":"n_steps(x)  n_notes(notes)  n_chords(notes)  n_octaves(notes)  chord_size(notes)  octave_type(notes)  accidental_type(x)  time_format(x)  is_space_time(x)  is_vector_time(x)  note_is_tick(notes)  note_is_integer(notes)  note_has_tick(notes)  note_has_integer(notes)  note_is_rest(notes)  note_has_rest(notes)"},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noteworthy string metadata — note-metadata","text":"x generic functions: notes, info music string. notes character, noteworthy string, space-delimited vector individual entries.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noteworthy string metadata — note-metadata","text":"varies function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Noteworthy string metadata — note-metadata","text":"functions inspect basic metadata noteworthy strings. functions perform basic checks strings, see note-checks(). n_* functions give summary totals number timesteps, number individual note (non-chord) timesteps, number chord time steps, number distinct octaves present across timesteps. Functions pertaining type format noteworthy string provide information particular string defined, e.g. time_format. Note result pertains true noteworthy-class objects. inspecting standard character string, result pertains post-conversion noteworthy class necessarily reflect found notes verbatim. See examples.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":"a-note-on-generic-functions","dir":"Reference","previous_headings":"","what":"A note on generic functions","title":"Noteworthy string metadata — note-metadata","text":"n_steps() three time format functions generic since apply clearly useful noteworthy strings, also note info, music, lyrics objects. x still simple character string, functions attempt guess noteworthy, note info, music. Lyrics content arbitrary never considered simple character string. Best practice set class using functions anyway. many package functions operate noteworthy strings concept also work music objects, expectation sound time/info disentangled analysis. music class convenient relatively efficient data entry, e.g., transcription purposes, sensible perform data analysis quantities like pitch time tightly bound together single string. lead repetitive deconstructions reconstructions music class objects. music class intended transient class data import, data entry, data export. functions operate noteworthy strings note info strings strictly apply one . Generic functions reserved fundamental generally applicable metadata retrieval format coercion.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/note-metadata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noteworthy string metadata — note-metadata","text":"","code":"x <- \"e_2 a_, c#f#a#\" n_steps(x) #> [1] 3 n_notes(x) #> [1] 2 n_chords(x) #> [1] 1 n_octaves(x) #> [1] 2 chord_size(x) #> [1] 1 1 3  # Type is mixed in `x` but is inferred under default conversion rules. # These check `x` once validated and coerced to 'noteworthy' class. octave_type(x) #> [1] \"tick\" accidental_type(x) #> [1] \"flat\" # The default is tick octaves and flats as_noteworthy(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, <d_g_b_>  time_format(x) #> [1] \"space-delimited time\" is_space_time(x) #> [1] TRUE is_vector_time(x) #> [1] FALSE"},{"path":"https://leonawicz.github.io/tabr/reference/note-summaries.html","id":null,"dir":"Reference","previous_headings":"","what":"Noteworthy string summaries — note-summaries","title":"Noteworthy string summaries — note-summaries","text":"Basic summary functions noteworthy strings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-summaries.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Noteworthy string summaries — note-summaries","text":"","code":"tally_notes(notes, rests = FALSE)  tally_pitches(notes, rests = FALSE)  octaves(notes)  tally_octaves(notes)  distinct_notes(notes, rests = FALSE)  distinct_pitches(notes, rests = FALSE)  distinct_octaves(notes)  pitch_range(notes)  semitone_range(notes)  semitone_span(notes)  octave_range(notes)  octave_span(notes)"},{"path":"https://leonawicz.github.io/tabr/reference/note-summaries.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Noteworthy string summaries — note-summaries","text":"notes character, noteworthy string, space-delimited vector individual entries. rests logical, include rests r silent rests s tally.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-summaries.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Noteworthy string summaries — note-summaries","text":"varies function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note-summaries.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Noteworthy string summaries — note-summaries","text":"functions provide basic summaries noteworthy strings. Returned object depends nature function. can integers, logical, character. Results can vector equal length single value summary. Use tally_* distinct_* functions specifically summaries unique elements. distinct_notes() distinct_pitches() filter noteworthy string unique elements, respectively. functions return another noteworthy string. *_span functions just size range, e.g., semitone_range() semitone_span().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/note-summaries.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Noteworthy string summaries — note-summaries","text":"","code":"x <- \"r s e_2 a_, c#f#a#\" tally_notes(x) #> # A tibble: 5 × 2 #>   note      n #>   <chr> <int> #> 1 c#        1 #> 2 e_        1 #> 3 f#        1 #> 4 a_        1 #> 5 a#        1 tally_pitches(x) #> # A tibble: 5 × 2 #>   pitch     n #>   <chr> <int> #> 1 e_2       1 #> 2 a_,       1 #> 3 c#        1 #> 4 f#        1 #> 5 a#        1 octaves(x) #> [[1]] #> [1] NA #>  #> [[2]] #> [1] NA #>  #> [[3]] #> [1] 2 #>  #> [[4]] #> [1] 2 #>  #> [[5]] #> [1] 3 3 3 #>  tally_octaves(x) #> # A tibble: 2 × 2 #>   octave     n #>    <int> <int> #> 1      2     2 #> 2      3     3 distinct_notes(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d_ e_ g_ a_ b_ distinct_pitches(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e_, a_, d_ g_ b_ distinct_octaves(x) #> [1] 2 3  pitch_range(x) #> [1] \"e_,\" \"b_\"  semitone_range(x) #> [1] 39 58 semitone_span(x) #> [1] 19 octave_range(x) #> [1] 2 3 octave_span(x) #> [1] 1"},{"path":"https://leonawicz.github.io/tabr/reference/noteinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Note info helpers — noteinfo","title":"Note info helpers — noteinfo","text":"Functions working note info strings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/noteinfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Note info helpers — noteinfo","text":"","code":"info_duration(x)  info_slur_on(x)  info_slur_off(x)  info_slide(x)  info_bend(x)  info_dotted(x)  info_single_dotted(x)  info_double_dotted(x)  info_annotation(x)  info_articulation(x)"},{"path":"https://leonawicz.github.io/tabr/reference/noteinfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Note info helpers — noteinfo","text":"x character, note info string normally accompanying noteworthy string building phrase objects. x may also phrase object.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/noteinfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Note info helpers — noteinfo","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/noteinfo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Note info helpers — noteinfo","text":"x phrase object, parsing limitations tuplets repeats.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/noteinfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Note info helpers — noteinfo","text":"","code":"a <- notate(\"t8x\", \"Start here\") notes <- \"a, b, c d e f g# a r ac'e' a c' e' c' r*3 ac'e'~ ac'e'\" info <- paste(a, \"t8x t8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1\") x <- as_music(notes, info)  data.frame(   duration = info_duration(x),   slur_on = info_slur_on(x),   slur_off = info_slur_off(x),   slide = info_slide(x),   bend = info_bend(x),   dotted = info_dotted(x),   dotted1 = info_single_dotted(x),   dotted2 = info_double_dotted(x),   annotation = info_annotation(x),   articulation = info_articulation(x) ) #>    duration slur_on slur_off slide  bend dotted dotted1 dotted2 annotation #> 1        t8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE Start here #> 2        t8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 3        t8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 4        16   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 5       4..   FALSE    FALSE FALSE FALSE   TRUE   FALSE    TRUE       <NA> #> 6        16   FALSE    FALSE  TRUE FALSE  FALSE   FALSE   FALSE       <NA> #> 7        16   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 8         2   FALSE    FALSE FALSE  TRUE  FALSE   FALSE   FALSE       <NA> #> 9         2   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 10       4.   FALSE    FALSE FALSE FALSE   TRUE    TRUE   FALSE       <NA> #> 11        8    TRUE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 12        4    TRUE     TRUE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 13        4   FALSE     TRUE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 14        8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 15        8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 16        8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 17        8   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 18        1   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #> 19        1   FALSE    FALSE FALSE FALSE  FALSE   FALSE   FALSE       <NA> #>    articulation #> 1          <NA> #> 2          <NA> #> 3            -. #> 4          <NA> #> 5          <NA> #> 6          <NA> #> 7          <NA> #> 8          <NA> #> 9          <NA> #> 10         <NA> #> 11         <NA> #> 12         <NA> #> 13         <NA> #> 14         <NA> #> 15         <NA> #> 16         <NA> #> 17         <NA> #> 18         <NA> #> 19         <NA>"},{"path":"https://leonawicz.github.io/tabr/reference/note_ngram.html","id":null,"dir":"Reference","previous_headings":"","what":"Note/chord n-gram — note_ngram","title":"Note/chord n-gram — note_ngram","text":"Convert noteworthy string list noteworthy n-grams.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_ngram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Note/chord n-gram — note_ngram","text":"","code":"note_ngram(notes, n = 2, tally = FALSE, rests = FALSE)"},{"path":"https://leonawicz.github.io/tabr/reference/note_ngram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Note/chord n-gram — note_ngram","text":"notes noteworthy string. n Number grams. Must >= 1 <= number timesteps notes. tally logical, tally n-grams data frame. Otherwise list. rests logical, exclude rests. Affects number timesteps.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_ngram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Note/chord n-gram — note_ngram","text":"list noteworthy objects tibble","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_ngram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Note/chord n-gram — note_ngram","text":"","code":"x <- as_noteworthy(\"c r ceg dfa ceg dfa\") note_ngram(x) #> [[1]] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c #>  #> [[2]] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c <ceg> #>  #> [[3]] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ceg> <dfa> #>  #> [[4]] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <dfa> <ceg> #>  #> [[5]] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <ceg> <dfa> #>  (x <- note_ngram(x, tally = TRUE)) #> # A tibble: 4 × 2 #>   ngram              n #>   <list>         <int> #> 1 <notwrthy [1]>     1 #> 2 <notwrthy [1]>     1 #> 3 <notwrthy [1]>     2 #> 4 <notwrthy [1]>     1 x$ngram <- as.character(x$ngram) x #> # A tibble: 4 × 2 #>   ngram       n #>   <chr>   <int> #> 1 c           1 #> 2 c ceg       1 #> 3 ceg dfa     2 #> 4 dfa ceg     1"},{"path":"https://leonawicz.github.io/tabr/reference/note_slice.html","id":null,"dir":"Reference","previous_headings":"","what":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","title":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","text":"Helper functions indexing moving notes within noteworthy strings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_slice.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","text":"","code":"note_slice(notes, ...)  note_sort(notes, decreasing = FALSE)  note_rotate(notes, n = 0)  note_shift(notes, n = 0)  note_arpeggiate(notes, n = 0, step = 12)"},{"path":"https://leonawicz.github.io/tabr/reference/note_slice.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","text":"notes character, noteworthy string, space-delimited vector individual entries. ... note_slice(), integer logical vector. decreasing logical, short decreasing order. n integer, number rotations extensions note sequence. See details. step integer, number semitone steps first (last) note notes begin repeating shifted notes sequence arpeggio. See examples.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_slice.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_slice.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","text":"note_slice() subsets timesteps noteworthy string integer index logical vector length equal number timesteps. note_sort() sorts timesteps noteworthy string pitch. tie exists root note, next note chords compared, exist. example, , sorts lower ,ce. note_rotate() simply rotates anything space-delimited vectorized place. allows chords. Octave numbering ignored present. note_shift() entire sequence shifted pitch, inverting broken chord. notes contains chords, broken successive notes. notes ordered pitch. Finally shifting occurs. Instead moving window, note_arpeggiate() grows sequence original set timesteps repeating entire sequence n times (n must positive). repeated sequence contributing arpeggio offset step semitones original. step can negative. defaults 12, increasing notes one octave.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/note_slice.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Slice, sort, rotate, shift and arpeggiate notes — note_slice","text":"","code":"x <- \"bd'f#' a c'e'g' b ba c'g' gd'g'd''\" note_sort(x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <gd'g'd''> a <ba> b <bd'f#'> <c'e'g'> <c'g'> note_sort(x, decreasing = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <c'g'> <c'e'g'> <bd'f#'> b <ba> a <gd'g'd''>  x <- \"e_2 a_, c#f#a#\" note_slice(x, 2:3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_, <d_g_b_> note_slice(x, c(FALSE, TRUE, TRUE)) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_, <d_g_b_>  note_rotate(x, 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_, <d_g_b_> e_,  note_shift(\"c e g\", 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: e g c' note_shift(\"c e g\", -4) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g,, c, e,  note_arpeggiate(\"c e g ceg\", 3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e g <ceg> c' e' g' <c'e'g'> c'' e'' g'' <c''e''g''> c''' e''' g''' <c'''e'''g'''> note_arpeggiate(\"c e g\", 3, step = -12) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e g c, e, g, c,, e,, g,, c,,, e,,, g,,, note_arpeggiate(\"g e c\", 3, step = -12) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g e c g, e, c, g,, e,, c,, g,,, e,,, c,,, note_arpeggiate(\"c e_ g_ a\", 3, step = 3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c e_ g_ a e_ g_ a c' g_ a c' e_' a c' e_' g_' note_arpeggiate(\"c a g_ e_\", 3, step = -3) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c a g_ e_ a, g_ e_ c g_, e_ c a, e_, c a, g_,"},{"path":"https://leonawicz.github.io/tabr/reference/n_measures.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize rhythm and time of music objects — n_measures","title":"Summarize rhythm and time of music objects — n_measures","text":"functions assist summarizing temporal data music objects.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/n_measures.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize rhythm and time of music objects — n_measures","text":"","code":"n_measures(x)  n_beats(x, unit = 4)  steps_per_measure(x)  bpm(x, unit = 4, tempo = NULL)  seconds(x, tempo = NULL)  seconds_per_measure(x, tempo = NULL)  seconds_per_step(x, tempo = NULL)  steps_start_time(x, tempo = NULL)"},{"path":"https://leonawicz.github.io/tabr/reference/n_measures.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize rhythm and time of music objects — n_measures","text":"x note info music object. unit character, equivalent integer. beat unit. See details. tempo character, LilyPond format tempo, e.g., \"4 = 120\" 120 quarter note beats per minute.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/n_measures.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize rhythm and time of music objects — n_measures","text":"depends function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/n_measures.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize rhythm and time of music objects — n_measures","text":"functions also work simpler noteinfo class, though functions require provide additional arguments. Functions deal real time require known tempo, music objects . simpler note info object contain information. can provide value tempo argument functions. overrides tempo x music object. reason use tempo provide one x note info object. default tempo = NULL, case derive value music object return error note info objects. n_measures() gives total number measures covered timesteps. Functions providing number beats beats per minute take unit, defaulting 4 quarter note beats. unit can even beat, triplet beat, dotted, double dotted beat, \"t32\" 1. number timesteps starting measure obtained steps_per_measure().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/n_measures.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize rhythm and time of music objects — n_measures","text":"","code":"a <- notate(\"t8x\", \"Start here\") notes <- \"a, b, c d e f g# a r ac'e' a c' e' c' r*3 ac'e'~ ac'e'\" info <- paste(a, \"t8x t8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1\") info <- as_noteinfo(info) x <- as_music(notes, info)  n_measures(info) # fraction indicates incomplete final measure #> [1] 5.375 n_measures(x) #> [1] 5.375  n_beats(x) #> [1] 21.5 n_beats(x, 1) #> [1] 5.375 n_beats(x, \"t16\") #> [1] 129  bpm(x) #> [1] 120 bpm(x, \"t8\") #> [1] 360  seconds(x) #> [1] 10.75 seconds(info, \"4 = 120\") #> [1] 10.75 seconds(info, \"2 = 60\") #> [1] 10.75 seconds(x, \"4 = 100\") #> [1] 12.9  steps_per_measure(x) #> # A tibble: 5 × 2 #>   measure steps #>     <int> <int> #> 1       1     8 #> 2       2     2 #> 3       3     4 #> 4       4     4 #> 5       5     1 seconds_per_measure(x) #> [1] 2 seconds_per_step(x) #>  [1] 0.1666667 0.1666667 0.1666667 0.1250000 0.8750000 0.1250000 0.1250000 #>  [8] 1.0000000 1.0000000 0.7500000 0.2500000 0.5000000 0.5000000 0.2500000 #> [15] 0.2500000 0.2500000 0.2500000 2.0000000 2.0000000 steps_start_time(x) #>  [1] 0.0000000 0.1666667 0.3333333 0.5000000 0.6250000 1.5000000 1.6250000 #>  [8] 1.7500000 2.7500000 3.7500000 4.5000000 4.7500000 5.2500000 5.7500000 #> [15] 6.0000000 6.2500000 6.5000000 6.7500000 8.7500000"},{"path":"https://leonawicz.github.io/tabr/reference/phrase-checks.html","id":null,"dir":"Reference","previous_headings":"","what":"Phrase validation and coercion — phrase-checks","title":"Phrase validation and coercion — phrase-checks","text":"helper functions add validation checks phrase candidate phrase objects.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase-checks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Phrase validation and coercion — phrase-checks","text":"","code":"as_phrase(phrase)  phrasey(phrase)  notify(phrase)  phrase_notes(phrase, collapse = TRUE)  phrase_info(phrase, collapse = TRUE, annotations = TRUE)  phrase_strings(phrase, collapse = FALSE)  notable(phrase)"},{"path":"https://leonawicz.github.io/tabr/reference/phrase-checks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Phrase validation and coercion — phrase-checks","text":"phrase phrase object character string (candidate phrase). collapse logical, collapse result single string ready phrase construction. annotations logical, strip text annotations note info converted phrase().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase-checks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Phrase validation and coercion — phrase-checks","text":"see details function's purpose return value.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase-checks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Phrase validation and coercion — phrase-checks","text":"Use functions caution. intended strictness perfection. phrasey() checks whether object weakly phrase-like returns TRUE FALSE. can used safeguard obvious cases phrase() containing valid phrase syntax programming. However, may also limiting. Use wear sensible. as_phrase() coerces object phrase object possible. function performs internal phrasey() check. notify() attempts decompose phrase object back original input vectors consisting notes, note info, optionally, instrument string numbering. successful, returns tibble data frame columns: notes, info, string. Unless decomposing simple phrases, function likely reveal limitations. Complex phrase objects constructed originally phrase() can challenging deconstruct one one manner. Information may lost, garbled, function may fail. example, function advanced enough unravel repeat notation tuplets. notable() returns TRUE FALSE regarding whether phrase can converted back character string inputs, necessarily complete correctness, without simple failure.checks phrasiness. tries call notify() returns FALSE gracefully call throws exception.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase-checks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Phrase validation and coercion — phrase-checks","text":"","code":"# Create a list of phrase objects p1 <- phrase(\"c ec'g' ec'g'\", \"4 4 2\") # no string numbers (not recommended) p2 <- phrase(\"c ec4g4 ec4g4\", \"4 4 2\") # same as above p3 <- phrase(\"c b, c\", \"4. 8( 8)\", \"5 5 5\") # direction implies hammer on p4 <- phrase(\"b2 c d\", \"4( 4)- 2\", \"5 5 5\") # hammer and slide p5 <- phrase(\"c ec'g'~ ec'g'\", 1, \"5 432 432\") # tied chord x <- list(p1, p2, p3, p4, p5)  # Check if phrases and strings are phrasey sapply(x, phrasey) #> [1] TRUE TRUE TRUE TRUE TRUE sapply(as.character(x), phrasey, USE.NAMES = FALSE) #> [1] TRUE TRUE TRUE TRUE TRUE  # Coerce character string representation to phrase and compare with original y <- lapply(as.character(x), as_phrase) identical(x, y) #> [1] TRUE  # Check if notable sapply(x, notable) #> [1] TRUE TRUE TRUE TRUE TRUE notable(p(\"a b c\", 1)) #> [1] TRUE notable(\"a b x\") # note: not constructible as a phrase in the first place #> [1] FALSE  # Notify phrases d <- do.call(rbind, lapply(x, notify)) d #> # A tibble: 15 × 3 #>    notes    info  string #>    <chr>    <chr> <chr>  #>  1 c        4     NA     #>  2 ec'g'    4     NA     #>  3 ec'g'    2     NA     #>  4 c        4     NA     #>  5 ec'g'    4     NA     #>  6 ec'g'    2     NA     #>  7 c        4.    5      #>  8 b,       8(    5      #>  9 c        8)    5      #> 10 b,       4(    5      #> 11 c        4)-   5      #> 12 d        2     5      #> 13 c        1     5      #> 14 e~c'~g'~ 1     432    #> 15 ec'g'    1     432     # Wrappers around notify extract components, default to collapsed strings phrase_notes(p5) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c <e~c'~g'~> <ec'g'> phrase_info(p5) #> <Note info string> #>   Format: space-delimited time #>   Values: 1 1 1 phrase_strings(p5) #> [1] \"5\"   \"432\" \"432\"  # If phrase decomposition works well, coercion is one to one x2 <- lapply(x,   function(x) p(phrase_notes(x), phrase_info(x), phrase_strings(x)) ) identical(x, x2) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/phrase.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a musical phrase — phrase","title":"Create a musical phrase — phrase","text":"Create musical phrase character strings define notes, note metadata, optionally explicit strings fretted. latter can used ensure proper tablature layout.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a musical phrase — phrase","text":"","code":"phrase(notes, info = NULL, string = NULL, bar = NULL)  p(notes, info = NULL, string = NULL, bar = NULL)"},{"path":"https://leonawicz.github.io/tabr/reference/phrase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a musical phrase — phrase","text":"notes, info noteworthy note info strings. info = NULL, assumed notes refers music object string formatted . string space-delimited character string vector (integer vector simple string numbers). optional argument specifies instrument strings play specific timestep. Otherwise NULL. bar character NULL (default). Terminates phrase bar bar check. See details. Also see LilyPond help documentation bar notation valid options.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a musical phrase — phrase","text":"phrase.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/phrase.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a musical phrase — phrase","text":"phrase object combines valid string notes corresponding valid string note info. required note info time, information can included well. need input existing noteworthy class object noteinfo class object, inputs must valid thus coercible classes. similar music class works. difference phrase objects used create LilyPond syntax analogous music object contains. Note convert music object phrase object, changing contexts. phrase object simplest LilyPond-format music structure. Coercion phrase() strips attributes music object retains notes, note info string numbers. See help documentation noteworthy, noteinfo, music classes understanding input data structures. function p() convenient shorthand wrapper phrase(). string provided bar, interpreted LilyPond bar notation. E.g., bar = \"|\" adds LilyPond syntax \\bar \"|\" end phrase. bar check desired, use bar = TRUE. FALSE treated NULL completeness.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/phrase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a musical phrase — phrase","text":"","code":"phrase(\"c ec'g' ec'g'\", \"4- 4 2\") # no string arg (not recommended for tabs) #> <Musical phrase> #> <c>4\\glissando <e c' g'>4 <e c' g'>2 phrase(\"c ec4g4 ec4g4\", \"4 4 2\") # same as above #> <Musical phrase> #> <c>4 <e c' g'>4 <e c' g'>2 phrase(\"c b, c\", \"4. 8( 8)\", \"5 5 5\") # direction implies hammer on #> <Musical phrase> #> <c\\5>4. <b,\\5>8( <c\\5>8) phrase(\"b2 c d\", \"4( 4)- 2\", \"5 5 5\") # hammer and slide #> <Musical phrase> #> <b,\\5>4( <c\\5>4)\\glissando <d\\5>2  phrase(\"c ec'g' ec'g'\", \"1 1 1\", \"5 432 432\") #> <Musical phrase> #> <c\\5>1 <e\\4 c'\\3 g'\\2>1 <e\\4 c'\\3 g'\\2>1 p(\"c ec'g' ec'g'\", 1, \"5 4 4\") # same as above #> <Musical phrase> #> <c\\5>1 <e\\4 c'\\3 g'\\2>1 <e\\4 c'\\3 g'\\2>1   n <- \"a, b, c d e f g e f g a~ a\" i <- \"8- 8 8 8-. t8( t8)( t8) t16( t16)( t16) 8 1\" m <- as_music(n, i)  x <- p(n, i) x #> <Musical phrase> #> <a,>8\\glissando <b,>8 <c>8 <d>8-. \\tuplet 3/2 4 { <e>8( <f>8)( <g>8) } \\tuplet 3/2 8 { <e>16( <f>16)( <g>16) } <a~>8 <a>1 identical(x, p(m)) #> [1] TRUE  x <- \"a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\" p(x) #> <Musical phrase> #> <a,\\5>4 <a,\\5>4 <a,\\5>4 <a,\\5>4 <a,\\5>4 <b,\\5>4\\glissando <c\\5>4 <c~\\5 g~\\4 c'~\\3 e'~\\2>4 <c\\5 g\\4 c'\\3 e'\\2>1 <e'\\2>4 <c'\\3>4 <g\\4>4 <c\\5>4 <c\\5 e'\\1>1 identical(p(x), p(as_music(x))) #> [1] TRUE  x <- p(\"a b\", 2, bar = \"|.\") x2 <- pc(p(\"a b\", 2), '\\\\bar \"|.\"') identical(x, x2) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/pitch_freq.html","id":null,"dir":"Reference","previous_headings":"","what":"Pitch conversions — pitch_freq","title":"Pitch conversions — pitch_freq","text":"Convert pitches, chords, semitones frequencies.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_freq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pitch conversions — pitch_freq","text":"","code":"pitch_freq(notes, a4 = 440)  pitch_semitones(notes)  chord_freq(notes, a4 = 440)  chord_semitones(notes)  freq_pitch(   freq,   octaves = c(\"tick\", \"integer\"),   accidentals = c(\"flat\", \"sharp\"),   collapse = FALSE,   a4 = 440 )  freq_semitones(freq, a4 = 440)  semitone_pitch(   semitones,   octaves = c(\"tick\", \"integer\"),   accidentals = c(\"flat\", \"sharp\"),   collapse = FALSE )  semitone_freq(semitones, a4 = 440)"},{"path":"https://leonawicz.github.io/tabr/reference/pitch_freq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pitch conversions — pitch_freq","text":"notes character, noteworthy string, space-delimited vector individual entries. See details. a4 fixed frequency middle C, typically 440 Hz. freq numeric vector, frequencies Hz. octaves NULL character, \"tick\" \"integer\" octave numbering result. accidentals NULL character, represent accidentals, \"flat\" \"sharp\". collapse logical, collapse result single string. key style. semitones integer values pitches.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_freq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pitch conversions — pitch_freq","text":"integer, numeric noteworthy vector","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_freq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pitch conversions — pitch_freq","text":"Frequencies Hertz. Values based 12-tone equal-tempered scale. converting arbitrary frequency pitch, rounded nearest pitch. pitch_freq() pitch_semitones() strictly accept single notes noteworthy strings return numeric vectors. chord_freq() chord_semitones() accept noteworthy string always return list. provided functions type-safe. See examples.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_freq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pitch conversions — pitch_freq","text":"","code":"x <- \"a e4 a4 e5 a5\" y <- pitch_freq(x) y #> [1] 220.0000 329.6276 440.0000 659.2551 880.0000  freq_semitones(y) #> [1] 57 64 69 76 81 freq_pitch(y) #> <Noteworthy string> #>   Format: vectorized time #>   Values: a e' a' e'' a''  identical(as_noteworthy(x), freq_pitch(y, \"integer\", collapse = TRUE)) #> [1] TRUE  s <- pitch_semitones(x) s #> [1] 57 64 69 76 81 semitone_pitch(s) #> <Noteworthy string> #>   Format: vectorized time #>   Values: a e' a' e'' a''  x <- \"a, a,c#e\" chord_semitones(x) #> $`a,` #> [1] 45 #>  #> $`a,c#e` #> [1] 45 49 52 #>  chord_freq(x) #> $`a,` #> [1] 110 #>  #> $`a,c#e` #> [1] 110.0000 138.5913 164.8138 #>"},{"path":"https://leonawicz.github.io/tabr/reference/pitch_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a sequence from pitch notation — pitch_seq","title":"Create a sequence from pitch notation — pitch_seq","text":"Create noteworthy string sequence consecutive pitches.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a sequence from pitch notation — pitch_seq","text":"","code":"pitch_seq(x, y, key = NULL, scale = NULL, format = c(\"space\", \"vector\"))"},{"path":"https://leonawicz.github.io/tabr/reference/pitch_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a sequence from pitch notation — pitch_seq","text":"x character, valid pitch notation, e.g., \"a2\" \",\". y character, x sequence x:y. number, length sequence x sign y determines direction. key character, key signature diatonic sequence. key = NULL (default) results chromatic sequence. scale character, want use different scale conjunction key/root note, can provide , e.g., scale = \"harmonic minor\". Ignored key = NULL. format character, timestep delimiter format, \"space\" \"vector\".","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a sequence from pitch notation — pitch_seq","text":"noteworthy","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a sequence from pitch notation — pitch_seq","text":"Note pitches resulting defined sequence must semitone range 0-131 error thrown. using chromatic sequence x (y also pitch) part key signature scale, sequence internally bound. See examples. Format accidentals result prioritized scale key, key scale given, x (y also pitch), finally defaults flats ambiguous.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/pitch_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a sequence from pitch notation — pitch_seq","text":"","code":"# chromatic sequence (default) pitch_seq(\"a,\", 13) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, b_, b, c d_ d e_ e f g_ g a_ a pitch_seq(\"c5\", -2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c5 b4 pitch_seq(\"c\", \"b\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d_ d e_ e f g_ g a_ a b_ b  # diatonic sequence pitch_seq(\"c\", 8, key = \"c\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d e f g a b c' pitch_seq(\"c\", 8, \"am\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c d e f g a b c' pitch_seq(\"c#,\", \"a#'\", \"am\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d, e, f, g, a, b, c d e f g a b c' d' e' f' g' a'  # combine with alternative scale pitch_seq(\"a\", 8, \"am\", \"harmonic minor\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b c' d' e' f' g#' a'"},{"path":"https://leonawicz.github.io/tabr/reference/plot_fretboard.html","id":null,"dir":"Reference","previous_headings":"","what":"Chord and fretboard diagram plots — plot_fretboard","title":"Chord and fretboard diagram plots — plot_fretboard","text":"Create fretboard diagram single chord general progression.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_fretboard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chord and fretboard diagram plots — plot_fretboard","text":"","code":"plot_fretboard(   string,   fret,   labels = NULL,   mute = FALSE,   label_size = 10,   label_color = \"white\",   point_size = 10,   point_color = \"black\",   point_fill = \"black\",   group = NULL,   horizontal = FALSE,   left_handed = FALSE,   fret_range = NULL,   fret_labels = NULL,   fret_offset = FALSE,   accidentals = c(\"flat\", \"sharp\"),   tuning = \"standard\",   show_tuning = FALSE,   asp = NULL,   base_size = 20 )  plot_chord(   chord,   labels = NULL,   label_size = 10,   label_color = \"white\",   point_size = 10,   point_color = \"black\",   point_fill = \"black\",   group = NULL,   horizontal = FALSE,   left_handed = FALSE,   fret_range = NULL,   fret_labels = NULL,   fret_offset = FALSE,   accidentals = c(\"flat\", \"sharp\"),   tuning = \"standard\",   show_tuning = FALSE,   asp = NULL,   base_size = 20 )"},{"path":"https://leonawicz.github.io/tabr/reference/plot_fretboard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chord and fretboard diagram plots — plot_fretboard","text":"string integer space-delimited character string; instrument string numbers. fret integer space-delimited character string; fret numbers. labels NULL character, optional vector text labels, must one every point; just special value \"notes\". mute logical vector specific integer indices, notes mute. See details. label_size numeric, size fretted note labels. label_color character, label color. point_size numeric, size fretted note points. point_color character, point color. point_fill character, point fill color. group optional vector facet . horizontal logical, directional orientation. left_handed logical, handedness orientation. fret_range fret limits, NULL, overrides limits derived fret. fret_labels integer, vector fret number labels fret axis. See details. fret_offset logical set TRUE shift fret axis number labels (present) directly next fret aligned circles behind fret. accidentals character, labels = \"notes\" represent accidentals: \"flat\" \"sharp\". tuning explicit tuning, e.g., \"e, , d g b e'\", pre-defined tuning. See details. show_tuning logical, show tuning string string axis. asp numeric, aspect ratio, overrides default aspect ratio derived number strings frets. base_size base size ggplot2::theme_void(). chord character, single chord given fret notation. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_fretboard.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chord and fretboard diagram plots — plot_fretboard","text":"ggplot object","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_fretboard.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chord and fretboard diagram plots — plot_fretboard","text":"functions development subject change. return ggplot object. Use plot_chord() create fretboard diagram specific chord. plot_chord() accepts character string simple fretboard format, e.g., chord = \"xo221o\". Zero allowed place \"o\". works spaces semicolons detected. function checks spaces first, semicolons, split fret numbers. mix formats. example, can use chord = \"xo221o\", chord = \"x 8 10 10 9 8\" chord = \"x;8;10;10;9;8\". Trailing delimiters ignored (LilyPond format: \"x;8;10;10;9;8;\"). fewer fret values strings instrument, inferred tuning, muted strings, x, inferred remaining lower-pitch strings. plot_fretboard() produces general fretboard diagram plot. intended scales, arpeggios patterns along fretboard. function, provide vectors string fret numbers. mute available applicable function; pass-plot_chord(). single chord diagrams, use plot_chord(). letter \"o\" also allowed fret open strings display lowest fret plotted. number 0 treated intent displaying corresponding position instrument neck. Number strings derived tuning. See tunings() pre-defined tunings examples explicit tunings. tuning affects point labels labels = \"notes\". Providing fret_labels overrides default (minimal) fret numbering behavior fret axis. intended integers. vector integers given sorted subset needed range frets appear plot. See example.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_fretboard.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chord and fretboard diagram plots — plot_fretboard","text":"","code":"# General patterns: scale shifting exercise string <- c(6, 6, 6, 5, 5, 5, 4, 4, 4, 4, 4, 3, 3, 3, 2, 2, 2, 1, 1, 1) fret <- \"2 4 5 2 4 5 2 4 6 7 9 6 7 9 7 9 10 7 9 10\" # string input accepted plot_fretboard(string, fret, labels = \"notes\", fret_offset = TRUE)  plot_fretboard(string, fret, fret_labels = c(3, 5, 7, 9, 12), show_tuning = TRUE)   # open and muted strings on shifted general fretboard layout # try to use plot_chord() if more suitable plot_fretboard(\"6 5 4 3\", \"o 9 10 12\", mute = 2, show_tuning = TRUE)   # Single chord diagrams # open chord idx <- c(1, 1, 2, 2, 2, 1) fill <- c(\"white\", \"black\")[idx] lab_col <- c(\"black\", \"white\")[idx] plot_chord(\"xo221o\", \"notes\", label_color = lab_col, point_fill = fill)   # moveable chord plot_chord(\"355433\", horizontal = TRUE, show_tuning = TRUE)   # leading x inferred; same as plot_chord(\"xxo321\") plot_chord(\"o231\", fret_labels = 3)  plot_chord(\"10 12 13 11\", show_tuning = TRUE)  plot_chord(\"o x 10 12 13 11\", fret_range = c(9, 14), fret_labels = c(9, 12))"},{"path":"https://leonawicz.github.io/tabr/reference/plot_music.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot sheet music snippet with LilyPond — plot_music","title":"Plot sheet music snippet with LilyPond — plot_music","text":"functions wrappers around render_music* functions. abstract process rendering sheet music snippet png loading rendered image back R displayed plot open graphics device inserted R Markdown code chunk.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_music.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot sheet music snippet with LilyPond — plot_music","text":"","code":"plot_music(   music,   clef = \"treble\",   tab = FALSE,   tuning = \"standard\",   string_names = NULL,   header = NULL,   paper = NULL,   colors = NULL,   transparent = FALSE,   res = 300 )  plot_music_tc(   music,   header = NULL,   paper = NULL,   colors = NULL,   transparent = FALSE,   res = 300 )  plot_music_bc(   music,   header = NULL,   paper = NULL,   colors = NULL,   transparent = FALSE,   res = 300 )  plot_music_tab(   music,   clef = NA,   tuning = \"standard\",   string_names = NULL,   header = NULL,   paper = NULL,   colors = NULL,   transparent = FALSE,   res = 300 )  plot_music_guitar(   music,   tuning = \"standard\",   string_names = NULL,   header = NULL,   paper = NULL,   colors = NULL,   transparent = FALSE,   res = 300 )  plot_music_bass(   music,   tuning = \"bass\",   string_names = FALSE,   header = NULL,   paper = NULL,   colors = NULL,   transparent = FALSE,   res = 300 )"},{"path":"https://leonawicz.github.io/tabr/reference/plot_music.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot sheet music snippet with LilyPond — plot_music","text":"music music object. clef character, include music staff given clef. NA suppress. See track() details. tab logical, include tablature staff. NA suppress. See track(). tuning character, string tuning, applies tablature. See track(). string_names label strings beginning tab staff. NULL (default) non-standard tunings , TRUE FALSE force completely. header named list arguments passed header LilyPond file. See lilypond() details. paper named list arguments LilyPond file page layout. See lilypond() details. colors named list LilyPond element color global overrides. See lilypond() details. transparent logical, transparent background intermediate png file. res numeric, resolution, png . Defaults 300.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_music.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot sheet music snippet with LilyPond — plot_music","text":"plot","code":""},{"path":"https://leonawicz.github.io/tabr/reference/plot_music.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot sheet music snippet with LilyPond — plot_music","text":"functions abstract away details process, making plot completely R. R displaying intermediary png file. LilyPond required engrave sheet music. R Markdown can alternatively render png using corresponding render_music* function place document explicitly using knitr::include_graphics(). See render_music() details.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/plot_music.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot sheet music snippet with LilyPond — plot_music","text":"","code":"x <- \"a,4;5*5 b,4- c4 cgc'e'~4 cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\" x <- as_music(x)  y <- \"a,,4;3*5 b,,4- c,4 c,g,c~4 c,g,c1 c4;1 g,;2 c,;3 g,;2 c,c1;31\" y <- as_music(y)  if (FALSE) { # \\dontrun{ if(tabr_options()$lilypond != \"\"){ # requires LilyPond installation   plot_music(x)   plot_music(x, \"treble_8\", tab = TRUE)    plot_music_tc(x)   plot_music_bc(x)    plot_music_tab(x)   plot_music_guitar(x)   plot_music_bass(y) } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/ratio_to_cents.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between chord frequency ratios and cents — ratio_to_cents","title":"Convert between chord frequency ratios and cents — ratio_to_cents","text":"Convert frequency ratios logarithmic cents","code":""},{"path":"https://leonawicz.github.io/tabr/reference/ratio_to_cents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between chord frequency ratios and cents — ratio_to_cents","text":"","code":"ratio_to_cents(x, y = NULL)  cents_to_ratio(x)"},{"path":"https://leonawicz.github.io/tabr/reference/ratio_to_cents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between chord frequency ratios and cents — ratio_to_cents","text":"x vector ratios y = NULL, otherwise frequencies. Cents cents_to_ratio(). y NULL, frequencies ratios given y / x.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/ratio_to_cents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between chord frequency ratios and cents — ratio_to_cents","text":"numeric","code":""},{"path":"https://leonawicz.github.io/tabr/reference/ratio_to_cents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between chord frequency ratios and cents — ratio_to_cents","text":"","code":"ratio_to_cents(c(0.5, 1, 1.5, 2)) #> [1] -1200.000     0.000   701.955  1200.000 cents_to_ratio(c(-1200, 0, 701.955, 1200)) #> [1] 0.5 1.0 1.5 2.0"},{"path":"https://leonawicz.github.io/tabr/reference/read_midi.html","id":null,"dir":"Reference","previous_headings":"","what":"Read, inspect and convert MIDI file contents — read_midi","title":"Read, inspect and convert MIDI file contents — read_midi","text":"Read MIDI file data frame inspect music data supporting functions.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/read_midi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read, inspect and convert MIDI file contents — read_midi","text":"","code":"read_midi(file, ticks_per_qtr = 480)  midi_metadata(x)  midi_notes(x, channel = NULL, track = NULL, noteworthy = TRUE)  midi_time(x)  midi_key(x)  ticks_to_duration(x, ticks_per_qtr = 480)  duration_to_ticks(x, ticks_per_qtr = 480)"},{"path":"https://leonawicz.github.io/tabr/reference/read_midi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read, inspect and convert MIDI file contents — read_midi","text":"file character, path MIDI file. ticks_per_qtr ticks per quarter note. Used compute durations MIDI file ticks. x data frame returned read_midi(). integer vector ticks_to_duration(); character vector (may space-delimited string) duration_to_ticks(). channel, track integer, filter rows channel track. noteworthy logical, convert noteworthy noteinfo data.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/read_midi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read, inspect and convert MIDI file contents — read_midi","text":"tibble data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/read_midi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Read, inspect and convert MIDI file contents — read_midi","text":"read_midi() function wraps around tuneR::readMidi() Uwe Ligges Johanna Mielke. midi_notes() work progress, converts MIDI data noteworthy strings note info formats. makes easy analyze, transform edit music data well render sheet music new MIDI file. read_midi() parse ticks per quarter note MIDI file input time. must specified ticks_per_qtr.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/read_midi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read, inspect and convert MIDI file contents — read_midi","text":"","code":"ticks_to_duration(c(120, 160)) #> [1] \"16\" \"t8\" ticks_to_duration(c(128, 192, 512), ticks_per_qtr = 384) #> [1] \"t8\" \"8\"  \"t2\" duration_to_ticks(c(\"t8\", \"8\", \"8.\", \"8..\")) #> [1] 160 240 360 420 duration_to_ticks(c(\"t8 8 8. 8..\"), ticks_per_qtr = 384) #> [1] 128 192 288 336  if (FALSE) { # \\dontrun{ file <- system.file(\"example2.mid\", package = \"tabr\") if(require(\"tuneR\")){   x <- read_midi(file, ticks_per_qtr = 384)   midi_metadata(x)   midi_time(x)   midi_key(x)   midi_notes(x, channel = 0, noteworthy = FALSE)    (x <- midi_notes(x, channel = 0))   (x <- as_music(x$pitch, x$duration))    # requires LilyPond installation   if(tabr_options()$lilypond != \"\"){     out <- file.path(tempdir(), \"out.pdf\")     phrase(x) |> track_bc() |> score() |> tab(out, details = FALSE)   } } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/render_chordchart.html","id":null,"dir":"Reference","previous_headings":"","what":"Render a chord chart with LilyPond — render_chordchart","title":"Render a chord chart with LilyPond — render_chordchart","text":"Render standalone chord chart chord fretboard diagrams LilyPond set chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/render_chordchart.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render a chord chart with LilyPond — render_chordchart","text":"","code":"render_chordchart(   chords,   file,   size = 1.2,   header = NULL,   paper = NULL,   colors = NULL,   crop_png = TRUE,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   details = FALSE )"},{"path":"https://leonawicz.github.io/tabr/reference/render_chordchart.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render a chord chart with LilyPond — render_chordchart","text":"chords named character vector valid formatting LilyPond chord names values. See examples. file output file. size numeric, size fretboard diagrams (relative paper font size). Use scale diagrams . header named list arguments passed header LilyPond file. See details. paper named list arguments LilyPond file page layout. See details. colors reserved; yet implemented function. crop_png logical, see lilypond() details. transparent logical, transparent background, png . res numeric, resolution, png . transparent = TRUE may fail res exceeds ~150. keep_ly logical, keep intermediate LilyPond file. details logical, set TRUE print LilyPond log output console. Windows .","code":""},{"path":"https://leonawicz.github.io/tabr/reference/render_chordchart.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render a chord chart with LilyPond — render_chordchart","text":"writes files disk","code":""},{"path":"https://leonawicz.github.io/tabr/reference/render_chordchart.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Render a chord chart with LilyPond — render_chordchart","text":"function uses generates LilyPond template displaying fretboard diagram chart. passes file LilyPond rendering. plot specific fretboard diagrams R using ggplot greater control, use plot_fretboard(). options paper include following following default values provided. textheight = 220 linewidth = 150 indent = 0 fontsize = 10 page_numbers = FALSE print_first_page_number = TRUE first_page_number = 1 fontsize controls global font size. want scale size fretboard diagrams use size argument rather paper value. Note chord chart output must fit single page. full set chord diagrams fit one page diagrams clipped rendered output. Use size keep output one page make multiple sheets separately.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/render_chordchart.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render a chord chart with LilyPond — render_chordchart","text":"","code":"if (FALSE) { # \\dontrun{ suppressPackageStartupMessages(library(dplyr))  chords <- filter(   guitarChords, root %in% c(\"c\", \"f\") & id %in% c(\"7\", \"M7\", \"m7\") &   !grepl(\"#\", notes) & root_fret <= 12) |>   arrange(root, id) chords <- setNames(chords$fretboard, chords$lp_name) head(chords)  # requires LilyPond installation if(tabr_options()$lilypond != \"\"){   outfile <- file.path(tempdir(), \"out.pdf\")   hdr <- list(     title = \"Dominant 7th, major 7th and minor 7th chords\",     subtitle = \"C and F root\"   )   render_chordchart(chords, outfile, 2, hdr, list(textheight = 175)) } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/render_music.html","id":null,"dir":"Reference","previous_headings":"","what":"Render sheet music snippet with LilyPond — render_music","title":"Render sheet music snippet with LilyPond — render_music","text":"Render sheet music/tablature snippet music object LilyPond.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/render_music.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render sheet music snippet with LilyPond — render_music","text":"","code":"render_music(   music,   file,   clef = \"treble\",   tab = FALSE,   tuning = \"standard\",   string_names = NULL,   header = NULL,   paper = NULL,   midi = FALSE,   colors = NULL,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE )  render_music_tc(   music,   file,   header = NULL,   paper = NULL,   midi = FALSE,   colors = NULL,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE )  render_music_bc(   music,   file,   header = NULL,   paper = NULL,   midi = FALSE,   colors = NULL,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE )  render_music_tab(   music,   file,   clef = NA,   tuning = \"standard\",   string_names = NULL,   header = NULL,   paper = NULL,   midi = FALSE,   colors = NULL,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE )  render_music_guitar(   music,   file,   tuning = \"standard\",   string_names = NULL,   header = NULL,   paper = NULL,   midi = FALSE,   colors = NULL,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE )  render_music_bass(   music,   file,   tuning = \"bass\",   string_names = NULL,   header = NULL,   paper = NULL,   midi = FALSE,   colors = NULL,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE )"},{"path":"https://leonawicz.github.io/tabr/reference/render_music.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render sheet music snippet with LilyPond — render_music","text":"music music object. file character, output file ending .pdf .png. clef character, include music staff given clef. NA suppress. See track() details. tab logical, include tablature staff. NA suppress. See track(). tuning character, string tuning, applies tablature. See track(). string_names label strings beginning tab staff. NULL (default) non-standard tunings , TRUE FALSE force completely. header named list arguments passed header LilyPond file. See lilypond() details. paper named list arguments LilyPond file page layout. See lilypond() details. midi logical, also output corresponding MIDI file. colors named list LilyPond element color global overrides. See lilypond() details. transparent logical, transparent background, png . res numeric, resolution, png . transparent = TRUE may fail res exceeds ~150. keep_ly logical, keep intermediary LilyPond file. simplify logical, uses simplify_phrase() convert simpler, efficient LilyPond syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/render_music.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render sheet music snippet with LilyPond — render_music","text":"nothing returned; file written.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/render_music.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Render sheet music snippet with LilyPond — render_music","text":"functions allow render short, simple snippets sheet music directly music object. useful need build phrases tracks full score. treat music objects single voice single track. simplifies possible output convenient need. functions abstract following pipeline, music |> phrase() |> track() |> score() |> render_*() simple edge case directly expose relevant arguments. header list elements character strings. options header include following. title subtitle composer album arranger instrument meter opus piece poet copyright tagline paper list elements numeric except page_numbers print_first_page_number, logical. page_numbers = FALSE suppresses page numbering. page_numbers = TRUE, can set print_first_page_number = FALSE suppress printing first page number. first_page_number number first page, defaulting 1, determines subsequent page numbers. arguments correspond LilyPond paper block variables. options paper include following following default values provided. textheight = 220 linewidth = 150 indent = 0 fontsize = 20 page_numbers = FALSE print_first_page_number = TRUE first_page_number = 1 textheight = 150 default, music snippet rendering, value must provided explicitly via paper rendering png. Otherwise png outputs height cropped automatically rather remaining full page. See lilypond() details. Passing arguments header can completely partially prevent cropping directions, must done manually linewidth textheight. based underlying LilyPond behavior. music contains lyrics rests note sequence, note-lyric alignment maintained automatically functions remove lyric timesteps corresponding rests prior sending LilyPond. LilyPond skips rests engraving lyrics expects shortened lyrics sequence comparison tabr matches timestep including rests. contrast track(), shorten lyrics object prior combining phrase object rests.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/render_music.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render sheet music snippet with LilyPond — render_music","text":"","code":"x <- \"a,4;5*5 b,- c cgc'e'~ cgc'e'1 e'4;2 c';3 g;4 c;5 ce'1;51\" x <- as_music(x)  y <- \"a,,4;3*5 b,,- c, c,g,c~ c,g,c1 c4;1 g,;2 c,;3 g,;2 c,c1;31\" y <- as_music(y)  z <- as_music(\"a,4 b, r c~ c2 d\", lyrics = as_lyrics(\"A2 B2 . C3 . D3\"))  if (FALSE) { # \\dontrun{ if(tabr_options()$lilypond != \"\"){ # requires LilyPond installation   outfile <- file.path(tempdir(), \"out.pdf\")   render_music(x, outfile)    outfile <- file.path(tempdir(), \"out.png\")   render_music(x, outfile, \"treble_8\", tab = TRUE)    render_music_tc(x, outfile)   render_music_bc(x, outfile)    render_music_tab(x, outfile)   render_music_guitar(x, outfile)   render_music_bass(y, outfile)    # lyrics example   render_music_guitar(z, outfile) } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/repeats.html","id":null,"dir":"Reference","previous_headings":"","what":"Repeat phrases — repeats","title":"Repeat phrases — repeats","text":"Create repeat section LilyPond readable format.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/repeats.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Repeat phrases — repeats","text":"","code":"rp(phrase, n = 1)  pct(phrase, n = 1, counter = FALSE, step = 1, reset = TRUE)  volta(phrase, n = 1, endings = NULL, silent = FALSE)"},{"path":"https://leonawicz.github.io/tabr/reference/repeats.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Repeat phrases — repeats","text":"phrase phrase object equivalent string repeated. n integer, number repeats phrase (one less total number plays). counter logical, TRUE, print percent repeat counter staff, applies measure repeats two repeats (n > 2). step integer, print measure percent repeat counter staff every step measures counter = TRUE. reset logical, percent repeat counter step settings applied single pct() call reset afterward. reset = FALSE, settings left open apply subsequent percent repeat sections track. endings single phrase list phrases, alternate endings. silent TRUE, text printed staff beginning volta section. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/repeats.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Repeat phrases — repeats","text":"phrase.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/repeats.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Repeat phrases — repeats","text":"functions wraps phrase object character string LilyPond repeat syntax. basic rp() basic wrapping LilyPond unfold repeat tag around phrase. repeats phrase n times, displayed engraved sheet music fully written literal propagation phrase repeat notation used reduce redundant presentation. next pct(), wraps percent() repeat tag around phrase. displayed sheet music percent repeat notation whose specific notation changes based length repeated section music, used beats whole measures. volta() wraps phrase volta() repeat tag, used long repeats one full measures bars music, optionally alternate endings. Note basic strings still interpretable valid musical phrase LilyPond strings coerced phrase class functions. example, one-measure rest, \"r1\", need phrase object work functions, character string explicitly written valid LilyPond syntax. always, see LilyPond documentation familiar LilyPond syntax. VOLTA REPEAT: silent = TRUE indication number plays staff start volta section. otherwise happens automatically number repeats greater one alternate endings included (already numbered). override creates ambiguity , important use multiple staves present another staff already displays text regarding number plays. prevents printing text every staff. PERCENT REPEAT: indicated parameter descriptions, arguments counter step apply full measures bars music. apply shorter beats repeated using pct().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/repeats.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Repeat phrases — repeats","text":"","code":"x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 432 432\") e1 <- phrase(\"a\", 1, 5) # ending 1 e2 <- phrase(\"b\", 1, 5) # ending 2  rp(x) # simple unfolded repeat, one repeat or two plays #> <Musical phrase> #> \\repeat unfold 2 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 } #>  rp(x, 3) # three repeats or four plays #> <Musical phrase> #> \\repeat unfold 4 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 } #>   pct(x) # one repeat or two plays #> <Musical phrase> #> \\repeat percent 2 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 } #>  pct(x, 9, TRUE, 5) # 10 plays, add counter every 5 steps #> <Musical phrase> #> \\set countPercentRepeats = ##t #> \\set repeatCountVisibility = #(every-nth-repeat-count-visible 5) #> \\repeat percent 10 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 } #> \\set countPercentRepeats = ##f #> \\set repeatCountVisibility = #(every-nth-repeat-count-visible 1) #>  pct(x, 9, TRUE, 5, FALSE) # as above, but do not reset counter settings #> <Musical phrase> #> \\set countPercentRepeats = ##t #> \\set repeatCountVisibility = #(every-nth-repeat-count-visible 5) #> \\repeat percent 10 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 } #>   volta(x) # one repeat or two plays #> <Musical phrase> #> \\repeat volta 2 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 | } #>  volta(x, 1, list(e1, e2)) # one repeat with alternate ending #> <Musical phrase> #> \\repeat volta 2 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 | } #> \\alternative { #>   { <a\\5>1 | } #>   { <b\\5>1 | } #> } volta(x, 4, list(e1, e2)) # multiple repeats with only one alternate ending #> <Musical phrase> #> \\repeat volta 5 { <c\\5>4 <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 | } #> \\alternative { #>   { <a\\5>1 | } #>   { <b\\5>1 | } #> } volta(x, 4) # no alternates, more than one repeat #> <Musical phrase> #> \\repeat volta 5 { <c\\5>4^\"Play 5 times.\" <e\\4 c'\\3 g'\\2>4 <e\\4 c'\\3 g'\\2>2 | } #>"},{"path":"https://leonawicz.github.io/tabr/reference/rest.html","id":null,"dir":"Reference","previous_headings":"","what":"Create rests — rest","title":"Create rests — rest","text":"Create multiple rests efficiently simple wrapper around rep() using times argument.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/rest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create rests — rest","text":"","code":"rest(x, n = 1)"},{"path":"https://leonawicz.github.io/tabr/reference/rest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create rests — rest","text":"x integer, duration. n integer, number repetitions.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/rest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create rests — rest","text":"character string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/rest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create rests — rest","text":"","code":"rest(c(1, 8), c(1, 4)) #> [1] \"r1 r8 r8 r8 r8\""},{"path":"https://leonawicz.github.io/tabr/reference/scale-deg.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale degrees and mappings — scale-deg","title":"Scale degrees and mappings — scale-deg","text":"functions assist mapping scale degrees, notes chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale-deg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale degrees and mappings — scale-deg","text":"","code":"scale_degree(   notes,   key = \"c\",   scale = \"diatonic\",   use_root = TRUE,   strict_accidentals = TRUE,   naturalize = FALSE,   roman = FALSE )  scale_note(deg, key = \"c\", scale = \"diatonic\", collapse = FALSE, ...)  note_in_scale(   notes,   key = \"c\",   scale = \"diatonic\",   use_root = TRUE,   strict_accidentals = TRUE )  chord_degree(   notes,   key = \"c\",   scale = \"diatonic\",   strict_accidentals = TRUE,   naturalize = FALSE,   roman = FALSE )  is_in_scale(notes, key = \"c\", scale = \"diatonic\", strict_accidentals = TRUE)"},{"path":"https://leonawicz.github.io/tabr/reference/scale-deg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale degrees and mappings — scale-deg","text":"notes character, string notes. key character, key signature (root note) scale, depending type scale. scale character, suffix supported scale_* function. use_root logical, use lowest pitch chord. Otherwise yield NA output. strict_accidentals logical, whether representation must match key scale. See details. naturalize logical, whether naturalize sharps flats obtaiuning scale degree. roman logical, return integer scale degrees Roman numerals. deg integer, roman class, character roman, scale degree. collapse logical, collapse result single string ready phrase construction. ... additional arguments passed scale function, e.g., sharp = FALSE scale_chromatic().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale-deg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale degrees and mappings — scale-deg","text":"integer, roman class roman = TRUE scale_degree(); character scale_note().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale-deg.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scale degrees and mappings — scale-deg","text":"Obtain scale degree note supported scale scale_degree(). function works noteworthy string. ignores octave numbering. Rests note explicitly scale return NA. deg greater number degrees scale, recycled, e.g., C major 8 starts C. default, flats sharps checked strictly scale. Setting strict_accidentals = FALSE convert flats sharps present, necessary based combination key signature scale. chromatic scale special case strict accidental always ignored. arbitrary combination valid key valid scale valid. example, key = \"\" scale = \"harmonic\" valid, key = \"\". note_in_scale() wrapper around scale_degree(). check full chords diatonic scale, see is_diatonic(). inverse scale_degree() scale_note(), obtaining note associated scale degree. done simply calling scale_* function indexing output directly, wrapper provided complement scale_degree(). Additionally, accepts common Roman numeral input degree. can roman class character string. Degrees return NA outside scale degree range.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/scale-deg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale degrees and mappings — scale-deg","text":"","code":"scale_degree(\"r c, e3 g~ g s g# ceg\") #> [1] NA  1  3  5  5 NA NA  1 note_in_scale(\"r c, e3 g~ g s g# ceg\") #> [1]    NA  TRUE  TRUE  TRUE  TRUE    NA FALSE  TRUE  scale_degree(\"c e g\", roman = TRUE) #> [1] I   III V    scale_degree(\"c c# d_ e\", key = \"d\") #> [1] NA  7 NA  2 scale_degree(\"c c# d_ e\", key = \"d\", strict_accidentals = FALSE) #> [1] NA  7  7  2  scale_degree(\"c, e_3 g' f#ac#\", use_root = FALSE) #> [1]  1 NA  5 NA scale_degree(\"c, e_3 g' f#ac#\", naturalize = TRUE) # lowest chord pitch: c# #> [1] 1 3 5 1  scale_degree(\"c# d_ e_' e4 f f# g\", key = \"c#\", scale = \"chromatic\") #> [1] 1 1 3 4 5 6 7  scale_note(1:3, key = \"am\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: a b c scale_note(c(1, 3, 8), \"d\", collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: d f# d all(sapply(list(4, \"IV\", as.roman(4)), scale_note) == \"f\") #> [1] TRUE  x <- \"d dfa df#a f#ac#\" chord_degree(x, \"d\") #> [[1]] #> [1] 1 #>  #> [[2]] #> [1]  1 NA  5 #>  #> [[3]] #> [1] 1 3 5 #>  #> [[4]] #> [1] 3 5 7 #>  is_in_scale(x, \"d\") #> [1]  TRUE FALSE  TRUE  TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/scale-helpers.html","id":null,"dir":"Reference","previous_headings":"","what":"Scale helpers — scale-helpers","title":"Scale helpers — scale-helpers","text":"Helper functions working musical scales.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale-helpers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scale helpers — scale-helpers","text":"","code":"scale_diatonic(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  scale_major(key = \"c\", collapse = FALSE, ignore_octave = FALSE)  scale_minor(key = \"am\", collapse = FALSE, ignore_octave = FALSE)  scale_harmonic_minor(key = \"am\", collapse = FALSE, ignore_octave = FALSE)  scale_hungarian_minor(key = \"am\", collapse = FALSE, ignore_octave = FALSE)  scale_melodic_minor(   key = \"am\",   descending = FALSE,   collapse = FALSE,   ignore_octave = FALSE )  scale_jazz_minor(key = \"am\", collapse = FALSE, ignore_octave = FALSE)  scale_chromatic(   root = \"c\",   collapse = FALSE,   sharp = TRUE,   ignore_octave = FALSE )"},{"path":"https://leonawicz.github.io/tabr/reference/scale-helpers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scale helpers — scale-helpers","text":"key character, key signature. collapse logical, collapse result single string ready phrase construction. ignore_octave logical, strip octave numbering scales rooted C. descending logical, return descending scale, available built-argument melodic minor scale, different direction. root character, root note. sharp logical, accidentals arbitrary scale output sharp rather flat.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale-helpers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Scale helpers — scale-helpers","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale-helpers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Scale helpers — scale-helpers","text":"valid key signatures, see keys().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/scale-helpers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Scale helpers — scale-helpers","text":"","code":"scale_diatonic(key = \"dm\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: d e f g a b_ c' scale_minor(key = \"dm\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: d e f g a b_ c' scale_major(key = \"d\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: d e f# g a b c#'  scale_chromatic(root = \"a\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: a, a#, b, c c# d d# e f f# g g#  scale_harmonic_minor(\"am\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: a, b, c d e f g# scale_hungarian_minor(\"am\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: a, b, c d# e f g#  identical(scale_melodic_minor(\"am\"), scale_jazz_minor(\"am\")) #> [1] TRUE rev(scale_melodic_minor(\"am\", descending = TRUE)) #> <Noteworthy string> #>   Format: vectorized time #>   Values: a, b, c d e f g scale_jazz_minor(\"am\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: a, b, c d e f# g#"},{"path":"https://leonawicz.github.io/tabr/reference/scale_chords.html","id":null,"dir":"Reference","previous_headings":"","what":"Diatonic chords — scale_chords","title":"Diatonic chords — scale_chords","text":"Obtain ordered sequence diatonic chords given scale, triads sevenths.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale_chords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diatonic chords — scale_chords","text":"","code":"scale_chords(   root = \"c\",   scale = \"major\",   type = c(\"triad\", \"seventh\"),   collapse = FALSE )"},{"path":"https://leonawicz.github.io/tabr/reference/scale_chords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diatonic chords — scale_chords","text":"root character, root note starting position scale. scale character, valid named scale, referring one existing scale_* functions. type character, type chord, triad seventh. collapse logical, collapse result single string ready phrase construction.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale_chords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diatonic chords — scale_chords","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/scale_chords.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diatonic chords — scale_chords","text":"","code":"scale_chords(\"c\", \"major\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <ceg> <dfa> <egb> <fac'> <gbd'> <ac'e'> <bd'f'> scale_chords(\"a\", \"minor\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <a,ce> <b,df> <ceg> <dfa> <egb> <fac'> <gbd'> scale_chords(\"a\", \"harmonic minor\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <a,ce> <b,df> <ceg#> <dfa> <eg#b> <fac'> <g#bd'> scale_chords(\"a\", \"melodic minor\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <a,ce> <b,df#> <ceg#> <df#a> <eg#b> <f#ac'> <g#bd'> scale_chords(\"a\", \"jazz minor\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <a,ce> <b,df#> <ceg#> <df#a> <eg#b> <f#ac'> <g#bd'> scale_chords(\"a\", \"hungarian minor\") #> <Noteworthy string> #>   Format: vectorized time #>   Values: <a,ce> <b,d#f> <ceg#> <d#fa> <eg#b> <fac'> <g#bd#'>  scale_chords(\"c\", \"major\", \"seventh\", collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <cegb> <dfac'> <egbd'> <fac'e'> <gbd'f'> <ac'e'g'> <bd'f'a'> scale_chords(\"a\", \"minor\", \"seventh\", collapse = TRUE) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <a,ceg> <b,dfa> <cegb> <dfac'> <egbd'> <fac'e'> <gbd'f'>"},{"path":"https://leonawicz.github.io/tabr/reference/score.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a music score — score","title":"Create a music score — score","text":"Create music score collection tracks.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/score.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a music score — score","text":"","code":"score(track, chords = NULL, chord_seq = NULL)"},{"path":"https://leonawicz.github.io/tabr/reference/score.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a music score — score","text":"track track table consisting one tracks. chords optional named list chords respective fingerings generated chord_set, inclusion top center chord diagram chart. chord_seq optional named vector chords durations, placing chord diagrams staves time.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/score.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a music score — score","text":"tibble data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/score.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a music score — score","text":"Score takes track tables generated track() fortifies music score. optionally binds tracks set chord diagrams. may one track track() well chord information passed, consistency score() still required fortify single track score object can rendered tab().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/score.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a music score — score","text":"","code":"x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 432 432\") x <- track(x) score(x) #> # A tibble: 1 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1"},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a musical phrase from string/fret combinations — sf_phrase","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"Create musical phrase character strings define string numbers, fret numbers note metadata. function wrapper around phrase().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"","code":"sf_phrase(   string,   fret = NULL,   info = NULL,   key = \"c\",   tuning = \"standard\",   to_notes = FALSE,   bar = NULL )  sfp(   string,   fret = NULL,   info = NULL,   key = \"c\",   tuning = \"standard\",   to_notes = FALSE,   bar = NULL )  sf_note(...)  sfn(...)"},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"string character, space-delimited vector. String numbers associated notes. Alternatively, provide information single space-delimited string ignore fret info. See details. fret character, space-delimited vector (integer vector) fret numbers associated notes. number timesteps string. info character, space-delimited vector (integer vector simple durations) giving metadata associated notes. number timesteps string. key character, key signature just specify \"sharp\" \"flat\". tuning character, instrument tuning. to_notes logical, return mapped notes character string rather entire phrase object. bar character NULL (default). Terminates phrase bar bar check. See details phrase(). Also see LilyPond help documentation bar notation valid options. ... arguments passed sf_phrase().","code":""},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"phrase.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"Note: alternate specification wrapper receiving support removed future version tabr. alternate syntax allows specifying string/fret combinations instead unambiguous pitch used phrase(). order remove ambiguity, critical specify instrument string tuning key signature. essentially uses string fret combination known tuning key signature generate notes phrase(). info passed straight phrase(), string done used help derive notes. See main function phrase general details phrase construction.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"comparison-with-phrase-","dir":"Reference","previous_headings":"","what":"Comparison with phrase()","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"function wrapper function users working musical notes (play), rather just position guitar neck (play). approach conveniences, limiting. order remove ambiguity, necessary specify instrument tuning key signature. standard approach phrase() specify play; specifying exactly play optional, highly recommended (providing string). sf_phrase(), string argument course required along fret. time tuning changes, \"play\" method breaks must redone. robust provide string pitch rather string fret. key additionally important way indicate accidentals notated sharps flats. wrapper also increases redundancy typing. order specify rests r, silent rests s, tied notes ~, must now providing parallel string fret arguments, whereas standard method using phrase(), need provided notes. mismatch throw error. Despite redundancy, helpful ensuring proper match string fret, essentially dual entry method aims reduce inside sf_phrase() single notes string passed internally phrase(). important thing keep mind nature, method writing music lend well high detail. Tabs informed nothing string fret number remove lot important information, attempt compensate additional symbols say, ascii tab, difficult read. wrapper function providing alternative input method phrase() job allowing users create phrase objects equivalent standard phrase()-generated objects, including rests ties. practice comfort working phrase() highly recommended greater control development support. function sfp() convenient shorthand wrapper sf_phrase(). sf_note() alias sfn() wrappers around sf_phrase() force to_notes = TRUE.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"single-string-input","dir":"Reference","previous_headings":"","what":"Single-string input","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"Another way use sf_phrase() provide musical input string ignore fret info explicit arguments. Providing three explicit arguments closely mimics inputs phrase() useful information three independent sources. However, cases single-argument input method can reduce typing, though depends phrase. importantly, allow reason musical inputs time step rather argument. provide three components single character string string argument, leaving fret info NULL, sf_phrase() decompose string three component parts internally. rules single-argument input. three components separated semicolons \"string;fret;info\". example, \"3;7x7;4\" means begin third string (infer higher number strings muted). frets 7th 7th, meaning two notes played. x present second entry means string played. inferred string numbers starting third string strings 3 1 rather 3 2 example. 4 indicates quarter note since part third entry additional info specified. contextual. example, x still indicate dead note, rather unplayed string second entry, contextual. bonus using input method explicit string info values persist one timestep next. Neither needs provided change value. example, \"3;7x7;4 7x7 ;7x7;1\" repeats string info values timestep one timestep two. timestep three, string numbers repeat , duration changes quarter note whole note. Note except string info repeating fret numbers provided (see timestep two ), two semicolons must present unambiguous whether sole missing component string info (see timestep three). Ambiguity arise case like \"4;4\" without second semicolon. type indexing chosen using two different delimiters. rest, r s, provided fret entry, string entry ignored. using input method, ties ~ given info entry. See examples comparison two identical phrases specified using input methods sf_phrase().","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/sf_phrase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a musical phrase from string/fret combinations — sf_phrase","text":"","code":"sf_phrase(\"5 4 3 2 1\", \"1 3 3 3 1\", \"8*4 1\", key = \"b_\") #> <Musical phrase> #> <bes,\\5>8 <f\\4>8 <bes\\3>8 <d'\\2>8 <f'\\1>1 sf_phrase(\"6 6 12 1 21\", \"133211 355333 11 (13) (13)(13)\", \"4 4 8 8 4\",           key = \"f\") #> <Musical phrase> #> <f,\\6 c\\5 f\\4 a\\3 c'\\2 f'\\1>4 <g,\\6 d\\5 g\\4 bes\\3 d'\\2 g'\\1>4 <f'\\1 c'\\2>8 <f''\\1>8 <c''\\2 f''\\1>4 sfp(\"6*2 1*4\", \"000232*2 2*4\", \"4 4 8*4\", tuning = \"dropD\", key = \"d\") #> <Musical phrase> #> <d,\\6 a,\\5 d\\4 a\\3 d'\\2 fis'\\1>4 <d,\\6 a,\\5 d\\4 a\\3 d'\\2 fis'\\1>4 <fis'\\1>8 <fis'\\1>8 <fis'\\1>8 <fis'\\1>8  # compare with single-argument input s <- \"3*5 53~*3 543*2 643\" f <- \"987*2 775 553 335 77~*3 545 325 210\" i <- \"2*3 4. 16 4.*3 4*3\" p1 <- sfp(s, f, i)  # Nominally shorter syntax, but potentially much easier to reason about p2 <- sfp(\"3;987;2*2 775 ;553;4. ;335;16 5;7x7;4.~*3 ;545;4 325 6;2x10;\")  identical(p1, p2) #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/simplify_phrase.html","id":null,"dir":"Reference","previous_headings":"","what":"Simplify the LilyPond syntax of a phrase — simplify_phrase","title":"Simplify the LilyPond syntax of a phrase — simplify_phrase","text":"function can used simplify LilyPond syntax phrase. intended direct use. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/simplify_phrase.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simplify the LilyPond syntax of a phrase — simplify_phrase","text":"","code":"simplify_phrase(phrase)"},{"path":"https://leonawicz.github.io/tabr/reference/simplify_phrase.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simplify the LilyPond syntax of a phrase — simplify_phrase","text":"phrase phrase object.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/simplify_phrase.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simplify the LilyPond syntax of a phrase — simplify_phrase","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/simplify_phrase.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simplify the LilyPond syntax of a phrase — simplify_phrase","text":"function intended used directly, available can see LilyPond syntax phrases transformed default process creating LilyPond file. function used lilypond() function associated render_* functions. using lilypond() directly, can controlled simplify argument. result function character string containing simpler, efficient LilyPond syntax. can coerced back phrase as_phrase(), print method colors longer display properly. importantly, simplification removes possibility transforming phrase back original inputs. complex nicely structured original representation better job maintaining reasonable possibility one one transformation phrase object inputs built .","code":""},{"path":"https://leonawicz.github.io/tabr/reference/simplify_phrase.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simplify the LilyPond syntax of a phrase — simplify_phrase","text":"","code":"notes <- \"a~ a b c' c'e'g'~ c'e'g'\" info <- \"8.. 8..-. 8- 8-^ 4.^ 4.\" (x <- p(notes, info)) #> <Musical phrase> #> <a~>8.. <a>8..-. <b>8\\glissando <c'>8-^ <c'~ e'~ g'~>4.\\bendAfter #+6 <c' e' g'>4. as_phrase(simplify_phrase(x)) #> <Musical phrase> #> a8..~ a-. b8\\glissando c'-^ <c' e' g'>4.~\\bendAfter #+6 <c' e' g'>  (x <- p(notes, info, 5)) #> <Musical phrase> #> <a~\\5>8.. <a\\5>8..-. <b\\5>8\\glissando <c'\\5>8-^ <c'~\\5 e'~\\4 g'~\\3>4.\\bendAfter #+6 <c'\\5 e'\\4 g'\\3>4. as_phrase(simplify_phrase(x)) #> <Musical phrase> #> a8..~\\5 a\\5-. b8\\5\\glissando c'\\5-^ <c'\\5 e'\\4 g'\\3>4.~\\bendAfter #+6 <c'\\5 e'\\4 g'\\3>"},{"path":"https://leonawicz.github.io/tabr/reference/single-bracket.html","id":null,"dir":"Reference","previous_headings":"","what":"Single bracket methods for tabr classes — single-bracket","title":"Single bracket methods for tabr classes — single-bracket","text":"Single bracket indexing assignment. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/single-bracket.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Single bracket methods for tabr classes — single-bracket","text":"","code":"# S3 method for class 'noteworthy' x[i]  # S3 method for class 'noteinfo' x[i]  # S3 method for class 'music' x[i]  # S3 method for class 'lyrics' x[i]  # S3 method for class 'noteworthy' x[i] <- value  # S3 method for class 'noteinfo' x[i] <- value  # S3 method for class 'music' x[i] <- value  # S3 method for class 'lyrics' x[i] <- value"},{"path":"https://leonawicz.github.io/tabr/reference/single-bracket.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Single bracket methods for tabr classes — single-bracket","text":"x object. index. value values assign index.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/single-bracket.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Single bracket methods for tabr classes — single-bracket","text":"","code":"# noteworthy class examples x <- as_noteworthy(\"a, b, c ce_g d4f#4a4\") x[3:4] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c <ce_g> x[-2] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c <ce_g> <d'g_'a'> x[2] <- paste0(transpose(x[2], 1), \"~\") x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c~ c <ce_g> <d'g_'a'>  # noteinfo class examples x <- as_noteinfo(c(\"4-\", \"t8(\", \"t8)\", \"t8x\", \"8^\", \"16\")) x[2:4] #> <Note info string> #>   Format: vectorized time #>   Values: t8( t8) t8x x[-1] #> <Note info string> #>   Format: vectorized time #>   Values: t8( t8) t8x 8^ 16 x[5:6] <- c(\"16^\", \"8\") x #> <Note info string> #>   Format: vectorized time #>   Values: 4- t8( t8) t8x 16^ 8 x[x == \"4-\"] #> <Note info string> #>   Format: vectorized time #>   Values: 4-  # music class examples x <- as_music(\"c,~4 c,1 c'e_'g'4-.*4\") x[1:3] #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e_'g'>4-. x[-c(1:2)] #> <Music string> #>   Format: space-delimited time #>   Values: <c'e_'g'>4-. <c'e_'g'>4-. <c'e_'g'>4-. <c'e_'g'>4-. x[3:6] <- \"c'e'g'8\" x #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e'g'>8 <c'e'g'>8 <c'e'g'>8 <c'e'g'>8"},{"path":"https://leonawicz.github.io/tabr/reference/string_unfold.html","id":null,"dir":"Reference","previous_headings":"","what":"Fold and unfold strings — string_unfold","title":"Fold and unfold strings — string_unfold","text":"Fold unfold string expansion operator.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/string_unfold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fold and unfold strings — string_unfold","text":"","code":"string_unfold(x)  string_fold(x, n = 3)"},{"path":"https://leonawicz.github.io/tabr/reference/string_unfold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fold and unfold strings — string_unfold","text":"x character string, valid notes note info beats. n integer, minimum number consecutive repeated values warrant folding, defaults 3.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/string_unfold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fold and unfold strings — string_unfold","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/string_unfold.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fold and unfold strings — string_unfold","text":"function work arbitrary stings. perform noteworthy check. allows work info strings well. Make sure strings properly formatted. string_fold() always collapses output string space-delimited.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/string_unfold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fold and unfold strings — string_unfold","text":"","code":"time <- \"8*3 16 4.. 16 16 2 2 4. 8 4 4 8*4 1\" x <- string_unfold(time) x #> [1] \"8 8 8 16 4.. 16 16 2 2 4. 8 4 4 8 8 8 8 1\" string_fold(x) == time #> [1] TRUE  notes <- \"a, b, c d e f g# a r ac'e' a c' e' c' r r r a\" x <- string_fold(notes) x #> [1] \"a, b, c d e f g# a r ac'e' a c' e' c' r*3 a\" string_unfold(x) == notes #> [1] TRUE"},{"path":"https://leonawicz.github.io/tabr/reference/tab.html","id":null,"dir":"Reference","previous_headings":"","what":"Render sheet music with LilyPond — tab","title":"Render sheet music with LilyPond — tab","text":"Render sheet music/tablature music score LilyPond.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Render sheet music with LilyPond — tab","text":"","code":"tab(   score,   file,   key = \"c\",   time = \"4/4\",   tempo = \"2 = 60\",   header = NULL,   paper = NULL,   string_names = NULL,   endbar = \"|.\",   midi = TRUE,   colors = NULL,   crop_png = TRUE,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE,   details = FALSE )  render_tab(   score,   file,   key = \"c\",   time = \"4/4\",   tempo = \"2 = 60\",   header = NULL,   paper = NULL,   string_names = NULL,   endbar = \"|.\",   midi = TRUE,   colors = NULL,   crop_png = TRUE,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE,   details = FALSE )  render_score(   score,   file,   key = \"c\",   time = \"4/4\",   tempo = \"2 = 60\",   header = NULL,   paper = NULL,   endbar = \"|.\",   colors = NULL,   crop_png = TRUE,   transparent = FALSE,   res = 150,   keep_ly = FALSE,   simplify = TRUE,   details = FALSE )  render_midi(score, file, key = \"c\", time = \"4/4\", tempo = \"2 = 60\")"},{"path":"https://leonawicz.github.io/tabr/reference/tab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Render sheet music with LilyPond — tab","text":"score score object. file character, output file ending .pdf .png sheet music tablature score(). May include absolute relative path. render_midi(), file ending .mid. key character, key signature, e.g., c, b_, f#m, etc. time character, defaults \"4/4\". tempo character, defaults \"2 = 60\". Set NULL suppress display time signature output. header named list arguments passed header LilyPond file. See lilypond() details. paper named list arguments LilyPond file page layout. See lilypond() details. string_names label strings beginning tab staff. NULL (default) non-standard tunings , TRUE FALSE force completely. endbar character, global end bar. midi logical, output midi file addition sheet music. colors named list LilyPond element color overrides. See lilypond() details. crop_png logical, see lilypond() details. transparent logical, transparent background, png . res numeric, resolution, png . transparent = TRUE may fail res exceeds ~150. keep_ly logical, keep intermediary LilyPond file. simplify logical, uses simplify_phrase() convert simpler, efficient LilyPond syntax LilyPond file rendering . details logical, set TRUE print LilyPond log output console. Windows .","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Render sheet music with LilyPond — tab","text":"nothing returned; file written.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tab.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Render sheet music with LilyPond — tab","text":"Generate pdf png music score using LilyPond music engraving program. Output format inferred file extension. function wrapper around lilypond(), function creates LilyPond (.ly) file. render_score() renders score() pdf png. render_midi() renders MIDI file based score(). still done via LilyPond. sheet music created automatically process behind scenes deleted MIDI output retained. tab() render_tab() (equivalent) produces sheet music MIDI file output default includes arguments tablature-relevant argument string_names. -purpose function. Also use intend create sheet music document MIDI file. Remember whether track contains tablature staff, standard music staff, , defined individual track object contained score(). contents assembled inscore() dictate render function use. render_tab() general always works, render_score() best choice tablature staff present unless accept default string naming convention. render_midi() different midily() miditab(), whose purpose create sheet music existing MIDI file using LilyPond command line utility. Windows users, add path LilyPond executable system path variable. example, file C:/lilypond-2.24.2/bin/lilypond.exe, add C:/lilypond-2.24.2/bin system path.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Render sheet music with LilyPond — tab","text":"","code":"if (FALSE) { # \\dontrun{ if(tabr_options()$lilypond != \"\"){   x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 432 432\")   x <- track(x)   x <- score(x)   outfile <- file.path(tempdir(), \"out.pdf\")   tab(x, outfile) # requires LilyPond installation } } # }"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-c.html","id":null,"dir":"Reference","previous_headings":"","what":"Concatenate for tabr classes — tabr-c","title":"Concatenate for tabr classes — tabr-c","text":"Several methods implemented classes noteworthy, noteinfo, music. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-c.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Concatenate for tabr classes — tabr-c","text":"","code":"# S3 method for class 'noteworthy' c(...)  # S3 method for class 'noteinfo' c(...)  # S3 method for class 'music' c(...)  # S3 method for class 'lyrics' c(...)  # S3 method for class 'phrase' c(...)"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-c.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Concatenate for tabr classes — tabr-c","text":"... objects.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr-c.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Concatenate for tabr classes — tabr-c","text":"","code":"# noteworthy class examples x <- \"a b c\" c(x, x) #> [1] \"a b c\" \"a b c\" c(as_noteworthy(x), x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b c a b c  # noteinfo class examples x <- \"4- t8( t8)( t8) 4*2\" c(as_noteinfo(x), x) #> <Note info string> #>   Format: space-delimited time #>   Values: 4- t8( t8)( t8) 4 4 4- t8( t8)( t8) 4 4  # music class examples x <- \"c,~4 c,1 c'e_'g'4-.*2\" c(as_music(x), x) #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e_'g'>4-. <c'e_'g'>4-. c,~4 c,1 <c'e_'g'>4-. <c'e_'g'>4-.  # phrase class examples c(phrase(x), x) #> <Musical phrase> #> <c,~>4 <c,>1 <c' es' g'>4-. <c' es' g'>4-. <c,~>4 <c,>1 <c' es' g'>4-. <c' es' g'>4-."},{"path":"https://leonawicz.github.io/tabr/reference/tabr-details.html","id":null,"dir":"Reference","previous_headings":"","what":"tabr: Additional Detals — tabr-details","title":"tabr: Additional Detals — tabr-details","text":"tabr package provides music notation syntax collection music programming functions generating, manipulating, organizing analyzing musical information R. music notation framework facilitates creating analyzing music data notation form.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-details.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"tabr: Additional Detals — tabr-details","text":"Music syntax can entered directly character strings, example quickly transcribe short pieces music. package contains functions directly performing various mathematical, logical organizational operations musical transformations special object classes facilitate working music data notation. music data can organized tidy data frames familiar powerful approach analysis large amounts structured music data. Functions available mapping seamlessly formats representations musical information. package also provides API 'LilyPond' (https://lilypond.org/) transcribing musical representations R tablature (\"tabs\") sheet music. 'LilyPond' open source music engraving software generating high quality sheet music based markup syntax. package generates 'LilyPond' files R code can pass 'LilyPond' command line interface rendered sheet music PDF files inserted R markdown documents. package offers nominal MIDI file output support conjunction rendering sheet music. package can read MIDI files attempts structure MIDI data integrate best possible data structures functionality found throughout package. tabr offers useful limited LilyPond API intended access LilyPond functionality R, transcription via API entire scope tabr. creating sheet music case case basis, write LilyPond files manually. need use tabr limit existing LilyPond API. generating music notation programmatically, tabr provides ability R added benefit converting write R code LilyPond file format rendered printable guitar tablature. LilyPond listed system requirement tabr, can use package music analysis without installing LilyPond intend render tabs.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-head.html","id":null,"dir":"Reference","previous_headings":"","what":"Head and tail for tabr classes — tabr-head","title":"Head and tail for tabr classes — tabr-head","text":"Several methods implemented classes noteworthy, noteinfo, music. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-head.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Head and tail for tabr classes — tabr-head","text":"","code":"# S3 method for class 'noteworthy' head(x, ...)  # S3 method for class 'noteinfo' head(x, ...)  # S3 method for class 'music' head(x, ...)  # S3 method for class 'lyrics' head(x, ...)  # S3 method for class 'noteworthy' tail(x, ...)  # S3 method for class 'noteinfo' tail(x, ...)  # S3 method for class 'music' tail(x, ...)  # S3 method for class 'lyrics' tail(x, ...)"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-head.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Head and tail for tabr classes — tabr-head","text":"x object. ... number elements return.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr-head.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Head and tail for tabr classes — tabr-head","text":"","code":"# noteworthy class examples x <- \"a b c d e f g\" head(x, 2) #> [1] \"a b c d e f g\" head(as_noteworthy(x), 2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b tail(as_noteworthy(x), 2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: f g  # noteinfo class examples x <- \"4x 4-.*8 2 4\" head(as_noteinfo(x)) #> <Note info string> #>   Format: space-delimited time #>   Values: 4x 4-. 4-. 4-. 4-. 4-. tail(as_noteinfo(x)) #> <Note info string> #>   Format: space-delimited time #>   Values: 4-. 4-. 4-. 4-. 2 4  # music class examples x <- \"c,~4 c,1 c'e_'g'4-.\" head(as_music(x), 2) #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 tail(as_music(x), 2) #> <Music string> #>   Format: space-delimited time #>   Values: c,1 <c'e_'g'>4-."},{"path":"https://leonawicz.github.io/tabr/reference/tabr-length.html","id":null,"dir":"Reference","previous_headings":"","what":"Length for tabr classes — tabr-length","title":"Length for tabr classes — tabr-length","text":"Several methods implemented classes noteworthy, noteinfo, music. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-length.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Length for tabr classes — tabr-length","text":"","code":"# S3 method for class 'noteworthy' length(x)  # S3 method for class 'noteinfo' length(x)  # S3 method for class 'music' length(x)  # S3 method for class 'lyrics' length(x)"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-length.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Length for tabr classes — tabr-length","text":"x object.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr-length.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Length for tabr classes — tabr-length","text":"","code":"# noteworthy class examples x <- \"a b c\" length(x) #> [1] 1 length(as_noteworthy(x)) #> [1] 3 length(as_noteworthy(\"a b*2 c*2\")) #> [1] 5  # noteinfo class examples x <- \"4- t8( t8)( t8) 4*2\" length(x) #> [1] 1 length(as_noteinfo(x)) #> [1] 6  # music class examples x <- \"c,~4 c,1 c'e_'g'4-.*4\" length(x) #> [1] 1 length(as_music(x)) #> [1] 6"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary of implemented S3 generic methods — tabr-methods","title":"Summary of implemented S3 generic methods — tabr-methods","text":"Several methods implemented classes noteworthy, noteinfo, music lyrics. See details limited implementations phrase class.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary of implemented S3 generic methods — tabr-methods","text":"x object. index. value values assign index. ... additional arguments.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summary of implemented S3 generic methods — tabr-methods","text":"addition custom print summary methods, following methods implemented four classes: [, [<-, [[, [[<-, length(), c(), rep(), rev(), head() tail(). Logical operators also implemented noteworthy strings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"methods-length-and-c-","dir":"Reference","previous_headings":"","what":"Methods length() and c()","title":"Summary of implemented S3 generic methods — tabr-methods","text":"implementation length() equivalent n_steps(). access attribute, returning number timesteps object. gives result even underlying string space-delimited format. obtain character string length, coerce .character() function effect. implementation c() classes strict favors object class question. different c() might normally behave, coercing objects different types numeric character character. four classes, c() strict return error attempting concatenate one classes class besides character. includes . possible coerce music object noteworthy object noteinfo object, opposite aggressive coercion classes intended c() done. classes numeric immediately return error, concatenation character strings attempts coerce character string present given class. coercion fails character class object, usual error returned concerning invalid notes note info present. coercion succeeds character strings, result c() concatenate timesteps objects passed . output new noteworthy, noteinfo ormusic object.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"methods-rep-rev-head-and-tail-","dir":"Reference","previous_headings":"","what":"Methods rep() rev() head() and tail()","title":"Summary of implemented S3 generic methods — tabr-methods","text":"rep() function similar c() except never consider classes. pass vector objects rep(), c() already resolved objects single class. , matters underlying length elements character vector class built upon, timesteps. rep() extend x terms timesteps. can also provide times arguments. rev(), head() tail() work similarly, based sequence timesteps, character vector length. Remember accounts vectors length one contain multiple timesteps space-delimited time format, also multiple timesteps can condensed even space-delimited time format * expansion operator. example, \"'*4 b'*2\" six timesteps form well vector form. object length neither one two. generic method implementations work manner.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"square-brackets","dir":"Reference","previous_headings":"","what":"Square brackets","title":"Summary of implemented S3 generic methods — tabr-methods","text":"Single double bracket subsetting index work similarly occurs lists. Single bracket subsetting returns object, containing indexed timesteps. Double bracket subsetting operates single timestep extracts character string value. assignment, single double brackets change value timesteps return object, double brackets allow indexing single timestep. Double bracket indexing mostly useful combining steps extracting single value discarding special class one command.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"limited-phrase-implementations","dir":"Reference","previous_headings":"","what":"Limited phrase implementations","title":"Summary of implemented S3 generic methods — tabr-methods","text":"Methods implemented phrase class limited c() rep(). Due complex LilyPond syntax, applying functions directly phrases problematic. c() implemented like classes. rep() restricted can repeat entire phrase sequence, timesteps within. However, can convert phrase class back noteworthy noteinfo objects (reasonable conditions). See notify(). One exception made phrase objects respect concatenation attempt concatenate combination phrase music objects, order, results coercion new phrase. happens even case first object sequence music object (thus calling c.music() rather c.phrase()). subsequently fall back c.phrase() case.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summary of implemented S3 generic methods — tabr-methods","text":"","code":"# noteworthy class examples x <- as_noteworthy(\"a, b, c ce_g d4f#4a4\") x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, b, c <ce_g> <d'g_'a'> x[3:4] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c <ce_g> x[-2] #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c <ce_g> <d'g_'a'> x[2] <- paste0(transpose(x[2], 1), \"~\") x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c~ c <ce_g> <d'g_'a'> length(x) # equal to number of timesteps #> [1] 5 c(x, x) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a, c~ c <ce_g> <d'g_'a'> a, c~ c <ce_g> <d'g_'a'> tail(rep(x, times = c(1, 2, 1, 3, 1))) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c~ c <ce_g> <ce_g> <ce_g> <d'g_'a'>  # noteinfo class examples x <- as_noteinfo(c(\"4-\", \"t8(\", \"t8)\", \"t8x\", \"8^\", \"16\")) x #> <Note info string> #>   Format: vectorized time #>   Values: 4- t8( t8) t8x 8^ 16 x[2:4] #> <Note info string> #>   Format: vectorized time #>   Values: t8( t8) t8x x[-1] #> <Note info string> #>   Format: vectorized time #>   Values: t8( t8) t8x 8^ 16 x[5:6] <- c(\"16^\", \"8\") x #> <Note info string> #>   Format: vectorized time #>   Values: 4- t8( t8) t8x 16^ 8 x[x == \"4-\"] #> <Note info string> #>   Format: vectorized time #>   Values: 4- c(x[1], x[2]) == c(x[1:2]) #> [1] TRUE TRUE head(rep(x, each = 2)) #> <Note info string> #>   Format: vectorized time #>   Values: 4- 4- t8( t8( t8) t8)  # music class examples x <- as_music(\"c,~4 c,1 c'e_'g'4-.*4\") x #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e_'g'>4-. <c'e_'g'>4-. <c'e_'g'>4-. <c'e_'g'>4-. x[1:3] #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e_'g'>4-. x[-c(1:2)] #> <Music string> #>   Format: space-delimited time #>   Values: <c'e_'g'>4-. <c'e_'g'>4-. <c'e_'g'>4-. <c'e_'g'>4-. x[3:6] <- \"c'e'g'8\" x #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 <c'e'g'>8 <c'e'g'>8 <c'e'g'>8 <c'e'g'>8 c(x[1], x[1]) == x[c(1, 1)] #> [1] TRUE rev(x) #> <Music string> #>   Format: space-delimited time #>   Values: <c'e'g'>8 <c'e'g'>8 <c'e'g'>8 <c'e'g'>8 c,1 c,~4  x[[3]] #> [1] \"c'e'g'8\" x[[3]] <- \"b_t8\" x #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,1 b_t8 <c'e'g'>8 <c'e'g'>8 <c'e'g'>8"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rep.html","id":null,"dir":"Reference","previous_headings":"","what":"Repeat for tabr classes — tabr-rep","title":"Repeat for tabr classes — tabr-rep","text":"Several methods implemented classes noteworthy, noteinfo, music. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rep.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Repeat for tabr classes — tabr-rep","text":"","code":"# S3 method for class 'noteworthy' rep(x, ...)  # S3 method for class 'noteinfo' rep(x, ...)  # S3 method for class 'music' rep(x, ...)  # S3 method for class 'lyrics' rep(x, ...)  # S3 method for class 'phrase' rep(x, ...)"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rep.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Repeat for tabr classes — tabr-rep","text":"x object. ... additional arguments. accepted phrase objects.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rep.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Repeat for tabr classes — tabr-rep","text":"","code":"# noteworthy class examples x <- \"a b c\" rep(x, 2) #> [1] \"a b c\" \"a b c\" rep(as_noteworthy(x), 2) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b c a b c  # noteinfo class examples x <- \"4x 4-.*2 2\" rep(as_noteinfo(x), times = c(2, 1, 1, 2)) #> <Note info string> #>   Format: space-delimited time #>   Values: 4x 4x 4-. 4-. 2 2  # music class examples x <- \"c,~4 c,1 c'e_'g'4-.\" rep(as_music(x), each = 2) #> <Music string> #>   Format: space-delimited time #>   Values: c,~4 c,~4 c,1 c,1 <c'e_'g'>4-. <c'e_'g'>4-.  # phrase class examples rep(phrase(x), 2) #> <Musical phrase> #> <c,~>4 <c,>1 <c' es' g'>4-. <c,~>4 <c,>1 <c' es' g'>4-."},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rev.html","id":null,"dir":"Reference","previous_headings":"","what":"Reverse for tabr classes — tabr-rev","title":"Reverse for tabr classes — tabr-rev","text":"Several methods implemented classes noteworthy, noteinfo, music. See tabr-methods() details methods tabr classes.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rev.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reverse for tabr classes — tabr-rev","text":"","code":"# S3 method for class 'noteworthy' rev(x)  # S3 method for class 'noteinfo' rev(x)  # S3 method for class 'music' rev(x)  # S3 method for class 'lyrics' rev(x)"},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rev.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reverse for tabr classes — tabr-rev","text":"x object.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr-rev.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reverse for tabr classes — tabr-rev","text":"","code":"# noteworthy class examples x <- \"a b c\" rev(x) #> [1] \"a b c\" rev(as_noteworthy(x)) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: c b a  # noteinfo class examples x <- \"4x 4-.*2 2\" rev(as_noteinfo(x)) #> <Note info string> #>   Format: space-delimited time #>   Values: 2 4-. 4-. 4x  # music class examples x <- \"c,~4 c,1 c'e_'g'4-.\" rev(as_music(x)) #> <Music string> #>   Format: space-delimited time #>   Values: <c'e_'g'>4-. c,1 c,~4"},{"path":"https://leonawicz.github.io/tabr/reference/tabr.html","id":null,"dir":"Reference","previous_headings":"","what":"tabr: Music Notation Syntax, Manipulation, Analysis and Transcription in R — tabr","title":"tabr: Music Notation Syntax, Manipulation, Analysis and Transcription in R — tabr","text":"Provides music notation syntax collection music programming functions generating, manipulating, organizing, analyzing musical information R. Music syntax can entered directly character strings, example quickly transcribe short pieces music. package contains functions directly performing various mathematical, logical organizational operations musical transformations special object classes facilitate working music data notation. music data can organized tidy data frames familiar powerful approach analysis large amounts structured music data. Functions available mapping seamlessly formats representations musical information. package also provides API 'LilyPond' (https://lilypond.org/) transcribing musical representations R tablature (\"tabs\") sheet music. 'LilyPond' open source music engraving software generating high quality sheet music based markup syntax. package generates 'LilyPond' files R code can pass 'LilyPond' command line interface rendered sheet music PDF files inserted R markdown documents. package offers nominal MIDI file output support conjunction rendering sheet music. package can read MIDI files attempts structure MIDI data integrate best possible data structures functionality found throughout package.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/tabr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"tabr: Music Notation Syntax, Manipulation, Analysis and Transcription in R — tabr","text":"Maintainer: Matthew Leonawicz rpkgs@pm.(ORCID)","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabrSyntax.html","id":null,"dir":"Reference","previous_headings":"","what":"tabr syntax — tabrSyntax","title":"tabr syntax — tabrSyntax","text":"data frame containing descriptions syntax used phrase construction tabr.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabrSyntax.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"tabr syntax — tabrSyntax","text":"","code":"tabrSyntax"},{"path":"https://leonawicz.github.io/tabr/reference/tabrSyntax.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"tabr syntax — tabrSyntax","text":"data frame 3 columns syntax description, operators examples.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr_options.html","id":null,"dir":"Reference","previous_headings":"","what":"Options — tabr_options","title":"Options — tabr_options","text":"Options tabr package.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr_options.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Options — tabr_options","text":"","code":"tabr_options(...)"},{"path":"https://leonawicz.github.io/tabr/reference/tabr_options.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Options — tabr_options","text":"... list options.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr_options.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Options — tabr_options","text":"function prints set options called arguments. setting options, nothing returned.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr_options.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Options — tabr_options","text":"Currently lilypond, midi2ly python used. Windows systems, system path lilypond.exe, midi2ly python.exe stored system PATH environmental variable, must provided user loading package.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tabr_options.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Options — tabr_options","text":"","code":"tabr_options() #> $lilypond #> [1] \"C:\\\\PROGRA~2\\\\LilyPond\\\\usr\\\\bin\\\\lilypond.exe\" #>  #> $midi2ly #> [1] \"C:\\\\PROGRA~2\\\\LilyPond\\\\usr\\\\bin\\\\midi2ly\" #>  #> $python #> [1] \"C:\\\\Users\\\\Matt\\\\AppData\\\\Local\\\\Programs\\\\Python\\\\PYTHON~2\\\\python.exe\" #>  lilypond_path <- \"C:/lilypond-2.24.2/bin/lilypond.exe\" # if installed here tabr_options(lilypond = lilypond_path)"},{"path":"https://leonawicz.github.io/tabr/reference/tie.html","id":null,"dir":"Reference","previous_headings":"","what":"Tied notes — tie","title":"Tied notes — tie","text":"Tie notes efficiently.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tie.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tied notes — tie","text":"","code":"tie(x)  untie(x)"},{"path":"https://leonawicz.github.io/tabr/reference/tie.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tied notes — tie","text":"x character, single chord.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tie.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tied notes — tie","text":"character string.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tie.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tied notes — tie","text":"function useful bar chords.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tie.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tied notes — tie","text":"","code":"tie(\"e,b,egbe'\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <e,~b,~e~g~b~e'~>"},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":null,"dir":"Reference","previous_headings":"","what":"Music notation syntax converters — to_tabr","title":"Music notation syntax converters — to_tabr","text":"Convert alternative representations music notation tabr syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Music notation syntax converters — to_tabr","text":"","code":"to_tabr(id, ...)  from_chorrrds(x, key = \"c\", guitar = FALSE, gc_args = list())  from_music21(x, accidentals = c(\"flat\", \"sharp\"), output = c(\"music\", \"list\"))"},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Music notation syntax converters — to_tabr","text":"id character, suffix from_* function, e.g., \"chorrrds\" ... arguments passed function matched id. x character, general syntax input. See details examples inputs structured converter. key key signature, used enforce consistent use flats sharps. guitar logical, attempt match input chords known guitar chords guitarChords(). Otherwise default standard piano chords consecutive pitches covering minimum pitch range returned. gc_args named list additional arguments passed gc_info(), used guitar = TRUE. accidentals character, represent accidentals, \"flat\" \"sharp\". output character, type output multiple options available.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Music notation syntax converters — to_tabr","text":"noteworthy string chorrrds; music string list music21.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Music notation syntax converters — to_tabr","text":"functions convert music notation data sources style used tabr music analysis sheet music transcription.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"syntax-converter-for-chorrrds","dir":"Reference","previous_headings":"","what":"Syntax converter for chorrrds","title":"Music notation syntax converters — to_tabr","text":"input x character vector chords output chorrrds package, shown examples. Output noteworthy string object. sources offer complete explicit information order make sheet music. However, available formats converted extent possible available function arguments can allow user add additional specification. Different input syntax makes use different syntax converter. Depending format, different arguments may available /required. general wrapper function available syntax converters to_tabr(). function takes id argument appropriate converter function. See examples. example, output chorrrds package scrapes chord information Cifraclub website provides chords, note note transcription data particular instrument. means result syntax conversion still yields chords, fine data analysis add anything useful sheet music transcription. input case also specify distinct pitches assigning octaves numbers chord's notes, even root note. remains user want apply information. default, every chord starts octave three. also ambiguous chord played since provided generic chord symbol. default standard chord constructed can determined. Setting guitar = TRUE switches using guitarChords() dataset find matching guitar chords using gc_info(), can provided additional arguments named list gc_args. guitar, allows additional control actual structure chord, shape position guitar neck. options never work perfectly chords chords, minimum, typical default component pitches determined returned tabr notation style.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"syntax-converter-for-music-","dir":"Reference","previous_headings":"","what":"Syntax converter for music21","title":"Music notation syntax converters — to_tabr","text":"input x character vector music21 tiny notation syntax, shown examples. Default output music object. Setting output = \"list\" returns list three elements: noteworthy string, note info string, time signature. recommendation music21 syntax keep simple. use letter n explicit natural notes. add text annotations lyrics. Double flats sharps supported. examples demonstrate currently supported.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/to_tabr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Music notation syntax converters — to_tabr","text":"","code":"# chorrrds package output chords <- c(\"Bb\", \"Bbm\", \"Bbm7\", \"Bbm7(b5)\", \"Bb7(#5)/G\", \"Bb7(#5)/Ab\") from_chorrrds(chords) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_d'f'> <b_d_'f'> <b_d_'f'a_'> <b_d_'e'a_'> <gb_d'g_'a_'> <a_b_d'g_'> to_tabr(id = \"chorrrds\", x = chords) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_d'f'> <b_d_'f'> <b_d_'f'a_'> <b_d_'e'a_'> <gb_d'g_'a_'> <a_b_d'g_'>  from_chorrrds(chords, guitar = TRUE) #> Warning: Alternate bass note detected, but ignored when `guitar = TRUE`. #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_,fb_d'f'> <b_,fb_d_'f'> <b_,fa_d_'f'> <b_,a_d_'e'> <b_,g_a_d'> <b_,g_a_d'> to_tabr(id = \"chorrrds\", x = chords, guitar = TRUE) #> Warning: Alternate bass note detected, but ignored when `guitar = TRUE`. #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <b_,fb_d'f'> <b_,fb_d_'f'> <b_,fa_d_'f'> <b_,a_d_'e'> <b_,g_a_d'> <b_,g_a_d'>  # music21 tiny notation x <- \"4/4 CC#FF4.. trip{c#8eg# d'- e-' f g a'} D4~# D E F r B16\" from_music21(x) #> <Music string> #>   Format: space-delimited time #>   Values: <d_,,f,,>4.. <d_ea_>t8 d_'t8 e_'t8 ft8 gt8 a't8 e_,~4 d,4 e,4 f,4 r4 b,16  from_music21(x, accidentals = \"sharp\") #> <Music string> #>   Format: space-delimited time #>   Values: <c#,,f,,>4.. <c#eg#>t8 c#'t8 d#'t8 ft8 gt8 a't8 d#,~4 d,4 e,4 f,4 r4 b,16  from_music21(x, output = \"list\") #> $notes #> <Noteworthy string> #>   Format: space-delimited time #>   Values: <d_,,f,,> <d_ea_> d_' e_' f g a' e_,~ d, e, f, r b, #>  #> $info #> <Note info string> #>   Format: space-delimited time #>   Values: 4.. t8 t8 t8 t8 t8 t8 4 4 4 4 4 16 #>  #> $lyrics #> [1] NA #>  #> $key #> [1] \"c\" #>  #> $time #> [1] \"4/4\" #>  #> $tempo #> [1] \"2 = 60\" #>"},{"path":"https://leonawicz.github.io/tabr/reference/track.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a music track — track","title":"Create a music track — track","text":"Create music track collection musical phrases.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/track.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a music track — track","text":"","code":"track(   phrase,   clef = \"treble_8\",   key = NA,   tab = TRUE,   tuning = \"standard\",   voice = 1,   lyrics = NA )  track_guitar(   phrase,   clef = \"treble_8\",   key = NA,   tab = TRUE,   tuning = \"standard\",   voice = 1,   lyrics = NA )  track_tc(phrase, key = NA, voice = 1, lyrics = NA)  track_bc(phrase, key = NA, voice = 1, lyrics = NA)  track_bass(phrase, key = NA, voice = 1, lyrics = NA)"},{"path":"https://leonawicz.github.io/tabr/reference/track.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a music track — track","text":"phrase phrase object. clef character, include music staff given clef. NA suppress. See details. key character, key signature music staff. See details. tab logical, include tablature staff. NA suppress. tuning character, pitches describing instrument string tuning predefined tuning ID. See tunings(). Defaults standard guitar tuning; relevant tablature staff suppressed. voice integer, ID indicating unique voice phrase() belongs within single track (another track may share tab/music staff different voice ID). two voices supported per track. lyrics lyrics object NA. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/track.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a music track — track","text":"tibble data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/track.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a music track — track","text":"Musical phrases generated phrase() fortified track table. tracks stored track tables, one per row, even table consists single track. track() creates single-entry track table. See trackbind() merging single tracks multi-track table. row binding also properly preserves phrase track classes. various track_* functions offering sensible defaults based function suffix. base track() function equivalent track_guitar(). See examples. Setting clef = NA tab = NA suppresses music staff tablature staff, respectively. default key = NA, case inherits global key key argument various sheet music rendering functions. planning bind two tracks one given voice = 1 voice = 2, respectively, must also common key, even key = NA. lyrics used simple tracks contain repeats. also need ensure timesteps lyrics align phrase() advance. Additionally, LilyPond engrave lyrics rests tied notes (excluding first note tied sequence) Therefore, phrase() contains rests tied notes lyrics object subset exclude timesteps well. contrast using render_music* functions, handle automatically music objects.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/track.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a music track — track","text":"","code":"x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 4 4\") track(x) # same as track_guitar(x); 8va treble clef above tab staff #> # A tibble: 1 × 7 #>   phrase       clef     key   tab   tuning    voice lyrics #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA     track_tc(x) # treble clef sheet music, no tab staff #> # A tibble: 1 × 7 #>   phrase       clef   key   tab   tuning    voice lyrics #>   <list>       <chr>  <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> treble NA    FALSE e,a,dgbe'     1 NA     track_bc(x) # bass clef sheet music, no tab staff #> # A tibble: 1 × 7 #>   phrase       clef  key   tab   tuning    voice lyrics #>   <list>       <chr> <chr> <lgl> <chr>     <int> <chr>  #> 1 <phrase [1]> bass  NA    FALSE e,a,dgbe'     1 NA      x <- phrase(\"c, g,c g,c\", \"4 4 2\", \"3 2 2\") track_bass(x) # includes tab staff and standard bass tuning #> # A tibble: 1 × 7 #>   phrase       clef   key   tab   tuning     voice lyrics #>   <list>       <chr>  <chr> <lgl> <chr>      <int> <chr>  #> 1 <phrase [1]> bass_8 NA    FALSE e,,a,,d,g,     1 NA"},{"path":"https://leonawicz.github.io/tabr/reference/trackbind.html","id":null,"dir":"Reference","previous_headings":"","what":"Bind track tables — trackbind","title":"Bind track tables — trackbind","text":"Bind together track tables row.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/trackbind.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bind track tables — trackbind","text":"","code":"trackbind(..., id)"},{"path":"https://leonawicz.github.io/tabr/reference/trackbind.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bind track tables — trackbind","text":"... single-entry track data frames. id integer, ID vector indicating distinct tracks corresponding distinct sheet music staves. See details.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/trackbind.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bind track tables — trackbind","text":"tibble data frame","code":""},{"path":"https://leonawicz.github.io/tabr/reference/trackbind.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bind track tables — trackbind","text":"function appends multiple track tables single track table preparation generating multi-track score. id used separate staves sheet music/tablature output. track's voice used separate distinct voices within common music staff. provided, id automatically propagates 1:n n tracks passed ... binding tracks together. expresses default assumption one staff music/tab staff pair per track. typical use case. tracks represent different voices share staff. assigned id, case must provide id argument. two voices per track supported. error thrown two tracks voice id. pair must unique. E.g., provide id = c(1, 1) two tracks voice equal 1 2. See examples. Note actual ID values assigned track matter; order tracks bound, first last.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/trackbind.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bind track tables — trackbind","text":"","code":"x <- phrase(\"c ec'g' ec'g'\", \"4 4 2\", \"5 432 432\") x1 <- track(x) x2 <- track(x, voice = 2) trackbind(x1, x1) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         2 trackbind(x1, x2, id = c(1, 1)) #> # A tibble: 2 × 8 #>   phrase       clef     key   tab   tuning    voice lyrics    id #>   <list>       <chr>    <chr> <lgl> <chr>     <int> <chr>  <int> #> 1 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     1 NA         1 #> 2 <phrase [1]> treble_8 NA    TRUE  e,a,dgbe'     2 NA         1"},{"path":"https://leonawicz.github.io/tabr/reference/transpose.html","id":null,"dir":"Reference","previous_headings":"","what":"Transpose pitch — transpose","title":"Transpose pitch — transpose","text":"Transpose pitch number semitones.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/transpose.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transpose pitch — transpose","text":"","code":"transpose(notes, n = 0, octaves = NULL, accidentals = NULL, key = NULL)  tp(notes, n = 0, octaves = NULL, accidentals = NULL, key = NULL)"},{"path":"https://leonawicz.github.io/tabr/reference/transpose.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transpose pitch — transpose","text":"notes character, noteworthy string. n integer, positive negative number semitones transpose. octaves NULL character, \"tick\" \"integer\" octave numbering result. accidentals NULL character, represent accidentals, \"flat\" \"sharp\". key NULL character, use key signature specify override accidentals. Ignored c .","code":""},{"path":"https://leonawicz.github.io/tabr/reference/transpose.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transpose pitch — transpose","text":"character","code":""},{"path":"https://leonawicz.github.io/tabr/reference/transpose.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Transpose pitch — transpose","text":"function transposes pitch notes noteworthy string. Transposing currently supported phrase object. notes phrase object already transformed LilyPond syntax mixed potentially complex information. Transposing intended done string notes prior passing phrase(). work strings use either integer tick mark octave numbering formats flats sharps, combination. transposed result conforms according function arguments. integer octaves returned, 3s dropped since third octave implicit LilyPond. octaves, accidentals key NULL, formatting inferred notes. mixed formats present, tick format default octave numbering flats default accidentals.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/transpose.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transpose pitch — transpose","text":"","code":"transpose(\"a_3 b_4 c5\", 0) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a_ b_4 c5 tp(\"a_3 b_4 c5\", -1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: g a4 b4 tp(\"a_3 b_4 c5\", 1) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a b4 d_5 tp(\"a#3 b4 c#5\", 11) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a4 a#5 c6 tp(\"a#3 b4 c#5\", 12) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: a#4 b5 c#6 tp(\"r s a#3 b4 c#5\", 13) #> <Noteworthy string> #>   Format: space-delimited time #>   Values: r s b4 c6 d6 tp(\"a b' c#''\", 2, \"integer\", \"flat\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b d_5 e_5 tp(\"a, b ceg\", 2, \"tick\", \"sharp\") #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b, c#' <df#a>"},{"path":"https://leonawicz.github.io/tabr/reference/tunings.html","id":null,"dir":"Reference","previous_headings":"","what":"Predefined instrument tunings — tunings","title":"Predefined instrument tunings — tunings","text":"data frame containing predefined instrument tunings commonly used guitar, bass, mandolin, banjo, ukulele orchestral instruments.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tunings.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predefined instrument tunings — tunings","text":"","code":"tunings"},{"path":"https://leonawicz.github.io/tabr/reference/tunings.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Predefined instrument tunings — tunings","text":"data frame 2 columns tuning ID corresponding pitches 32 rows predefined tunings.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tuplet.html","id":null,"dir":"Reference","previous_headings":"","what":"Tuplets — tuplet","title":"Tuplets — tuplet","text":"Helper function generating tuplet syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tuplet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tuplets — tuplet","text":"","code":"tuplet(x, n, string = NULL, a = 3, b = 2)  triplet(x, n, string = NULL)"},{"path":"https://leonawicz.github.io/tabr/reference/tuplet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tuplets — tuplet","text":"x noteworthy string phrase object. n integer, duration tuplet note, e.g., 8 8th note tuplet. string, character, optional string vector number timesteps x specifies strings play specific note. applies x noteworthy string. integer, notes per tuplet. b integer, beats per tuplet.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tuplet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tuplets — tuplet","text":"phrase","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tuplet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tuplets — tuplet","text":"function gives control tuplet construction. default arguments = 3 b = 2 generates triplet three triplet notes, lasting two thirds beat, take two beats. n} used describe beat duration fraction--measure denominator notation used notes tabr` phrases, e.g., 16th note triplet, 8th note triplet, etc. provide note sequence multiple tuplets row type, connected automatically. necessary call tuplet() time pattern constant. provide complete phrase object, simply wrapped tuplet tag, take care ensure phrase contents make sense part tuplet.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/tuplet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tuplets — tuplet","text":"","code":"tuplet(\"c c# d\", 8) #> <Musical phrase> #> \\tuplet 3/2 4 { <c>8 <cis> <d> } triplet(\"c c# d\", 8) #> <Musical phrase> #> \\tuplet 3/2 4 { <c>8 <cis> <d> } tuplet(\"c c# d c c# d\", 4, a = 6, b = 4) #> <Musical phrase> #> \\tuplet 6/4 1 { <c>4 <cis> <d> <c> <cis> <d> }  p1 <- phrase(\"c c# d\", \"8-. 8( 8)\", \"5*3\") tuplet(p1, 8) #> <Musical phrase> #> \\tuplet 3/2 4 { <c\\5>8-. <cis\\5>8( <d\\5>8) }"},{"path":"https://leonawicz.github.io/tabr/reference/valid-noteinfo.html","id":null,"dir":"Reference","previous_headings":"","what":"Check note info validity — valid-noteinfo","title":"Check note info validity — valid-noteinfo","text":"Check whether note info string comprised exclusively valid note info syntax. noteinfo returns scalar logical result indicating whether entire set contains exclusively valid entries.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/valid-noteinfo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check note info validity — valid-noteinfo","text":"","code":"informable(x, na.rm = FALSE)  as_noteinfo(x, format = NULL)  is_noteinfo(x)"},{"path":"https://leonawicz.github.io/tabr/reference/valid-noteinfo.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check note info validity — valid-noteinfo","text":"x character, note info string. na.rm remove NAs. format NULL character, timestep delimiter format, \"space\" \"vector\".","code":""},{"path":"https://leonawicz.github.io/tabr/reference/valid-noteinfo.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check note info validity — valid-noteinfo","text":"depends function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/valid-noteinfo.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check note info validity — valid-noteinfo","text":"as_noteinfo() can used coerce noteinfo class. Coercion fail string syntax valid note info. Using noteinfo class generally needed user interactive session, available offers print() summary() methods note info strings. class often used functions, functions output note info string attach noteinfo class. format = NULL, timestep delimiter format inferred note info string input. unclear, phrase objects, default space-delimited time.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/valid-noteinfo.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check note info validity — valid-noteinfo","text":"","code":"a <- notate(\"8x\", \"Start here\") x <- paste(a, \"8[stacatto] 8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8*4 1 1\")  informable(x) # is it of 'noteinfo' class; a validity check for any string #> [1] TRUE x <- as_noteinfo(x) # coerce to 'noteinfo' class is_noteinfo(x) # check for 'noteinfo' class #> [1] TRUE x #> <Note info string> #>   Format: space-delimited time #>   Values: 8x;^\"Start_here\" 8[stacatto] 8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8 8 8 8 1 1  summary(x) #> <Note info string> #>   Timesteps: 19 #>   Format: space-delimited time #>   Values: 8x;^\"Start_here\" 8[stacatto] 8-. 16 4.. 16- 16 2^ 2 4. 8( 4)( 4) 8 8 8 8 1 1"},{"path":"https://leonawicz.github.io/tabr/reference/valid-notes.html","id":null,"dir":"Reference","previous_headings":"","what":"Check note and chord validity — valid-notes","title":"Check note and chord validity — valid-notes","text":"Check string comprised exclusively valid note /chord syntax.","code":""},{"path":"https://leonawicz.github.io/tabr/reference/valid-notes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check note and chord validity — valid-notes","text":"","code":"is_note(x, na.rm = FALSE)  is_chord(x, na.rm = FALSE)  noteworthy(x, na.rm = FALSE)  as_noteworthy(x, octaves = NULL, accidentals = NULL, format = NULL)  is_noteworthy(x)"},{"path":"https://leonawicz.github.io/tabr/reference/valid-notes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check note and chord validity — valid-notes","text":"x character, noteworthy string. na.rm remove NAs. octaves NULL character, \"tick\" \"integer\" octave numbering result. accidentals NULL character, represent accidentals, \"flat\" \"sharp\". format NULL character, timestep delimiter format, \"space\" \"vector\".","code":""},{"path":"https://leonawicz.github.io/tabr/reference/valid-notes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check note and chord validity — valid-notes","text":"depends function","code":""},{"path":"https://leonawicz.github.io/tabr/reference/valid-notes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check note and chord validity — valid-notes","text":"is_note() is_chord() vectorized positive results mutually exclusive. noteworthy() also vectorized performs checks, returns scalar logical result indicating whether entire set contains exclusively valid entries. as_noteworthy() can used coerce noteworthy class. Coercion fail string noteworthy. many functions work simple character strings , syntax valid, coerce 'noteworthy' class, recommended use class. functions aggressive, several generic methods implemented class. also offers print() summary() methods noteworthy strings. added benefit using as_noteworthy() conform notes noteworthy string specific formatting accidentals octave numbering. Functions output noteworthy string attach noteworthy class. octaves, accidentals, format NULL, formatting inferred noteworthy string input. mixed formats present, tick format default octave numbering flats default accidentals.","code":""},{"path":[]},{"path":"https://leonawicz.github.io/tabr/reference/valid-notes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check note and chord validity — valid-notes","text":"","code":"x <- \"a# b_ c, d'' e3 g_4 A m c2e_2g2 cegh\" # includes invalid syntax data.frame(   x = strsplit(x, \" \")[[1]],   note = is_note(x),   chord = is_chord(x),   either = noteworthy(x)) #>          x  note chord either #> 1       a#  TRUE FALSE  FALSE #> 2       b_  TRUE FALSE  FALSE #> 3       c,  TRUE FALSE  FALSE #> 4      d''  TRUE FALSE  FALSE #> 5       e3  TRUE FALSE  FALSE #> 6      g_4  TRUE FALSE  FALSE #> 7        A FALSE FALSE  FALSE #> 8        m FALSE FALSE  FALSE #> 9  c2e_2g2 FALSE  TRUE  FALSE #> 10    cegh FALSE FALSE  FALSE  is_diatonic(\"ace ac#e d e_\", \"c\") #> [1]  TRUE FALSE  TRUE FALSE  x <- \"a# b_ c,~ c, d'' e3 g_4 c2e_2g2\" noteworthy(x) # is it noteworthy; a validity check for any string #> [1] TRUE x <- as_noteworthy(x) # coerce to 'noteworthy' class, conform formatting is_noteworthy(x) # check for 'noteworthy' class #> [1] TRUE x #> <Noteworthy string> #>   Format: space-delimited time #>   Values: b_ b_ c,~ c, d'' e g_' <c,e_,g,>  summary(x) #> <Noteworthy string> #>   Timesteps: 8 (7 notes, 1 chord) #>   Octaves: tick #>   Accidentals: flat #>   Format: space-delimited time #>   Values: b_ b_ c,~ c, d'' e g_' <c,e_,g,>  x <- as_noteworthy(x, format = \"vector\", octaves = \"integer\",                    accidentals = \"flat\") x #> <Noteworthy string> #>   Format: vectorized time #>   Values: b_ b_ c2~ c2 d5 e g_4 <c2e_2g2>  summary(x) #> <Noteworthy string> #>   Timesteps: 8 (7 notes, 1 chord) #>   Octaves: integer #>   Accidentals: flat #>   Format: vectorized time #>   Values: b_ b_ c2~ c2 d5 e g_4 <c2e_2g2>"},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-054","dir":"Changelog","previous_headings":"","what":"tabr 0.5.4","title":"tabr 0.5.4","text":"Updated unit tests avoid upcoming breaking change latest testthat package release.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-053","dir":"Changelog","previous_headings":"","what":"tabr 0.5.3","title":"tabr 0.5.3","text":"CRAN release: 2025-07-03 Another attempt fix opaque cruft occurs couple Linux flavors strictly CRAN post-release detect environment.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-052","dir":"Changelog","previous_headings":"","what":"tabr 0.5.2","title":"tabr 0.5.2","text":"CRAN release: 2025-04-28 CRAN-required updates. Update documentation.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-051","dir":"Changelog","previous_headings":"","what":"tabr 0.5.1","title":"tabr 0.5.1","text":"CRAN release: 2024-09-11 Minor updates.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-050","dir":"Changelog","previous_headings":"","what":"tabr 0.5.0","title":"tabr 0.5.0","text":"CRAN release: 2024-06-29 Refactored made improvements plot_fretboard() plot_chord() including addition fret_labels fret_offset arguments. Updated tests documentation.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-049","dir":"Changelog","previous_headings":"","what":"tabr 0.4.9","title":"tabr 0.4.9","text":"CRAN release: 2023-09-21 Added required package alias documentation. Various minor improvements, bug fixes, updates, including building newer versions LilyPond (see tabr_lilypond_api()). General documentation updates.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-045","dir":"Changelog","previous_headings":"","what":"tabr 0.4.5","title":"tabr 0.4.5","text":"CRAN release: 2021-02-20 LilyPond API built tested newer version LilyPond (see tabr_lilypond_api()). Minor fixes documentation updates.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-044","dir":"Changelog","previous_headings":"","what":"tabr 0.4.4","title":"tabr 0.4.4","text":"CRAN release: 2020-11-17 Documentation updates: readme, help docs, new vignette.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-043","dir":"Changelog","previous_headings":"","what":"tabr 0.4.3","title":"tabr 0.4.3","text":"CRAN release: 2020-05-05 Bug fix dyads freq_ratio(). Updated generic method implementations required working dplyr 1.0+.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-042","dir":"Changelog","previous_headings":"","what":"tabr 0.4.2","title":"tabr 0.4.2","text":"CRAN release: 2020-03-17 Added freq_ratio() generic generating data frame frequency ratios frequencies, noteworthy objects, music objects. Added utility functions retrieving LilyPond version installation directory tabr LilyPond API details. Fixed bug multiple sharps tuning broke tab staff string label LilyPond syntax. Updated documentation.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-041","dir":"Changelog","previous_headings":"","what":"tabr 0.4.1","title":"tabr 0.4.1","text":"CRAN release: 2020-02-09 Fixed pitch_freq() documentation error. Fixed bug relating multiple labels as_music(). Fixed bug lyrics parsed correctly rests present music object rendering functions. Fixed bug explicitly added bar inside quotes failed due line break inside string. bar argument phrase() (associated functions) now NULL default, character, rather simply TRUE FALSE. string provided, interpreted LilyPond bar notation. E.g., bar = \"|\" adds LilyPond syntax \\bar \"|\" end phrase. bar check desired, TRUE still accepted insert bar check rather literal bar. FALSE treated NULL completeness. Handle extra whitespace pc() pn(). Fixed bug final note scale dropped scale_note(). Unit test updates. Documentation updates.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-040","dir":"Changelog","previous_headings":"","what":"tabr 0.4.0","title":"tabr 0.4.0","text":"CRAN release: 2019-12-03 Breaking change: major refactor track() function. relative transposed keys. Now takes explicit key argument overrides global key sheet music render functions. arguments simplified rearranged. Refactored many package functions. behavior unchanged, breaking changes made based intentional shifts perspective functions user interact . included changes function arguments well redefinition certain functions . Substantial code optimization done, overhauling much package process. Vectorized functions previously operated note note. Generalized functions previously accept notes chords, case case basis ways meaningful sensible handling chords. Added new classes noteinfo complement noteworthy associated functions. Added new class music builds upon combination noteworthy noteinfo, similar content phrase maintaining structure tabr classes data manipulation analysis. Added implementations several common R functions including primitives like c, length, [ used special classes available tabr. Added logical operator methods noteworthy class. Refactored basic metadata functions generics dispatch new classes rather working noteworthy objects. example, time_format. Added native triplet support note info using t-prefix, e.g., 4 4] t8 t8- t8^ 4. Support extends music objects now also phrase(), alleviates reliance triplet() function limitations. Added lyrics class parallels structure behavior classes; added associated functions generic method implementations. Added lyrics argument support music object construction transformations. Added lyrics argument track* functions support combining lyrics existing phrase object. Added render_music* functions making simple sheet music snippets directly music objects. abstracts phrase() |> track() [|> trackbind()] |> score() |> render_*() pipeline user simpler music essentially single voice, single track. Added plot_music* function wrappers around corresponding render_music* functions abstract external LilyPond process. Added support render_music* plot_music* functions automatically handle lyrics contained music object. Added support auto-cropping rendered sheet music output format png. Added transparent background png support. Added colors argument takes named list color overrides lilypond() render_* functions. Added MIDI file read support (requires optional tuneR installation) set functions inspecting manipulating table MIDI music data. Added initial support conversion MIDI file input noteworthy, noteinfo, music phrase classes MIDI data can analyzed, transformed, edited rendered sheet music new MIDI file. Added functions music data manipulation analysis. Added functions mapping noteworthy strings, phrase objects, data frames. Added functions summarizing times durations noteinfo music objects. Added syntax converters from_chorrrds() (chord output chorrrds package) from_music21(), converting music notation syntax tabr syntax. Added track_* wrapper functions provide better default track arguments different instruments use cases. Added render_tab() alias tab() consistent naming, functions render_score() render_midi() simpler wrappers around tab() appropriate fewer arguments appropriate argument defaults. Added new vignettes syntax conversion rendering chord charts. Updated vignettes, readme documentation. Made improvements print method phrase objects. Added rests argument note metadata functions. Breaking change: Added support many articulations. abbreviated syntax options beginning hyphen: -., --, -+, etc. Otherwise spelled bracketed text: -. [staccato]. break old form staccato ] longer allowed. Switch -. [staccato]. leading - cause conflict single -, continues represent slide notation. need (support ) s-suffix string numbering. instances single string number inputs assumed starting string additional strings inferred consecutively. Improvements plot_fretboard() (renamed fretboard_plot) added wrapper function plot_chord() convenient chord diagrams. Minor bug fixes. Significantly simplified LilyPond syntax generated LilyPond files adding simplify_phrase() new (default) argument lilypond(), simplify = TRUE, also used associated render_* functions. Thank fnord-repeater several helpful suggestions insights well example code helped make transcription pipeline better. Thank Han Oostdijk additional bug fixes improvements code transcription pipeline.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-035","dir":"Changelog","previous_headings":"","what":"tabr 0.3.5","title":"tabr 0.3.5","text":"CRAN release: 2019-10-06 Added alternate input specification sf_phrase(). Instead providing first three function arguments, string, fret info, separately, can now provide everything first input string single character string containing three components separated semicolons. makes easier reason input time step rather argument. Added chord helpers: chord_root(), chord_top(), chord_slice(), chord_is_major(), chord_is_minor(). Added notation-frequency conversion helpers: pitch_freq(), freq_pitch() related functions. Added several functions inspecting manipulating noteworthy strings. Code documentation formatting style overhaul based stricter linting rules. Updated documentation unit tests.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-031","dir":"Changelog","previous_headings":"","what":"tabr 0.3.1","title":"tabr 0.3.1","text":"Added no_tab argument track() allowing suppression tab staff music staff included, e.g., vocal tracks. no_tab-associated documentation unit test updates. Deprecated dup glue. Now use pn repeating phrases n times pc concatenating multiple phrases. Updated documentation, examples, vignettes unit tests. Minor bug fixes.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-030","dir":"Changelog","previous_headings":"","what":"tabr 0.3.0","title":"tabr 0.3.0","text":"CRAN release: 2019-06-23 Added fretboard_plot making fretboard diagrams outside LilyPond tablature pipeline. necessitates importing ggplot2. Added functions phrase validation, coercion decomposition back original character string inputs. Added functions note, pitch, chord octave equivalence checks. Added collection functions constructing working common chords. chord constructors among chord_*-named functions also shorter x*-named aliases. “piano chords,” .e., based condensed, defining intervals. Added guitarChords dataset containing several thousand formations guitar chord voicings. Added helper functions use guitarChords obtaining guitar chord information mapping different defining properties chord, notably addition gc_notes() gc_fretboard() mapping chord names noteworthy strings fretboard diagram syntax. Added helper functions working basic note/pitch strings. Added helper functions working musical scales modes. Added helper functions working musical intervals. Added noteworthy class, used internally, optional users (includes custom print summary methods). Added mainIntervals dataset. Added internal checks note chord syntax validity across functions work string representations (pre-phrase object construction). Update older functions utilize new, robust stricter validation checks offer consistent noteworthy class output. updated transpose() handle additional edge cases, including new style option, strip. Updated added new unit tests. Bug fix case NA-valued -chord rests (s r) unnamed output chord_set(). Fixed entry tabrSyntax. Fix class assignment bug updated as_phrase(). Added new column relative interval size internal .keydata helper table. Added new vignettes focusing programming aspect tabr. Updated documentation.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-020","dir":"Changelog","previous_headings":"","what":"tabr 0.2.0","title":"tabr 0.2.0","text":"CRAN release: 2018-05-17 Refactored tuplet() triplet() accept phrase object well character string notes. Previously, notes accepted limiting. argument name changed notes x tuplet() now check class x handle phrase objects accordingly. Added handling silent rests note strings tuplet(). sf_phrase() sfp() updated allow returning early notes string opposed entire phrase object. useful just want quick, cleaner string representation notes mapped string/fret combinations. Minor updates .onLoad non-Windows systems. Removed tibble package dependency. Using dplyr suffices. Updated Readme basic example intro vignette. Added updated unit tests. Added lintr Suggests field DESCRIPTION per CRAN maintainer request regarding testthat unit tests.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-012","dir":"Changelog","previous_headings":"","what":"tabr 0.1.2","title":"tabr 0.1.2","text":"CRAN release: 2018-04-18 Unwrapped lilypond() example dontrun tag. Switched tempdir() location examples write files. Added LilyPond SystemRequirements field DESCRIPTION. Attempt run file-writing examples file-writing unit tests conditionally LilyPond found system.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-011","dir":"Changelog","previous_headings":"","what":"tabr 0.1.1","title":"tabr 0.1.1","text":"Adjustments meet requirements CRAN resubmission: Updated DESCRIPTION. Adjusted file-writing locations unit tests use tempdir. Add dontrun tag around one last file-writing package example using lilypond(). Update lilypond(), tab(), midily() miditab() work system calls use absolute paths output files instead working relative paths.","code":""},{"path":"https://leonawicz.github.io/tabr/news/index.html","id":"tabr-010","dir":"Changelog","previous_headings":"","what":"tabr 0.1.0","title":"tabr 0.1.0","text":"Added package scaffolding. Developed initial functions music description organization. Developed initial functions generating LilyPond (.ly) files wrapping around system calls LilyPond rendering sheet music pdf png. Added readme basic example. Added initial vignette content. Added unit tests. Added support custom, non-standard guitar tunings instruments different numbers strings, seven. Added .mid .ly .mid tab output convenience functions. Added support multiple voices per staff. Added support transposition music staff relative tablature staff.","code":""}]
